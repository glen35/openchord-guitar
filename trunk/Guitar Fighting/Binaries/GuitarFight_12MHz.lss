
GuitarFight_12MHz.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  00001ed0  00001f84  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001ed0  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000052  00800102  00800102  00001f86  2**0
                  ALLOC
  3 .eeprom       00000168  00810000  00810000  00001f86  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 000000a0  00000000  00000000  000020ee  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000035b  00000000  00000000  0000218e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001a27  00000000  00000000  000024e9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008c3  00000000  00000000  00003f10  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001746  00000000  00000000  000047d3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000180  00000000  00000000  00005f1c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000869  00000000  00000000  0000609c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000af2  00000000  00000000  00006905  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000118  00000000  00000000  000073f7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 96 00 	jmp	0x12c	; 0x12c <__ctors_end>
       4:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
       8:	0c 94 51 0c 	jmp	0x18a2	; 0x18a2 <__vector_2>
       c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      10:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      14:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      18:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      1c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      20:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      24:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      28:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      2c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      30:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      34:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      38:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      3c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      40:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      44:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      48:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      4c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      50:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      54:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      58:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      5c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      60:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      64:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>

00000068 <usbDescriptorHidReport>:
      68:	05 01 09 05 a1 01 15 00 25 01 35 00 45 01 75 01     ........%.5.E.u.
      78:	95 0d 05 09 19 01 29 0d 81 02 95 03 81 01 05 01     ......).........
      88:	25 07 46 3b 01 75 04 95 01 65 14 09 39 81 42 65     %.F;.u...e..9.Be
      98:	00 95 01 81 01 26 ff 00 46 ff 00 09 30 09 31 09     .....&..F...0.1.
      a8:	32 09 35 75 08 95 04 81 02 06 00 ff 0a 21 26 95     2.5u.........!&.
      b8:	08 b1 02 c0                                         ....

000000bc <usbDescriptorString0>:
      bc:	04 03 09 04                                         ....

000000c0 <usbDescriptorStringVendor>:
      c0:	1c 03 4f 00 70 00 65 00 6e 00 43 00 68 00 6f 00     ..O.p.e.n.C.h.o.
      d0:	72 00 64 00 2e 00 6f 00 72 00 67 00                 r.d...o.r.g.

000000dc <usbDescriptorStringDevice>:
      dc:	14 03 56 00 31 00 20 00 47 00 75 00 69 00 74 00     ..V.1. .G.u.i.t.
      ec:	61 00 72 00                                         a.r.

000000f0 <usbDescriptorDevice>:
      f0:	12 01 10 01 00 00 00 08 ba 12 00 02 00 01 01 02     ................
     100:	00 01                                               ..

00000102 <usbDescriptorConfiguration>:
     102:	09 02 29 00 01 01 00 80 32 09 04 00 00 02 03 00     ..).....2.......
     112:	00 00 09 21 01 01 00 01 22 54 00 07 05 81 03 40     ...!...."T.....@
     122:	00 0a 07 05 83 03 40 00 0a 00                       ......@...

0000012c <__ctors_end>:
     12c:	11 24       	eor	r1, r1
     12e:	1f be       	out	0x3f, r1	; 63
     130:	cf ef       	ldi	r28, 0xFF	; 255
     132:	d4 e0       	ldi	r29, 0x04	; 4
     134:	de bf       	out	0x3e, r29	; 62
     136:	cd bf       	out	0x3d, r28	; 61

00000138 <__do_copy_data>:
     138:	11 e0       	ldi	r17, 0x01	; 1
     13a:	a0 e0       	ldi	r26, 0x00	; 0
     13c:	b1 e0       	ldi	r27, 0x01	; 1
     13e:	e0 ed       	ldi	r30, 0xD0	; 208
     140:	fe e1       	ldi	r31, 0x1E	; 30
     142:	02 c0       	rjmp	.+4      	; 0x148 <.do_copy_data_start>

00000144 <.do_copy_data_loop>:
     144:	05 90       	lpm	r0, Z+
     146:	0d 92       	st	X+, r0

00000148 <.do_copy_data_start>:
     148:	a2 30       	cpi	r26, 0x02	; 2
     14a:	b1 07       	cpc	r27, r17
     14c:	d9 f7       	brne	.-10     	; 0x144 <.do_copy_data_loop>

0000014e <__do_clear_bss>:
     14e:	11 e0       	ldi	r17, 0x01	; 1
     150:	a2 e0       	ldi	r26, 0x02	; 2
     152:	b1 e0       	ldi	r27, 0x01	; 1
     154:	01 c0       	rjmp	.+2      	; 0x158 <.do_clear_bss_start>

00000156 <.do_clear_bss_loop>:
     156:	1d 92       	st	X+, r1

00000158 <.do_clear_bss_start>:
     158:	a4 35       	cpi	r26, 0x54	; 84
     15a:	b1 07       	cpc	r27, r17
     15c:	e1 f7       	brne	.-8      	; 0x156 <.do_clear_bss_loop>
     15e:	0e 94 40 07 	call	0xe80	; 0xe80 <main>
     162:	0c 94 66 0f 	jmp	0x1ecc	; 0x1ecc <_exit>

00000166 <__bad_interrupt>:
     166:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000016a <processChords>:
*/
#include "processStringState.h"

void processChords(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
     16a:	0f 93       	push	r16
     16c:	1f 93       	push	r17
     16e:	cf 93       	push	r28
     170:	df 93       	push	r29
     172:	8c 01       	movw	r16, r24
     174:	fb 01       	movw	r30, r22
     176:	ea 01       	movw	r28, r20
     178:	20 e0       	ldi	r18, 0x00	; 0
     17a:	30 e0       	ldi	r19, 0x00	; 0
				data->downOn = 1;
				data->upOn   = 0;
			}
			else
			{
				data->upOn   = 1;
     17c:	91 e0       	ldi	r25, 0x01	; 1
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
	// First take care of registering strumming
	for (int guitarString = 0; guitarString < NUMBER_OF_STRINGS; guitarString++)
	{
		if (stringState[guitarString] & 1)
     17e:	db 01       	movw	r26, r22
     180:	8c 91       	ld	r24, X
     182:	80 ff       	sbrs	r24, 0
     184:	10 c0       	rjmp	.+32     	; 0x1a6 <processChords+0x3c>
		{
			if (guitarString < (NUMBER_OF_STRINGS / 2))
     186:	23 30       	cpi	r18, 0x03	; 3
     188:	31 05       	cpc	r19, r1
     18a:	3c f4       	brge	.+14     	; 0x19a <processChords+0x30>
			{
				data->downOn = 1;
     18c:	d8 01       	movw	r26, r16
     18e:	16 96       	adiw	r26, 0x06	; 6
     190:	9c 93       	st	X, r25
     192:	16 97       	sbiw	r26, 0x06	; 6
				data->upOn   = 0;
     194:	15 96       	adiw	r26, 0x05	; 5
     196:	1c 92       	st	X, r1
     198:	06 c0       	rjmp	.+12     	; 0x1a6 <processChords+0x3c>
			}
			else
			{
				data->upOn   = 1;
     19a:	d8 01       	movw	r26, r16
     19c:	15 96       	adiw	r26, 0x05	; 5
     19e:	9c 93       	st	X, r25
     1a0:	15 97       	sbiw	r26, 0x05	; 5
				data->downOn = 0;
     1a2:	16 96       	adiw	r26, 0x06	; 6
     1a4:	1c 92       	st	X, r1

void processChords(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
	// First take care of registering strumming
	for (int guitarString = 0; guitarString < NUMBER_OF_STRINGS; guitarString++)
     1a6:	2f 5f       	subi	r18, 0xFF	; 255
     1a8:	3f 4f       	sbci	r19, 0xFF	; 255
     1aa:	6e 5f       	subi	r22, 0xFE	; 254
     1ac:	7f 4f       	sbci	r23, 0xFF	; 255
     1ae:	26 30       	cpi	r18, 0x06	; 6
     1b0:	31 05       	cpc	r19, r1
     1b2:	29 f7       	brne	.-54     	; 0x17e <processChords+0x14>
	// the patterns in EEPROM. However, for debouncing, we don't want to
	// mess with the stringState[] array, so we'll mask stringState[i] every
	// time we compare it

	// First, save us some trouble and see if we're not pressing anything at all..
	if (( (stringState[0] & (~1)) == 0b00000000) &&
     1b4:	40 81       	ld	r20, Z
     1b6:	51 81       	ldd	r21, Z+1	; 0x01
     1b8:	4e 7f       	andi	r20, 0xFE	; 254
     1ba:	41 15       	cp	r20, r1
     1bc:	51 05       	cpc	r21, r1
     1be:	d1 f4       	brne	.+52     	; 0x1f4 <processChords+0x8a>
     1c0:	82 81       	ldd	r24, Z+2	; 0x02
     1c2:	93 81       	ldd	r25, Z+3	; 0x03
     1c4:	8e 7f       	andi	r24, 0xFE	; 254
     1c6:	89 2b       	or	r24, r25
     1c8:	a9 f4       	brne	.+42     	; 0x1f4 <processChords+0x8a>
     1ca:	84 81       	ldd	r24, Z+4	; 0x04
     1cc:	95 81       	ldd	r25, Z+5	; 0x05
     1ce:	8e 7f       	andi	r24, 0xFE	; 254
     1d0:	89 2b       	or	r24, r25
     1d2:	81 f4       	brne	.+32     	; 0x1f4 <processChords+0x8a>
     1d4:	86 81       	ldd	r24, Z+6	; 0x06
     1d6:	97 81       	ldd	r25, Z+7	; 0x07
     1d8:	8e 7f       	andi	r24, 0xFE	; 254
     1da:	89 2b       	or	r24, r25
     1dc:	59 f4       	brne	.+22     	; 0x1f4 <processChords+0x8a>
     1de:	80 85       	ldd	r24, Z+8	; 0x08
     1e0:	91 85       	ldd	r25, Z+9	; 0x09
     1e2:	8e 7f       	andi	r24, 0xFE	; 254
     1e4:	89 2b       	or	r24, r25
     1e6:	31 f4       	brne	.+12     	; 0x1f4 <processChords+0x8a>
     1e8:	82 85       	ldd	r24, Z+10	; 0x0a
     1ea:	93 85       	ldd	r25, Z+11	; 0x0b
     1ec:	8e 7f       	andi	r24, 0xFE	; 254
     1ee:	89 2b       	or	r24, r25
     1f0:	09 f4       	brne	.+2      	; 0x1f4 <processChords+0x8a>
     1f2:	63 c2       	rjmp	.+1222   	; 0x6ba <__stack+0x1bb>
		return;

	// Now see if what's being played on the fretboard matches any of the button patterns in
	//  buttonStringPatterns
	// green
	if( (stringState[0] & (~1)) == buttonStringPatterns[0][0] &&
     1f4:	88 81       	ld	r24, Y
     1f6:	99 81       	ldd	r25, Y+1	; 0x01
     1f8:	48 17       	cp	r20, r24
     1fa:	59 07       	cpc	r21, r25
     1fc:	61 f5       	brne	.+88     	; 0x256 <processChords+0xec>
     1fe:	82 81       	ldd	r24, Z+2	; 0x02
     200:	93 81       	ldd	r25, Z+3	; 0x03
     202:	8e 7f       	andi	r24, 0xFE	; 254
     204:	2a 81       	ldd	r18, Y+2	; 0x02
     206:	3b 81       	ldd	r19, Y+3	; 0x03
     208:	82 17       	cp	r24, r18
     20a:	93 07       	cpc	r25, r19
     20c:	21 f5       	brne	.+72     	; 0x256 <processChords+0xec>
     20e:	84 81       	ldd	r24, Z+4	; 0x04
     210:	95 81       	ldd	r25, Z+5	; 0x05
     212:	8e 7f       	andi	r24, 0xFE	; 254
     214:	2c 81       	ldd	r18, Y+4	; 0x04
     216:	3d 81       	ldd	r19, Y+5	; 0x05
     218:	82 17       	cp	r24, r18
     21a:	93 07       	cpc	r25, r19
     21c:	e1 f4       	brne	.+56     	; 0x256 <processChords+0xec>
     21e:	86 81       	ldd	r24, Z+6	; 0x06
     220:	97 81       	ldd	r25, Z+7	; 0x07
     222:	8e 7f       	andi	r24, 0xFE	; 254
     224:	2e 81       	ldd	r18, Y+6	; 0x06
     226:	3f 81       	ldd	r19, Y+7	; 0x07
     228:	82 17       	cp	r24, r18
     22a:	93 07       	cpc	r25, r19
     22c:	a1 f4       	brne	.+40     	; 0x256 <processChords+0xec>
     22e:	80 85       	ldd	r24, Z+8	; 0x08
     230:	91 85       	ldd	r25, Z+9	; 0x09
     232:	8e 7f       	andi	r24, 0xFE	; 254
     234:	28 85       	ldd	r18, Y+8	; 0x08
     236:	39 85       	ldd	r19, Y+9	; 0x09
     238:	82 17       	cp	r24, r18
     23a:	93 07       	cpc	r25, r19
     23c:	61 f4       	brne	.+24     	; 0x256 <processChords+0xec>
     23e:	82 85       	ldd	r24, Z+10	; 0x0a
     240:	93 85       	ldd	r25, Z+11	; 0x0b
     242:	8e 7f       	andi	r24, 0xFE	; 254
     244:	2a 85       	ldd	r18, Y+10	; 0x0a
     246:	3b 85       	ldd	r19, Y+11	; 0x0b
     248:	82 17       	cp	r24, r18
     24a:	93 07       	cpc	r25, r19
     24c:	21 f4       	brne	.+8      	; 0x256 <processChords+0xec>
	    (stringState[2] & (~1)) == buttonStringPatterns[0][2] &&
	    (stringState[3] & (~1)) == buttonStringPatterns[0][3] &&
	    (stringState[4] & (~1)) == buttonStringPatterns[0][4] &&
	    (stringState[5] & (~1)) == buttonStringPatterns[0][5]  ) 
		{
			data->greenOn = 1;
     24e:	81 e0       	ldi	r24, 0x01	; 1
     250:	f8 01       	movw	r30, r16
     252:	80 83       	st	Z, r24
     254:	32 c2       	rjmp	.+1124   	; 0x6ba <__stack+0x1bb>
  		}
	// red
	else if( (stringState[0] & (~1)) == buttonStringPatterns[1][0] &&
     256:	de 01       	movw	r26, r28
     258:	1c 96       	adiw	r26, 0x0c	; 12
     25a:	8c 85       	ldd	r24, Y+12	; 0x0c
     25c:	9d 85       	ldd	r25, Y+13	; 0x0d
     25e:	48 17       	cp	r20, r24
     260:	59 07       	cpc	r21, r25
     262:	a9 f5       	brne	.+106    	; 0x2ce <processChords+0x164>
     264:	82 81       	ldd	r24, Z+2	; 0x02
     266:	93 81       	ldd	r25, Z+3	; 0x03
     268:	8e 7f       	andi	r24, 0xFE	; 254
     26a:	12 96       	adiw	r26, 0x02	; 2
     26c:	2d 91       	ld	r18, X+
     26e:	3c 91       	ld	r19, X
     270:	13 97       	sbiw	r26, 0x03	; 3
     272:	82 17       	cp	r24, r18
     274:	93 07       	cpc	r25, r19
     276:	59 f5       	brne	.+86     	; 0x2ce <processChords+0x164>
     278:	84 81       	ldd	r24, Z+4	; 0x04
     27a:	95 81       	ldd	r25, Z+5	; 0x05
     27c:	8e 7f       	andi	r24, 0xFE	; 254
     27e:	14 96       	adiw	r26, 0x04	; 4
     280:	2d 91       	ld	r18, X+
     282:	3c 91       	ld	r19, X
     284:	15 97       	sbiw	r26, 0x05	; 5
     286:	82 17       	cp	r24, r18
     288:	93 07       	cpc	r25, r19
     28a:	09 f5       	brne	.+66     	; 0x2ce <processChords+0x164>
     28c:	86 81       	ldd	r24, Z+6	; 0x06
     28e:	97 81       	ldd	r25, Z+7	; 0x07
     290:	8e 7f       	andi	r24, 0xFE	; 254
     292:	16 96       	adiw	r26, 0x06	; 6
     294:	2d 91       	ld	r18, X+
     296:	3c 91       	ld	r19, X
     298:	17 97       	sbiw	r26, 0x07	; 7
     29a:	82 17       	cp	r24, r18
     29c:	93 07       	cpc	r25, r19
     29e:	b9 f4       	brne	.+46     	; 0x2ce <processChords+0x164>
     2a0:	80 85       	ldd	r24, Z+8	; 0x08
     2a2:	91 85       	ldd	r25, Z+9	; 0x09
     2a4:	8e 7f       	andi	r24, 0xFE	; 254
     2a6:	18 96       	adiw	r26, 0x08	; 8
     2a8:	2d 91       	ld	r18, X+
     2aa:	3c 91       	ld	r19, X
     2ac:	19 97       	sbiw	r26, 0x09	; 9
     2ae:	82 17       	cp	r24, r18
     2b0:	93 07       	cpc	r25, r19
     2b2:	69 f4       	brne	.+26     	; 0x2ce <processChords+0x164>
     2b4:	82 85       	ldd	r24, Z+10	; 0x0a
     2b6:	93 85       	ldd	r25, Z+11	; 0x0b
     2b8:	8e 7f       	andi	r24, 0xFE	; 254
     2ba:	1a 96       	adiw	r26, 0x0a	; 10
     2bc:	2d 91       	ld	r18, X+
     2be:	3c 91       	ld	r19, X
     2c0:	1b 97       	sbiw	r26, 0x0b	; 11
     2c2:	82 17       	cp	r24, r18
     2c4:	93 07       	cpc	r25, r19
     2c6:	19 f4       	brne	.+6      	; 0x2ce <processChords+0x164>
	    (stringState[2] & (~1)) == buttonStringPatterns[1][2] &&
	    (stringState[3] & (~1)) == buttonStringPatterns[1][3] &&
	    (stringState[4] & (~1)) == buttonStringPatterns[1][4] &&
	    (stringState[5] & (~1)) == buttonStringPatterns[1][5]  ) 
		{
			data->redOn = 1;
     2c8:	81 e0       	ldi	r24, 0x01	; 1
     2ca:	d8 01       	movw	r26, r16
     2cc:	f1 c0       	rjmp	.+482    	; 0x4b0 <processChords+0x346>
  		}

	// yellow
	else if( (stringState[0] & (~1)) == buttonStringPatterns[2][0] &&
     2ce:	de 01       	movw	r26, r28
     2d0:	58 96       	adiw	r26, 0x18	; 24
     2d2:	88 8d       	ldd	r24, Y+24	; 0x18
     2d4:	99 8d       	ldd	r25, Y+25	; 0x19
     2d6:	48 17       	cp	r20, r24
     2d8:	59 07       	cpc	r21, r25
     2da:	a9 f5       	brne	.+106    	; 0x346 <processChords+0x1dc>
     2dc:	82 81       	ldd	r24, Z+2	; 0x02
     2de:	93 81       	ldd	r25, Z+3	; 0x03
     2e0:	8e 7f       	andi	r24, 0xFE	; 254
     2e2:	12 96       	adiw	r26, 0x02	; 2
     2e4:	2d 91       	ld	r18, X+
     2e6:	3c 91       	ld	r19, X
     2e8:	13 97       	sbiw	r26, 0x03	; 3
     2ea:	82 17       	cp	r24, r18
     2ec:	93 07       	cpc	r25, r19
     2ee:	59 f5       	brne	.+86     	; 0x346 <processChords+0x1dc>
     2f0:	84 81       	ldd	r24, Z+4	; 0x04
     2f2:	95 81       	ldd	r25, Z+5	; 0x05
     2f4:	8e 7f       	andi	r24, 0xFE	; 254
     2f6:	14 96       	adiw	r26, 0x04	; 4
     2f8:	2d 91       	ld	r18, X+
     2fa:	3c 91       	ld	r19, X
     2fc:	15 97       	sbiw	r26, 0x05	; 5
     2fe:	82 17       	cp	r24, r18
     300:	93 07       	cpc	r25, r19
     302:	09 f5       	brne	.+66     	; 0x346 <processChords+0x1dc>
     304:	86 81       	ldd	r24, Z+6	; 0x06
     306:	97 81       	ldd	r25, Z+7	; 0x07
     308:	8e 7f       	andi	r24, 0xFE	; 254
     30a:	16 96       	adiw	r26, 0x06	; 6
     30c:	2d 91       	ld	r18, X+
     30e:	3c 91       	ld	r19, X
     310:	17 97       	sbiw	r26, 0x07	; 7
     312:	82 17       	cp	r24, r18
     314:	93 07       	cpc	r25, r19
     316:	b9 f4       	brne	.+46     	; 0x346 <processChords+0x1dc>
     318:	80 85       	ldd	r24, Z+8	; 0x08
     31a:	91 85       	ldd	r25, Z+9	; 0x09
     31c:	8e 7f       	andi	r24, 0xFE	; 254
     31e:	18 96       	adiw	r26, 0x08	; 8
     320:	2d 91       	ld	r18, X+
     322:	3c 91       	ld	r19, X
     324:	19 97       	sbiw	r26, 0x09	; 9
     326:	82 17       	cp	r24, r18
     328:	93 07       	cpc	r25, r19
     32a:	69 f4       	brne	.+26     	; 0x346 <processChords+0x1dc>
     32c:	82 85       	ldd	r24, Z+10	; 0x0a
     32e:	93 85       	ldd	r25, Z+11	; 0x0b
     330:	8e 7f       	andi	r24, 0xFE	; 254
     332:	1a 96       	adiw	r26, 0x0a	; 10
     334:	2d 91       	ld	r18, X+
     336:	3c 91       	ld	r19, X
     338:	1b 97       	sbiw	r26, 0x0b	; 11
     33a:	82 17       	cp	r24, r18
     33c:	93 07       	cpc	r25, r19
     33e:	19 f4       	brne	.+6      	; 0x346 <processChords+0x1dc>
	    (stringState[2] & (~1)) == buttonStringPatterns[2][2] &&
	    (stringState[3] & (~1)) == buttonStringPatterns[2][3] &&
	    (stringState[4] & (~1)) == buttonStringPatterns[2][4] &&
	    (stringState[5] & (~1)) == buttonStringPatterns[2][5]  ) 
		{
			 data->yellowOn = 1;
     340:	81 e0       	ldi	r24, 0x01	; 1
     342:	f8 01       	movw	r30, r16
     344:	76 c1       	rjmp	.+748    	; 0x632 <__stack+0x133>
  		}
	// blue
	else if( (stringState[0] & (~1)) == buttonStringPatterns[3][0] &&
     346:	de 01       	movw	r26, r28
     348:	94 96       	adiw	r26, 0x24	; 36
     34a:	8c a1       	ldd	r24, Y+36	; 0x24
     34c:	9d a1       	ldd	r25, Y+37	; 0x25
     34e:	48 17       	cp	r20, r24
     350:	59 07       	cpc	r21, r25
     352:	a9 f5       	brne	.+106    	; 0x3be <processChords+0x254>
     354:	82 81       	ldd	r24, Z+2	; 0x02
     356:	93 81       	ldd	r25, Z+3	; 0x03
     358:	8e 7f       	andi	r24, 0xFE	; 254
     35a:	12 96       	adiw	r26, 0x02	; 2
     35c:	2d 91       	ld	r18, X+
     35e:	3c 91       	ld	r19, X
     360:	13 97       	sbiw	r26, 0x03	; 3
     362:	82 17       	cp	r24, r18
     364:	93 07       	cpc	r25, r19
     366:	59 f5       	brne	.+86     	; 0x3be <processChords+0x254>
     368:	84 81       	ldd	r24, Z+4	; 0x04
     36a:	95 81       	ldd	r25, Z+5	; 0x05
     36c:	8e 7f       	andi	r24, 0xFE	; 254
     36e:	14 96       	adiw	r26, 0x04	; 4
     370:	2d 91       	ld	r18, X+
     372:	3c 91       	ld	r19, X
     374:	15 97       	sbiw	r26, 0x05	; 5
     376:	82 17       	cp	r24, r18
     378:	93 07       	cpc	r25, r19
     37a:	09 f5       	brne	.+66     	; 0x3be <processChords+0x254>
     37c:	86 81       	ldd	r24, Z+6	; 0x06
     37e:	97 81       	ldd	r25, Z+7	; 0x07
     380:	8e 7f       	andi	r24, 0xFE	; 254
     382:	16 96       	adiw	r26, 0x06	; 6
     384:	2d 91       	ld	r18, X+
     386:	3c 91       	ld	r19, X
     388:	17 97       	sbiw	r26, 0x07	; 7
     38a:	82 17       	cp	r24, r18
     38c:	93 07       	cpc	r25, r19
     38e:	b9 f4       	brne	.+46     	; 0x3be <processChords+0x254>
     390:	80 85       	ldd	r24, Z+8	; 0x08
     392:	91 85       	ldd	r25, Z+9	; 0x09
     394:	8e 7f       	andi	r24, 0xFE	; 254
     396:	18 96       	adiw	r26, 0x08	; 8
     398:	2d 91       	ld	r18, X+
     39a:	3c 91       	ld	r19, X
     39c:	19 97       	sbiw	r26, 0x09	; 9
     39e:	82 17       	cp	r24, r18
     3a0:	93 07       	cpc	r25, r19
     3a2:	69 f4       	brne	.+26     	; 0x3be <processChords+0x254>
     3a4:	82 85       	ldd	r24, Z+10	; 0x0a
     3a6:	93 85       	ldd	r25, Z+11	; 0x0b
     3a8:	8e 7f       	andi	r24, 0xFE	; 254
     3aa:	1a 96       	adiw	r26, 0x0a	; 10
     3ac:	2d 91       	ld	r18, X+
     3ae:	3c 91       	ld	r19, X
     3b0:	1b 97       	sbiw	r26, 0x0b	; 11
     3b2:	82 17       	cp	r24, r18
     3b4:	93 07       	cpc	r25, r19
     3b6:	19 f4       	brne	.+6      	; 0x3be <processChords+0x254>
	    (stringState[2] & (~1)) == buttonStringPatterns[3][2] &&
	    (stringState[3] & (~1)) == buttonStringPatterns[3][3] &&
	    (stringState[4] & (~1)) == buttonStringPatterns[3][4] &&
	    (stringState[5] & (~1)) == buttonStringPatterns[3][5]  ) 
		{
			 data->blueOn = 1;
     3b8:	81 e0       	ldi	r24, 0x01	; 1
     3ba:	d8 01       	movw	r26, r16
     3bc:	7c c1       	rjmp	.+760    	; 0x6b6 <__stack+0x1b7>
  		}
	// orange
	else if( (stringState[0] & (~1)) == buttonStringPatterns[4][0] &&
     3be:	de 01       	movw	r26, r28
     3c0:	d0 96       	adiw	r26, 0x30	; 48
     3c2:	88 a9       	ldd	r24, Y+48	; 0x30
     3c4:	99 a9       	ldd	r25, Y+49	; 0x31
     3c6:	48 17       	cp	r20, r24
     3c8:	59 07       	cpc	r21, r25
     3ca:	b1 f5       	brne	.+108    	; 0x438 <processChords+0x2ce>
     3cc:	82 81       	ldd	r24, Z+2	; 0x02
     3ce:	93 81       	ldd	r25, Z+3	; 0x03
     3d0:	8e 7f       	andi	r24, 0xFE	; 254
     3d2:	12 96       	adiw	r26, 0x02	; 2
     3d4:	2d 91       	ld	r18, X+
     3d6:	3c 91       	ld	r19, X
     3d8:	13 97       	sbiw	r26, 0x03	; 3
     3da:	82 17       	cp	r24, r18
     3dc:	93 07       	cpc	r25, r19
     3de:	61 f5       	brne	.+88     	; 0x438 <processChords+0x2ce>
     3e0:	84 81       	ldd	r24, Z+4	; 0x04
     3e2:	95 81       	ldd	r25, Z+5	; 0x05
     3e4:	8e 7f       	andi	r24, 0xFE	; 254
     3e6:	14 96       	adiw	r26, 0x04	; 4
     3e8:	2d 91       	ld	r18, X+
     3ea:	3c 91       	ld	r19, X
     3ec:	15 97       	sbiw	r26, 0x05	; 5
     3ee:	82 17       	cp	r24, r18
     3f0:	93 07       	cpc	r25, r19
     3f2:	11 f5       	brne	.+68     	; 0x438 <processChords+0x2ce>
     3f4:	86 81       	ldd	r24, Z+6	; 0x06
     3f6:	97 81       	ldd	r25, Z+7	; 0x07
     3f8:	8e 7f       	andi	r24, 0xFE	; 254
     3fa:	16 96       	adiw	r26, 0x06	; 6
     3fc:	2d 91       	ld	r18, X+
     3fe:	3c 91       	ld	r19, X
     400:	17 97       	sbiw	r26, 0x07	; 7
     402:	82 17       	cp	r24, r18
     404:	93 07       	cpc	r25, r19
     406:	c1 f4       	brne	.+48     	; 0x438 <processChords+0x2ce>
     408:	80 85       	ldd	r24, Z+8	; 0x08
     40a:	91 85       	ldd	r25, Z+9	; 0x09
     40c:	8e 7f       	andi	r24, 0xFE	; 254
     40e:	18 96       	adiw	r26, 0x08	; 8
     410:	2d 91       	ld	r18, X+
     412:	3c 91       	ld	r19, X
     414:	19 97       	sbiw	r26, 0x09	; 9
     416:	82 17       	cp	r24, r18
     418:	93 07       	cpc	r25, r19
     41a:	71 f4       	brne	.+28     	; 0x438 <processChords+0x2ce>
     41c:	82 85       	ldd	r24, Z+10	; 0x0a
     41e:	93 85       	ldd	r25, Z+11	; 0x0b
     420:	8e 7f       	andi	r24, 0xFE	; 254
     422:	1a 96       	adiw	r26, 0x0a	; 10
     424:	2d 91       	ld	r18, X+
     426:	3c 91       	ld	r19, X
     428:	1b 97       	sbiw	r26, 0x0b	; 11
     42a:	82 17       	cp	r24, r18
     42c:	93 07       	cpc	r25, r19
     42e:	21 f4       	brne	.+8      	; 0x438 <processChords+0x2ce>
	    (stringState[2] & (~1)) == buttonStringPatterns[4][2] &&
	    (stringState[3] & (~1)) == buttonStringPatterns[4][3] &&
	    (stringState[4] & (~1)) == buttonStringPatterns[4][4] &&
	    (stringState[5] & (~1)) == buttonStringPatterns[4][5]  ) 
		{
			 data->orangeOn = 1;
     430:	81 e0       	ldi	r24, 0x01	; 1
     432:	f8 01       	movw	r30, r16
     434:	84 83       	std	Z+4, r24	; 0x04
     436:	41 c1       	rjmp	.+642    	; 0x6ba <__stack+0x1bb>
  		}
	//Green and Red
	else if( (stringState[0] & (~1)) == buttonStringPatterns[5][0] &&
     438:	de 01       	movw	r26, r28
     43a:	dc 96       	adiw	r26, 0x3c	; 60
     43c:	8c ad       	ldd	r24, Y+60	; 0x3c
     43e:	9d ad       	ldd	r25, Y+61	; 0x3d
     440:	48 17       	cp	r20, r24
     442:	59 07       	cpc	r21, r25
     444:	c1 f5       	brne	.+112    	; 0x4b6 <processChords+0x34c>
     446:	82 81       	ldd	r24, Z+2	; 0x02
     448:	93 81       	ldd	r25, Z+3	; 0x03
     44a:	8e 7f       	andi	r24, 0xFE	; 254
     44c:	12 96       	adiw	r26, 0x02	; 2
     44e:	2d 91       	ld	r18, X+
     450:	3c 91       	ld	r19, X
     452:	13 97       	sbiw	r26, 0x03	; 3
     454:	82 17       	cp	r24, r18
     456:	93 07       	cpc	r25, r19
     458:	71 f5       	brne	.+92     	; 0x4b6 <processChords+0x34c>
     45a:	84 81       	ldd	r24, Z+4	; 0x04
     45c:	95 81       	ldd	r25, Z+5	; 0x05
     45e:	8e 7f       	andi	r24, 0xFE	; 254
     460:	14 96       	adiw	r26, 0x04	; 4
     462:	2d 91       	ld	r18, X+
     464:	3c 91       	ld	r19, X
     466:	15 97       	sbiw	r26, 0x05	; 5
     468:	82 17       	cp	r24, r18
     46a:	93 07       	cpc	r25, r19
     46c:	21 f5       	brne	.+72     	; 0x4b6 <processChords+0x34c>
     46e:	86 81       	ldd	r24, Z+6	; 0x06
     470:	97 81       	ldd	r25, Z+7	; 0x07
     472:	8e 7f       	andi	r24, 0xFE	; 254
     474:	16 96       	adiw	r26, 0x06	; 6
     476:	2d 91       	ld	r18, X+
     478:	3c 91       	ld	r19, X
     47a:	17 97       	sbiw	r26, 0x07	; 7
     47c:	82 17       	cp	r24, r18
     47e:	93 07       	cpc	r25, r19
     480:	d1 f4       	brne	.+52     	; 0x4b6 <processChords+0x34c>
     482:	80 85       	ldd	r24, Z+8	; 0x08
     484:	91 85       	ldd	r25, Z+9	; 0x09
     486:	8e 7f       	andi	r24, 0xFE	; 254
     488:	18 96       	adiw	r26, 0x08	; 8
     48a:	2d 91       	ld	r18, X+
     48c:	3c 91       	ld	r19, X
     48e:	19 97       	sbiw	r26, 0x09	; 9
     490:	82 17       	cp	r24, r18
     492:	93 07       	cpc	r25, r19
     494:	81 f4       	brne	.+32     	; 0x4b6 <processChords+0x34c>
     496:	82 85       	ldd	r24, Z+10	; 0x0a
     498:	93 85       	ldd	r25, Z+11	; 0x0b
     49a:	8e 7f       	andi	r24, 0xFE	; 254
     49c:	1a 96       	adiw	r26, 0x0a	; 10
     49e:	2d 91       	ld	r18, X+
     4a0:	3c 91       	ld	r19, X
     4a2:	1b 97       	sbiw	r26, 0x0b	; 11
     4a4:	82 17       	cp	r24, r18
     4a6:	93 07       	cpc	r25, r19
     4a8:	31 f4       	brne	.+12     	; 0x4b6 <processChords+0x34c>
	    (stringState[2] & (~1)) == buttonStringPatterns[5][2] &&
	    (stringState[3] & (~1)) == buttonStringPatterns[5][3] &&
	    (stringState[4] & (~1)) == buttonStringPatterns[5][4] &&
	    (stringState[5] & (~1)) == buttonStringPatterns[5][5]  ) 
		{
			data->greenOn = 1;
     4aa:	81 e0       	ldi	r24, 0x01	; 1
     4ac:	d8 01       	movw	r26, r16
     4ae:	8c 93       	st	X, r24
			data->redOn = 1;
     4b0:	11 96       	adiw	r26, 0x01	; 1
     4b2:	8c 93       	st	X, r24
     4b4:	02 c1       	rjmp	.+516    	; 0x6ba <__stack+0x1bb>
  		}
	//Red and Yellow
	else if( (stringState[0] & (~1)) == buttonStringPatterns[6][0] &&
     4b6:	de 01       	movw	r26, r28
     4b8:	a8 5b       	subi	r26, 0xB8	; 184
     4ba:	bf 4f       	sbci	r27, 0xFF	; 255
     4bc:	8d 91       	ld	r24, X+
     4be:	9c 91       	ld	r25, X
     4c0:	11 97       	sbiw	r26, 0x01	; 1
     4c2:	48 17       	cp	r20, r24
     4c4:	59 07       	cpc	r21, r25
     4c6:	b1 f5       	brne	.+108    	; 0x534 <__stack+0x35>
     4c8:	82 81       	ldd	r24, Z+2	; 0x02
     4ca:	93 81       	ldd	r25, Z+3	; 0x03
     4cc:	8e 7f       	andi	r24, 0xFE	; 254
     4ce:	12 96       	adiw	r26, 0x02	; 2
     4d0:	2d 91       	ld	r18, X+
     4d2:	3c 91       	ld	r19, X
     4d4:	13 97       	sbiw	r26, 0x03	; 3
     4d6:	82 17       	cp	r24, r18
     4d8:	93 07       	cpc	r25, r19
     4da:	61 f5       	brne	.+88     	; 0x534 <__stack+0x35>
     4dc:	84 81       	ldd	r24, Z+4	; 0x04
     4de:	95 81       	ldd	r25, Z+5	; 0x05
     4e0:	8e 7f       	andi	r24, 0xFE	; 254
     4e2:	14 96       	adiw	r26, 0x04	; 4
     4e4:	2d 91       	ld	r18, X+
     4e6:	3c 91       	ld	r19, X
     4e8:	15 97       	sbiw	r26, 0x05	; 5
     4ea:	82 17       	cp	r24, r18
     4ec:	93 07       	cpc	r25, r19
     4ee:	11 f5       	brne	.+68     	; 0x534 <__stack+0x35>
     4f0:	86 81       	ldd	r24, Z+6	; 0x06
     4f2:	97 81       	ldd	r25, Z+7	; 0x07
     4f4:	8e 7f       	andi	r24, 0xFE	; 254
     4f6:	16 96       	adiw	r26, 0x06	; 6
     4f8:	2d 91       	ld	r18, X+
     4fa:	3c 91       	ld	r19, X
     4fc:	17 97       	sbiw	r26, 0x07	; 7
     4fe:	82 17       	cp	r24, r18
     500:	93 07       	cpc	r25, r19
     502:	c1 f4       	brne	.+48     	; 0x534 <__stack+0x35>
     504:	80 85       	ldd	r24, Z+8	; 0x08
     506:	91 85       	ldd	r25, Z+9	; 0x09
     508:	8e 7f       	andi	r24, 0xFE	; 254
     50a:	18 96       	adiw	r26, 0x08	; 8
     50c:	2d 91       	ld	r18, X+
     50e:	3c 91       	ld	r19, X
     510:	19 97       	sbiw	r26, 0x09	; 9
     512:	82 17       	cp	r24, r18
     514:	93 07       	cpc	r25, r19
     516:	71 f4       	brne	.+28     	; 0x534 <__stack+0x35>
     518:	82 85       	ldd	r24, Z+10	; 0x0a
     51a:	93 85       	ldd	r25, Z+11	; 0x0b
     51c:	8e 7f       	andi	r24, 0xFE	; 254
     51e:	1a 96       	adiw	r26, 0x0a	; 10
     520:	2d 91       	ld	r18, X+
     522:	3c 91       	ld	r19, X
     524:	1b 97       	sbiw	r26, 0x0b	; 11
     526:	82 17       	cp	r24, r18
     528:	93 07       	cpc	r25, r19
     52a:	21 f4       	brne	.+8      	; 0x534 <__stack+0x35>
	    (stringState[2] & (~1)) == buttonStringPatterns[6][2] &&
	    (stringState[3] & (~1)) == buttonStringPatterns[6][3] &&
	    (stringState[4] & (~1)) == buttonStringPatterns[6][4] &&
	    (stringState[5] & (~1)) == buttonStringPatterns[6][5]  ) 
		{
			data->redOn = 1;
     52c:	81 e0       	ldi	r24, 0x01	; 1
     52e:	f8 01       	movw	r30, r16
     530:	81 83       	std	Z+1, r24	; 0x01
     532:	7f c0       	rjmp	.+254    	; 0x632 <__stack+0x133>
			data->yellowOn = 1;
  		}
	// Yellow and Blue
	else if( (stringState[0] & (~1)) == buttonStringPatterns[7][0] &&
     534:	de 01       	movw	r26, r28
     536:	ac 5a       	subi	r26, 0xAC	; 172
     538:	bf 4f       	sbci	r27, 0xFF	; 255
     53a:	8d 91       	ld	r24, X+
     53c:	9c 91       	ld	r25, X
     53e:	11 97       	sbiw	r26, 0x01	; 1
     540:	48 17       	cp	r20, r24
     542:	59 07       	cpc	r21, r25
     544:	c1 f5       	brne	.+112    	; 0x5b6 <__stack+0xb7>
     546:	82 81       	ldd	r24, Z+2	; 0x02
     548:	93 81       	ldd	r25, Z+3	; 0x03
     54a:	8e 7f       	andi	r24, 0xFE	; 254
     54c:	12 96       	adiw	r26, 0x02	; 2
     54e:	2d 91       	ld	r18, X+
     550:	3c 91       	ld	r19, X
     552:	13 97       	sbiw	r26, 0x03	; 3
     554:	82 17       	cp	r24, r18
     556:	93 07       	cpc	r25, r19
     558:	71 f5       	brne	.+92     	; 0x5b6 <__stack+0xb7>
     55a:	84 81       	ldd	r24, Z+4	; 0x04
     55c:	95 81       	ldd	r25, Z+5	; 0x05
     55e:	8e 7f       	andi	r24, 0xFE	; 254
     560:	14 96       	adiw	r26, 0x04	; 4
     562:	2d 91       	ld	r18, X+
     564:	3c 91       	ld	r19, X
     566:	15 97       	sbiw	r26, 0x05	; 5
     568:	82 17       	cp	r24, r18
     56a:	93 07       	cpc	r25, r19
     56c:	21 f5       	brne	.+72     	; 0x5b6 <__stack+0xb7>
     56e:	86 81       	ldd	r24, Z+6	; 0x06
     570:	97 81       	ldd	r25, Z+7	; 0x07
     572:	8e 7f       	andi	r24, 0xFE	; 254
     574:	16 96       	adiw	r26, 0x06	; 6
     576:	2d 91       	ld	r18, X+
     578:	3c 91       	ld	r19, X
     57a:	17 97       	sbiw	r26, 0x07	; 7
     57c:	82 17       	cp	r24, r18
     57e:	93 07       	cpc	r25, r19
     580:	d1 f4       	brne	.+52     	; 0x5b6 <__stack+0xb7>
     582:	80 85       	ldd	r24, Z+8	; 0x08
     584:	91 85       	ldd	r25, Z+9	; 0x09
     586:	8e 7f       	andi	r24, 0xFE	; 254
     588:	18 96       	adiw	r26, 0x08	; 8
     58a:	2d 91       	ld	r18, X+
     58c:	3c 91       	ld	r19, X
     58e:	19 97       	sbiw	r26, 0x09	; 9
     590:	82 17       	cp	r24, r18
     592:	93 07       	cpc	r25, r19
     594:	81 f4       	brne	.+32     	; 0x5b6 <__stack+0xb7>
     596:	82 85       	ldd	r24, Z+10	; 0x0a
     598:	93 85       	ldd	r25, Z+11	; 0x0b
     59a:	8e 7f       	andi	r24, 0xFE	; 254
     59c:	1a 96       	adiw	r26, 0x0a	; 10
     59e:	2d 91       	ld	r18, X+
     5a0:	3c 91       	ld	r19, X
     5a2:	1b 97       	sbiw	r26, 0x0b	; 11
     5a4:	82 17       	cp	r24, r18
     5a6:	93 07       	cpc	r25, r19
     5a8:	31 f4       	brne	.+12     	; 0x5b6 <__stack+0xb7>
	    (stringState[2] & (~1)) == buttonStringPatterns[7][2] &&
	    (stringState[3] & (~1)) == buttonStringPatterns[7][3] &&
	    (stringState[4] & (~1)) == buttonStringPatterns[7][4] &&
	    (stringState[5] & (~1)) == buttonStringPatterns[7][5]  ) 
		{
			 data->yellowOn = 1;
     5aa:	81 e0       	ldi	r24, 0x01	; 1
     5ac:	d8 01       	movw	r26, r16
     5ae:	12 96       	adiw	r26, 0x02	; 2
     5b0:	8c 93       	st	X, r24
     5b2:	12 97       	sbiw	r26, 0x02	; 2
     5b4:	80 c0       	rjmp	.+256    	; 0x6b6 <__stack+0x1b7>
			 data->blueOn = 1;
  		}
	// Green and Yellow
	else if( (stringState[0] & (~1)) == buttonStringPatterns[8][0] &&
     5b6:	de 01       	movw	r26, r28
     5b8:	a0 5a       	subi	r26, 0xA0	; 160
     5ba:	bf 4f       	sbci	r27, 0xFF	; 255
     5bc:	8d 91       	ld	r24, X+
     5be:	9c 91       	ld	r25, X
     5c0:	11 97       	sbiw	r26, 0x01	; 1
     5c2:	48 17       	cp	r20, r24
     5c4:	59 07       	cpc	r21, r25
     5c6:	b9 f5       	brne	.+110    	; 0x636 <__stack+0x137>
     5c8:	82 81       	ldd	r24, Z+2	; 0x02
     5ca:	93 81       	ldd	r25, Z+3	; 0x03
     5cc:	8e 7f       	andi	r24, 0xFE	; 254
     5ce:	12 96       	adiw	r26, 0x02	; 2
     5d0:	2d 91       	ld	r18, X+
     5d2:	3c 91       	ld	r19, X
     5d4:	13 97       	sbiw	r26, 0x03	; 3
     5d6:	82 17       	cp	r24, r18
     5d8:	93 07       	cpc	r25, r19
     5da:	69 f5       	brne	.+90     	; 0x636 <__stack+0x137>
     5dc:	84 81       	ldd	r24, Z+4	; 0x04
     5de:	95 81       	ldd	r25, Z+5	; 0x05
     5e0:	8e 7f       	andi	r24, 0xFE	; 254
     5e2:	14 96       	adiw	r26, 0x04	; 4
     5e4:	2d 91       	ld	r18, X+
     5e6:	3c 91       	ld	r19, X
     5e8:	15 97       	sbiw	r26, 0x05	; 5
     5ea:	82 17       	cp	r24, r18
     5ec:	93 07       	cpc	r25, r19
     5ee:	19 f5       	brne	.+70     	; 0x636 <__stack+0x137>
     5f0:	86 81       	ldd	r24, Z+6	; 0x06
     5f2:	97 81       	ldd	r25, Z+7	; 0x07
     5f4:	8e 7f       	andi	r24, 0xFE	; 254
     5f6:	16 96       	adiw	r26, 0x06	; 6
     5f8:	2d 91       	ld	r18, X+
     5fa:	3c 91       	ld	r19, X
     5fc:	17 97       	sbiw	r26, 0x07	; 7
     5fe:	82 17       	cp	r24, r18
     600:	93 07       	cpc	r25, r19
     602:	c9 f4       	brne	.+50     	; 0x636 <__stack+0x137>
     604:	80 85       	ldd	r24, Z+8	; 0x08
     606:	91 85       	ldd	r25, Z+9	; 0x09
     608:	8e 7f       	andi	r24, 0xFE	; 254
     60a:	18 96       	adiw	r26, 0x08	; 8
     60c:	2d 91       	ld	r18, X+
     60e:	3c 91       	ld	r19, X
     610:	19 97       	sbiw	r26, 0x09	; 9
     612:	82 17       	cp	r24, r18
     614:	93 07       	cpc	r25, r19
     616:	79 f4       	brne	.+30     	; 0x636 <__stack+0x137>
     618:	82 85       	ldd	r24, Z+10	; 0x0a
     61a:	93 85       	ldd	r25, Z+11	; 0x0b
     61c:	8e 7f       	andi	r24, 0xFE	; 254
     61e:	1a 96       	adiw	r26, 0x0a	; 10
     620:	2d 91       	ld	r18, X+
     622:	3c 91       	ld	r19, X
     624:	1b 97       	sbiw	r26, 0x0b	; 11
     626:	82 17       	cp	r24, r18
     628:	93 07       	cpc	r25, r19
     62a:	29 f4       	brne	.+10     	; 0x636 <__stack+0x137>
	    (stringState[2] & (~1)) == buttonStringPatterns[8][2] &&
	    (stringState[3] & (~1)) == buttonStringPatterns[8][3] &&
	    (stringState[4] & (~1)) == buttonStringPatterns[8][4] &&
	    (stringState[5] & (~1)) == buttonStringPatterns[8][5]  ) 
		{
			 data->greenOn = 1;
     62c:	81 e0       	ldi	r24, 0x01	; 1
     62e:	f8 01       	movw	r30, r16
     630:	80 83       	st	Z, r24
			 data->yellowOn = 1;
     632:	82 83       	std	Z+2, r24	; 0x02
     634:	42 c0       	rjmp	.+132    	; 0x6ba <__stack+0x1bb>
  		}
	// Red and Blue
	else if( (stringState[0] & (~1)) == buttonStringPatterns[9][0] &&
     636:	de 01       	movw	r26, r28
     638:	a4 59       	subi	r26, 0x94	; 148
     63a:	bf 4f       	sbci	r27, 0xFF	; 255
     63c:	8d 91       	ld	r24, X+
     63e:	9c 91       	ld	r25, X
     640:	11 97       	sbiw	r26, 0x01	; 1
     642:	48 17       	cp	r20, r24
     644:	59 07       	cpc	r21, r25
     646:	c9 f5       	brne	.+114    	; 0x6ba <__stack+0x1bb>
     648:	82 81       	ldd	r24, Z+2	; 0x02
     64a:	93 81       	ldd	r25, Z+3	; 0x03
     64c:	8e 7f       	andi	r24, 0xFE	; 254
     64e:	12 96       	adiw	r26, 0x02	; 2
     650:	2d 91       	ld	r18, X+
     652:	3c 91       	ld	r19, X
     654:	13 97       	sbiw	r26, 0x03	; 3
     656:	82 17       	cp	r24, r18
     658:	93 07       	cpc	r25, r19
     65a:	79 f5       	brne	.+94     	; 0x6ba <__stack+0x1bb>
     65c:	84 81       	ldd	r24, Z+4	; 0x04
     65e:	95 81       	ldd	r25, Z+5	; 0x05
     660:	8e 7f       	andi	r24, 0xFE	; 254
     662:	14 96       	adiw	r26, 0x04	; 4
     664:	2d 91       	ld	r18, X+
     666:	3c 91       	ld	r19, X
     668:	15 97       	sbiw	r26, 0x05	; 5
     66a:	82 17       	cp	r24, r18
     66c:	93 07       	cpc	r25, r19
     66e:	29 f5       	brne	.+74     	; 0x6ba <__stack+0x1bb>
     670:	86 81       	ldd	r24, Z+6	; 0x06
     672:	97 81       	ldd	r25, Z+7	; 0x07
     674:	8e 7f       	andi	r24, 0xFE	; 254
     676:	16 96       	adiw	r26, 0x06	; 6
     678:	2d 91       	ld	r18, X+
     67a:	3c 91       	ld	r19, X
     67c:	17 97       	sbiw	r26, 0x07	; 7
     67e:	82 17       	cp	r24, r18
     680:	93 07       	cpc	r25, r19
     682:	d9 f4       	brne	.+54     	; 0x6ba <__stack+0x1bb>
     684:	80 85       	ldd	r24, Z+8	; 0x08
     686:	91 85       	ldd	r25, Z+9	; 0x09
     688:	8e 7f       	andi	r24, 0xFE	; 254
     68a:	18 96       	adiw	r26, 0x08	; 8
     68c:	2d 91       	ld	r18, X+
     68e:	3c 91       	ld	r19, X
     690:	19 97       	sbiw	r26, 0x09	; 9
     692:	82 17       	cp	r24, r18
     694:	93 07       	cpc	r25, r19
     696:	89 f4       	brne	.+34     	; 0x6ba <__stack+0x1bb>
     698:	82 85       	ldd	r24, Z+10	; 0x0a
     69a:	93 85       	ldd	r25, Z+11	; 0x0b
     69c:	8e 7f       	andi	r24, 0xFE	; 254
     69e:	1a 96       	adiw	r26, 0x0a	; 10
     6a0:	2d 91       	ld	r18, X+
     6a2:	3c 91       	ld	r19, X
     6a4:	1b 97       	sbiw	r26, 0x0b	; 11
     6a6:	82 17       	cp	r24, r18
     6a8:	93 07       	cpc	r25, r19
     6aa:	39 f4       	brne	.+14     	; 0x6ba <__stack+0x1bb>
	    (stringState[2] & (~1)) == buttonStringPatterns[9][2] &&
	    (stringState[3] & (~1)) == buttonStringPatterns[9][3] &&
	    (stringState[4] & (~1)) == buttonStringPatterns[9][4] &&
	    (stringState[5] & (~1)) == buttonStringPatterns[9][5]  ) 
		{
			 data->redOn = 1;
     6ac:	81 e0       	ldi	r24, 0x01	; 1
     6ae:	d8 01       	movw	r26, r16
     6b0:	11 96       	adiw	r26, 0x01	; 1
     6b2:	8c 93       	st	X, r24
     6b4:	11 97       	sbiw	r26, 0x01	; 1
			 data->blueOn = 1;
     6b6:	13 96       	adiw	r26, 0x03	; 3
     6b8:	8c 93       	st	X, r24
  		}

	return;
}
     6ba:	df 91       	pop	r29
     6bc:	cf 91       	pop	r28
     6be:	1f 91       	pop	r17
     6c0:	0f 91       	pop	r16
     6c2:	08 95       	ret

000006c4 <processNotes>:

void processNotes(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
     6c4:	ef 92       	push	r14
     6c6:	ff 92       	push	r15
     6c8:	0f 93       	push	r16
     6ca:	1f 93       	push	r17
     6cc:	cf 93       	push	r28
     6ce:	df 93       	push	r29
     6d0:	dc 01       	movw	r26, r24
     6d2:	fb 01       	movw	r30, r22
	/* If we're playing with notes on a scale, then we have to figure out if the proper note is being
	   played, and also if we strummed the correct string.
	 */
	// First thing, we need to reset the strumming code, since we need to check and see if we 
	//  strummed on the correct string or not
	data->upOn = 0;
     6d4:	15 96       	adiw	r26, 0x05	; 5
     6d6:	1c 92       	st	X, r1
     6d8:	15 97       	sbiw	r26, 0x05	; 5
	data->downOn = 0;
     6da:	16 96       	adiw	r26, 0x06	; 6
     6dc:	1c 92       	st	X, r1
     6de:	16 97       	sbiw	r26, 0x06	; 6
						// are numbered 0-5
	char buttonPressed = 0;
	char strumPressed  = 0;

	//We also hardcode in a down strum on the empty 6th string, for navigation
	if (stringState[0] & 1)
     6e0:	80 81       	ld	r24, Z
     6e2:	80 ff       	sbrs	r24, 0
     6e4:	04 c0       	rjmp	.+8      	; 0x6ee <processNotes+0x2a>
	{
		data->downOn = 1;
     6e6:	81 e0       	ldi	r24, 0x01	; 1
     6e8:	16 96       	adiw	r26, 0x06	; 6
     6ea:	8c 93       	st	X, r24
     6ec:	16 97       	sbiw	r26, 0x06	; 6
     6ee:	7f 01       	movw	r14, r30
     6f0:	fa 01       	movw	r30, r20
     6f2:	ba 01       	movw	r22, r20
     6f4:	6c 5d       	subi	r22, 0xDC	; 220
     6f6:	7f 4f       	sbci	r23, 0xFF	; 255
     6f8:	4f ef       	ldi	r20, 0xFF	; 255
     6fa:	00 e0       	ldi	r16, 0x00	; 0
     6fc:	50 e0       	ldi	r21, 0x00	; 0
					buttonPressed = 1;
					}				
				if (maskedStringState == buttonStringPatterns[4][i] && 
										buttonStringPatterns[4][i] != 0)
				{
					data->orangeOn =  1;
     6fe:	11 e0       	ldi	r17, 0x01	; 1
		data->downOn = 1;
	}

	for (int i = 0; i < NUMBER_OF_STRINGS; i++)
	{
		if (stringState[i] != 0) // Only look at strings that are being touched or strummed
     700:	e7 01       	movw	r28, r14
     702:	88 81       	ld	r24, Y
     704:	99 81       	ldd	r25, Y+1	; 0x01
     706:	00 97       	sbiw	r24, 0x00	; 0
     708:	09 f4       	brne	.+2      	; 0x70c <processNotes+0x48>
     70a:	7b c0       	rjmp	.+246    	; 0x802 <processNotes+0x13e>
		{
			// Check for open strings being strummed first
			if (stringState[i] == 1) // This means we're strumming an open string
     70c:	81 30       	cpi	r24, 0x01	; 1
     70e:	91 05       	cpc	r25, r1
     710:	c9 f5       	brne	.+114    	; 0x784 <processNotes+0xc0>
			{
				if (stringState[i] == buttonStringPatterns[0][i])
     712:	80 81       	ld	r24, Z
     714:	91 81       	ldd	r25, Z+1	; 0x01
     716:	01 97       	sbiw	r24, 0x01	; 1
     718:	11 f4       	brne	.+4      	; 0x71e <processNotes+0x5a>
				{
					strumOn = i;
					data->greenOn =  1;	
     71a:	1c 93       	st	X, r17
     71c:	45 2f       	mov	r20, r21
				}
				if (stringState[i] == buttonStringPatterns[1][i])
     71e:	e7 01       	movw	r28, r14
     720:	28 81       	ld	r18, Y
     722:	39 81       	ldd	r19, Y+1	; 0x01
     724:	84 85       	ldd	r24, Z+12	; 0x0c
     726:	95 85       	ldd	r25, Z+13	; 0x0d
     728:	28 17       	cp	r18, r24
     72a:	39 07       	cpc	r19, r25
     72c:	21 f4       	brne	.+8      	; 0x736 <processNotes+0x72>
				{
					strumOn = i;
					data->redOn =  1;	
     72e:	11 96       	adiw	r26, 0x01	; 1
     730:	1c 93       	st	X, r17
     732:	11 97       	sbiw	r26, 0x01	; 1
     734:	45 2f       	mov	r20, r21
				}
				if (stringState[i] == buttonStringPatterns[2][i])
     736:	e7 01       	movw	r28, r14
     738:	28 81       	ld	r18, Y
     73a:	39 81       	ldd	r19, Y+1	; 0x01
     73c:	80 8d       	ldd	r24, Z+24	; 0x18
     73e:	91 8d       	ldd	r25, Z+25	; 0x19
     740:	28 17       	cp	r18, r24
     742:	39 07       	cpc	r19, r25
     744:	21 f4       	brne	.+8      	; 0x74e <processNotes+0x8a>
				{
					strumOn = i;
					data->yellowOn =  1;
     746:	12 96       	adiw	r26, 0x02	; 2
     748:	1c 93       	st	X, r17
     74a:	12 97       	sbiw	r26, 0x02	; 2
     74c:	45 2f       	mov	r20, r21
				}				
				if (stringState[i] == buttonStringPatterns[3][i])
     74e:	e7 01       	movw	r28, r14
     750:	28 81       	ld	r18, Y
     752:	39 81       	ldd	r19, Y+1	; 0x01
     754:	eb 01       	movw	r28, r22
     756:	88 81       	ld	r24, Y
     758:	99 81       	ldd	r25, Y+1	; 0x01
     75a:	28 17       	cp	r18, r24
     75c:	39 07       	cpc	r19, r25
     75e:	21 f4       	brne	.+8      	; 0x768 <processNotes+0xa4>
				{
					strumOn = i;
					data->blueOn =  1;
     760:	13 96       	adiw	r26, 0x03	; 3
     762:	1c 93       	st	X, r17
     764:	13 97       	sbiw	r26, 0x03	; 3
     766:	45 2f       	mov	r20, r21
				}				
				if (stringState[i] == buttonStringPatterns[4][i])
     768:	e7 01       	movw	r28, r14
     76a:	28 81       	ld	r18, Y
     76c:	39 81       	ldd	r19, Y+1	; 0x01
     76e:	eb 01       	movw	r28, r22
     770:	8c 85       	ldd	r24, Y+12	; 0x0c
     772:	9d 85       	ldd	r25, Y+13	; 0x0d
     774:	28 17       	cp	r18, r24
     776:	39 07       	cpc	r19, r25
     778:	39 f4       	brne	.+14     	; 0x788 <processNotes+0xc4>
				{
					strumOn = i;
					data->orangeOn =  1;				
     77a:	14 96       	adiw	r26, 0x04	; 4
     77c:	1c 93       	st	X, r17
     77e:	14 97       	sbiw	r26, 0x04	; 4
     780:	45 2f       	mov	r20, r21
     782:	02 c0       	rjmp	.+4      	; 0x788 <processNotes+0xc4>
			}
			 // Now we have checked for strummed notes, we need to check for pressed notes
			 //  so that we can display them for reference as well as use them when strummed
			else
				// First see if we're strumming or not
				strumPressed = stringState[i] & 1;
     784:	08 2f       	mov	r16, r24
     786:	01 70       	andi	r16, 0x01	; 1

				// 	maskedStringState[i] is a masked version of the 
				//  stringState that removes the strum data, so we can match
				//  the fret pressing against the prebuilt pattern without
				//  worrying about strumming or changing the stringState array
				int maskedStringState = stringState[i] & (~1);
     788:	e7 01       	movw	r28, r14
     78a:	28 81       	ld	r18, Y
     78c:	39 81       	ldd	r19, Y+1	; 0x01
     78e:	2e 7f       	andi	r18, 0xFE	; 254

				// Take care of displaying closed notes
				if (maskedStringState == buttonStringPatterns[0][i]&& 
     790:	80 81       	ld	r24, Z
     792:	91 81       	ldd	r25, Z+1	; 0x01
     794:	28 17       	cp	r18, r24
     796:	39 07       	cpc	r19, r25
     798:	21 f4       	brne	.+8      	; 0x7a2 <processNotes+0xde>
     79a:	21 15       	cp	r18, r1
     79c:	31 05       	cpc	r19, r1
     79e:	09 f0       	breq	.+2      	; 0x7a2 <processNotes+0xde>
										buttonStringPatterns[0][i] != 0)
				{
					data->greenOn =  1;	
     7a0:	1c 93       	st	X, r17
					buttonPressed = 1;
				}
				if (maskedStringState == buttonStringPatterns[1][i] && 
     7a2:	84 85       	ldd	r24, Z+12	; 0x0c
     7a4:	95 85       	ldd	r25, Z+13	; 0x0d
     7a6:	28 17       	cp	r18, r24
     7a8:	39 07       	cpc	r19, r25
     7aa:	31 f4       	brne	.+12     	; 0x7b8 <processNotes+0xf4>
     7ac:	21 15       	cp	r18, r1
     7ae:	31 05       	cpc	r19, r1
     7b0:	19 f0       	breq	.+6      	; 0x7b8 <processNotes+0xf4>
										buttonStringPatterns[1][i] != 0)
				{
					data->redOn =  1;	
     7b2:	11 96       	adiw	r26, 0x01	; 1
     7b4:	1c 93       	st	X, r17
     7b6:	11 97       	sbiw	r26, 0x01	; 1
					buttonPressed = 1;
				}
				if (maskedStringState == buttonStringPatterns[2][i] && 
     7b8:	80 8d       	ldd	r24, Z+24	; 0x18
     7ba:	91 8d       	ldd	r25, Z+25	; 0x19
     7bc:	28 17       	cp	r18, r24
     7be:	39 07       	cpc	r19, r25
     7c0:	31 f4       	brne	.+12     	; 0x7ce <processNotes+0x10a>
     7c2:	21 15       	cp	r18, r1
     7c4:	31 05       	cpc	r19, r1
     7c6:	19 f0       	breq	.+6      	; 0x7ce <processNotes+0x10a>
										buttonStringPatterns[2][i] != 0)
					{
					data->yellowOn =  1;
     7c8:	12 96       	adiw	r26, 0x02	; 2
     7ca:	1c 93       	st	X, r17
     7cc:	12 97       	sbiw	r26, 0x02	; 2
					buttonPressed = 1;
				}
				if (maskedStringState == buttonStringPatterns[3][i] && 
     7ce:	eb 01       	movw	r28, r22
     7d0:	88 81       	ld	r24, Y
     7d2:	99 81       	ldd	r25, Y+1	; 0x01
     7d4:	28 17       	cp	r18, r24
     7d6:	39 07       	cpc	r19, r25
     7d8:	31 f4       	brne	.+12     	; 0x7e6 <processNotes+0x122>
     7da:	21 15       	cp	r18, r1
     7dc:	31 05       	cpc	r19, r1
     7de:	19 f0       	breq	.+6      	; 0x7e6 <processNotes+0x122>
										buttonStringPatterns[3][i] != 0)
				{
					data->blueOn =  1;
     7e0:	13 96       	adiw	r26, 0x03	; 3
     7e2:	1c 93       	st	X, r17
     7e4:	13 97       	sbiw	r26, 0x03	; 3
					buttonPressed = 1;
					}				
				if (maskedStringState == buttonStringPatterns[4][i] && 
     7e6:	eb 01       	movw	r28, r22
     7e8:	8c 85       	ldd	r24, Y+12	; 0x0c
     7ea:	9d 85       	ldd	r25, Y+13	; 0x0d
     7ec:	28 17       	cp	r18, r24
     7ee:	39 07       	cpc	r19, r25
     7f0:	29 f4       	brne	.+10     	; 0x7fc <processNotes+0x138>
     7f2:	23 2b       	or	r18, r19
     7f4:	19 f0       	breq	.+6      	; 0x7fc <processNotes+0x138>
										buttonStringPatterns[4][i] != 0)
				{
					data->orangeOn =  1;
     7f6:	14 96       	adiw	r26, 0x04	; 4
     7f8:	1c 93       	st	X, r17
     7fa:	14 97       	sbiw	r26, 0x04	; 4
					buttonPressed = 1;									
				}
					// Now deal with strumming
				if ((buttonPressed = 1) && (strumPressed == 1))
     7fc:	01 30       	cpi	r16, 0x01	; 1
     7fe:	09 f4       	brne	.+2      	; 0x802 <processNotes+0x13e>
     800:	45 2f       	mov	r20, r21
     802:	82 e0       	ldi	r24, 0x02	; 2
     804:	90 e0       	ldi	r25, 0x00	; 0
     806:	e8 0e       	add	r14, r24
     808:	f9 1e       	adc	r15, r25
     80a:	5f 5f       	subi	r21, 0xFF	; 255
     80c:	32 96       	adiw	r30, 0x02	; 2
     80e:	6e 5f       	subi	r22, 0xFE	; 254
     810:	7f 4f       	sbci	r23, 0xFF	; 255
	if (stringState[0] & 1)
	{
		data->downOn = 1;
	}

	for (int i = 0; i < NUMBER_OF_STRINGS; i++)
     812:	56 30       	cpi	r21, 0x06	; 6
     814:	09 f0       	breq	.+2      	; 0x818 <processNotes+0x154>
     816:	74 cf       	rjmp	.-280    	; 0x700 <processNotes+0x3c>
				}
			}
	}

	//Now set the strum buttons properly, so we can have both up and down if we're in this mode
	if ((strumOn >= 0) && (strumOn < (NUMBER_OF_STRINGS / 2)))
     818:	43 30       	cpi	r20, 0x03	; 3
     81a:	20 f4       	brcc	.+8      	; 0x824 <processNotes+0x160>
	{
		data->downOn = 1;
     81c:	81 e0       	ldi	r24, 0x01	; 1
     81e:	16 96       	adiw	r26, 0x06	; 6
     820:	8c 93       	st	X, r24
     822:	0b c0       	rjmp	.+22     	; 0x83a <processNotes+0x176>
	}
	else if ((strumOn >= (NUMBER_OF_STRINGS / 2)) && (strumOn < NUMBER_OF_STRINGS ) && (data->downOn != 1))
     824:	43 50       	subi	r20, 0x03	; 3
     826:	43 30       	cpi	r20, 0x03	; 3
     828:	40 f4       	brcc	.+16     	; 0x83a <processNotes+0x176>
     82a:	16 96       	adiw	r26, 0x06	; 6
     82c:	8c 91       	ld	r24, X
     82e:	16 97       	sbiw	r26, 0x06	; 6
     830:	81 30       	cpi	r24, 0x01	; 1
     832:	19 f0       	breq	.+6      	; 0x83a <processNotes+0x176>
	{
		data->upOn = 1;
     834:	81 e0       	ldi	r24, 0x01	; 1
     836:	15 96       	adiw	r26, 0x05	; 5
     838:	8c 93       	st	X, r24
	}

	return;
}
     83a:	df 91       	pop	r29
     83c:	cf 91       	pop	r28
     83e:	1f 91       	pop	r17
     840:	0f 91       	pop	r16
     842:	ff 90       	pop	r15
     844:	ef 90       	pop	r14
     846:	08 95       	ret

00000848 <processFrets>:

void processFrets(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS], 
									int greenTimers[NUMBER_OF_STRINGS], int triedGreen[NUMBER_OF_STRINGS])
{
     848:	af 92       	push	r10
     84a:	bf 92       	push	r11
     84c:	cf 92       	push	r12
     84e:	df 92       	push	r13
     850:	ff 92       	push	r15
     852:	0f 93       	push	r16
     854:	1f 93       	push	r17
     856:	cf 93       	push	r28
     858:	df 93       	push	r29
     85a:	fc 01       	movw	r30, r24
     85c:	5b 01       	movw	r10, r22
     85e:	d8 01       	movw	r26, r16
     860:	89 01       	movw	r16, r18
     862:	60 e0       	ldi	r22, 0x00	; 0
     864:	70 e0       	ldi	r23, 0x00	; 0
				// now we test to see if the counter has counted high enough, and
				// if it has, then we do record a green hit.
				int test = TCNT1 - greenTimers[guitarString];
		    	if (  (data->greenOn == 0) && (( test > GREEN_TIMER_WAIT) || (test <= 0)) )
		    	{
		        	data->greenOn = 1;
     866:	ff 24       	eor	r15, r15
     868:	f3 94       	inc	r15
		{
		    if (triedGreen[guitarString] == 0) // we didn't touch green last cycle
		    {        
				// so we start the counter and say we did touch it.
		      greenTimers[guitarString] = TCNT1;
		      triedGreen[guitarString] = 1;
     86a:	81 e0       	ldi	r24, 0x01	; 1
     86c:	c8 2e       	mov	r12, r24
     86e:	d1 2c       	mov	r13, r1
		counts up to the GREEN_TIMER_WAIT, red gets activated and green doesn't.
	 */
	for(int guitarString = 0; guitarString < NUMBER_OF_STRINGS; guitarString++)
	{
		//First, we'll see if we're pressing anything at all (ignores strumming)
		if (stringState[guitarString] > 1)
     870:	e5 01       	movw	r28, r10
     872:	88 81       	ld	r24, Y
     874:	99 81       	ldd	r25, Y+1	; 0x01
     876:	02 97       	sbiw	r24, 0x02	; 2
     878:	1c f0       	brlt	.+6      	; 0x880 <processFrets+0x38>
			data->numberOfStringsPressed++;
     87a:	81 85       	ldd	r24, Z+9	; 0x09
     87c:	8f 5f       	subi	r24, 0xFF	; 255
     87e:	81 87       	std	Z+9, r24	; 0x09

		// find the proper value by masking the stringState variable for each fret
		char orange = (stringState[guitarString] & (1<<5));
     880:	e5 01       	movw	r28, r10
     882:	88 81       	ld	r24, Y
		char blue   = (stringState[guitarString] & (1<<4));
     884:	98 2f       	mov	r25, r24
     886:	90 71       	andi	r25, 0x10	; 16
		char yellow = (stringState[guitarString] & (1<<3));
     888:	28 2f       	mov	r18, r24
     88a:	28 70       	andi	r18, 0x08	; 8
		char red    = (stringState[guitarString] & (1<<2));
     88c:	38 2f       	mov	r19, r24
     88e:	34 70       	andi	r19, 0x04	; 4
		char green  = (stringState[guitarString] & (1<<1));
     890:	48 2f       	mov	r20, r24
     892:	42 70       	andi	r20, 0x02	; 2
		if ((orange != 0) && (blue != 0) && (data->orangeOn == 0))
     894:	85 ff       	sbrs	r24, 5
     896:	07 c0       	rjmp	.+14     	; 0x8a6 <processFrets+0x5e>
     898:	99 23       	and	r25, r25
     89a:	71 f0       	breq	.+28     	; 0x8b8 <processFrets+0x70>
     89c:	84 81       	ldd	r24, Z+4	; 0x04
     89e:	88 23       	and	r24, r24
     8a0:	21 f4       	brne	.+8      	; 0x8aa <processFrets+0x62>
		{    
		    data->orangeOn = 1;
     8a2:	f4 82       	std	Z+4, r15	; 0x04
     8a4:	40 c0       	rjmp	.+128    	; 0x926 <processFrets+0xde>
		    triedGreen[guitarString] = 0;
		}
		else if ((blue != 0) && (yellow != 0) && (data->blueOn == 0))
     8a6:	99 23       	and	r25, r25
     8a8:	39 f0       	breq	.+14     	; 0x8b8 <processFrets+0x70>
     8aa:	22 23       	and	r18, r18
     8ac:	71 f0       	breq	.+28     	; 0x8ca <processFrets+0x82>
     8ae:	83 81       	ldd	r24, Z+3	; 0x03
     8b0:	88 23       	and	r24, r24
     8b2:	21 f4       	brne	.+8      	; 0x8bc <processFrets+0x74>
		{
		    data->blueOn = 1;
     8b4:	f3 82       	std	Z+3, r15	; 0x03
     8b6:	37 c0       	rjmp	.+110    	; 0x926 <processFrets+0xde>
		    triedGreen[guitarString] = 0;
		}
		else if ((yellow != 0) && (red != 0) && (data->yellowOn == 0))
     8b8:	22 23       	and	r18, r18
     8ba:	39 f0       	breq	.+14     	; 0x8ca <processFrets+0x82>
     8bc:	33 23       	and	r19, r19
     8be:	71 f0       	breq	.+28     	; 0x8dc <processFrets+0x94>
     8c0:	82 81       	ldd	r24, Z+2	; 0x02
     8c2:	88 23       	and	r24, r24
     8c4:	21 f4       	brne	.+8      	; 0x8ce <processFrets+0x86>
		{
		    data->yellowOn = 1;
     8c6:	f2 82       	std	Z+2, r15	; 0x02
     8c8:	2e c0       	rjmp	.+92     	; 0x926 <processFrets+0xde>
		    triedGreen[guitarString] = 0;
		}
		else if ((red != 0) && (green != 0) && (data->redOn == 0))
     8ca:	33 23       	and	r19, r19
     8cc:	39 f0       	breq	.+14     	; 0x8dc <processFrets+0x94>
     8ce:	44 23       	and	r20, r20
     8d0:	51 f1       	breq	.+84     	; 0x926 <processFrets+0xde>
     8d2:	81 81       	ldd	r24, Z+1	; 0x01
     8d4:	88 23       	and	r24, r24
     8d6:	21 f4       	brne	.+8      	; 0x8e0 <processFrets+0x98>
		{
		    data->redOn = 1;
     8d8:	f1 82       	std	Z+1, r15	; 0x01
     8da:	25 c0       	rjmp	.+74     	; 0x926 <processFrets+0xde>
		    triedGreen[guitarString] = 0;
		}
		else if (green != 0)
     8dc:	44 23       	and	r20, r20
     8de:	19 f1       	breq	.+70     	; 0x926 <processFrets+0xde>
		{
		    if (triedGreen[guitarString] == 0) // we didn't touch green last cycle
     8e0:	8d 91       	ld	r24, X+
     8e2:	9c 91       	ld	r25, X
     8e4:	11 97       	sbiw	r26, 0x01	; 1
     8e6:	89 2b       	or	r24, r25
     8e8:	59 f4       	brne	.+22     	; 0x900 <processFrets+0xb8>
		    {        
				// so we start the counter and say we did touch it.
		      greenTimers[guitarString] = TCNT1;
     8ea:	80 91 84 00 	lds	r24, 0x0084
     8ee:	90 91 85 00 	lds	r25, 0x0085
     8f2:	e8 01       	movw	r28, r16
     8f4:	99 83       	std	Y+1, r25	; 0x01
     8f6:	88 83       	st	Y, r24
		      triedGreen[guitarString] = 1;
     8f8:	11 96       	adiw	r26, 0x01	; 1
     8fa:	dc 92       	st	X, r13
     8fc:	ce 92       	st	-X, r12
     8fe:	16 c0       	rjmp	.+44     	; 0x92c <processFrets+0xe4>
		    }
		    else //triedGreen == true
		    {
				// now we test to see if the counter has counted high enough, and
				// if it has, then we do record a green hit.
				int test = TCNT1 - greenTimers[guitarString];
     900:	20 91 84 00 	lds	r18, 0x0084
     904:	30 91 85 00 	lds	r19, 0x0085
     908:	e8 01       	movw	r28, r16
     90a:	48 81       	ld	r20, Y
     90c:	59 81       	ldd	r21, Y+1	; 0x01
		    	if (  (data->greenOn == 0) && (( test > GREEN_TIMER_WAIT) || (test <= 0)) )
     90e:	80 81       	ld	r24, Z
     910:	88 23       	and	r24, r24
     912:	61 f4       	brne	.+24     	; 0x92c <processFrets+0xe4>
     914:	21 50       	subi	r18, 0x01	; 1
     916:	30 40       	sbci	r19, 0x00	; 0
     918:	24 1b       	sub	r18, r20
     91a:	35 0b       	sbc	r19, r21
     91c:	24 36       	cpi	r18, 0x64	; 100
     91e:	31 05       	cpc	r19, r1
     920:	28 f0       	brcs	.+10     	; 0x92c <processFrets+0xe4>
		    	{
		        	data->greenOn = 1;
     922:	f0 82       	st	Z, r15
     924:	03 c0       	rjmp	.+6      	; 0x92c <processFrets+0xe4>
		    	}
		    }
		}
	    else  //no buttons pressed
	    {
	        triedGreen[guitarString] = 0;
     926:	11 96       	adiw	r26, 0x01	; 1
     928:	1c 92       	st	X, r1
     92a:	1e 92       	st	-X, r1
		the strum has a direction, so if you strum the
		top 3 strings, you strum down, and if you strum
		the bottom 3 strings, you're strumming up.
	*/
		// Check for strumming
		if (stringState[guitarString] & 1)
     92c:	e5 01       	movw	r28, r10
     92e:	88 81       	ld	r24, Y
     930:	80 ff       	sbrs	r24, 0
     932:	08 c0       	rjmp	.+16     	; 0x944 <processFrets+0xfc>
		{
			if (guitarString < (NUMBER_OF_STRINGS / 2))
     934:	63 30       	cpi	r22, 0x03	; 3
     936:	71 05       	cpc	r23, r1
     938:	1c f4       	brge	.+6      	; 0x940 <processFrets+0xf8>
			{
				data->downOn = 1;
     93a:	f6 82       	std	Z+6, r15	; 0x06
				data->upOn   = 0;
     93c:	15 82       	std	Z+5, r1	; 0x05
     93e:	02 c0       	rjmp	.+4      	; 0x944 <processFrets+0xfc>
			}
			else
			{
				data->upOn   = 1;
     940:	f5 82       	std	Z+5, r15	; 0x05
				data->downOn = 0;
     942:	16 82       	std	Z+6, r1	; 0x06
		you don't want that to register as a green button press.  So we do some
		timing on that one, so when you press just green, it starts counting
		instead of turing greenOn on, so if the red fret is turned on before it
		counts up to the GREEN_TIMER_WAIT, red gets activated and green doesn't.
	 */
	for(int guitarString = 0; guitarString < NUMBER_OF_STRINGS; guitarString++)
     944:	6f 5f       	subi	r22, 0xFF	; 255
     946:	7f 4f       	sbci	r23, 0xFF	; 255
     948:	82 e0       	ldi	r24, 0x02	; 2
     94a:	90 e0       	ldi	r25, 0x00	; 0
     94c:	a8 0e       	add	r10, r24
     94e:	b9 1e       	adc	r11, r25
     950:	12 96       	adiw	r26, 0x02	; 2
     952:	0e 5f       	subi	r16, 0xFE	; 254
     954:	1f 4f       	sbci	r17, 0xFF	; 255
     956:	66 30       	cpi	r22, 0x06	; 6
     958:	71 05       	cpc	r23, r1
     95a:	09 f0       	breq	.+2      	; 0x95e <processFrets+0x116>
     95c:	89 cf       	rjmp	.-238    	; 0x870 <processFrets+0x28>
	}	// end of for loop

	// Code for fixing some issues with gap chords (green/yellow, red/blue, etc.)
	// If we're not pressing all the strings, make sure that gap chords are only showing
	// when we press all strings
	if (data->numberOfStringsPressed < NUMBER_OF_STRINGS)
     95e:	81 85       	ldd	r24, Z+9	; 0x09
     960:	86 30       	cpi	r24, 0x06	; 6
     962:	48 f5       	brcc	.+82     	; 0x9b6 <processFrets+0x16e>
	{
		if(data->blueOn   &&
     964:	83 81       	ldd	r24, Z+3	; 0x03
     966:	88 23       	and	r24, r24
     968:	59 f0       	breq	.+22     	; 0x980 <processFrets+0x138>
     96a:	82 81       	ldd	r24, Z+2	; 0x02
     96c:	88 23       	and	r24, r24
     96e:	41 f0       	breq	.+16     	; 0x980 <processFrets+0x138>
     970:	81 81       	ldd	r24, Z+1	; 0x01
     972:	88 23       	and	r24, r24
     974:	29 f0       	breq	.+10     	; 0x980 <processFrets+0x138>
     976:	80 81       	ld	r24, Z
     978:	88 23       	and	r24, r24
     97a:	11 f0       	breq	.+4      	; 0x980 <processFrets+0x138>
		   data->yellowOn &&
		   data->redOn    &&
		   data->greenOn)
		{
		   	data->yellowOn = 0;
     97c:	12 82       	std	Z+2, r1	; 0x02
			data->greenOn  = 0;
     97e:	10 82       	st	Z, r1
		}

		if(data->orangeOn  &&
     980:	84 81       	ldd	r24, Z+4	; 0x04
     982:	88 23       	and	r24, r24
     984:	31 f0       	breq	.+12     	; 0x992 <processFrets+0x14a>
     986:	83 81       	ldd	r24, Z+3	; 0x03
     988:	88 23       	and	r24, r24
     98a:	19 f0       	breq	.+6      	; 0x992 <processFrets+0x14a>
     98c:	82 81       	ldd	r24, Z+2	; 0x02
     98e:	81 11       	cpse	r24, r1
		   data->blueOn   &&
		   data->yellowOn)
		   {data->blueOn = 0;}
     990:	13 82       	std	Z+3, r1	; 0x03
		if(data->blueOn  &&
     992:	83 81       	ldd	r24, Z+3	; 0x03
     994:	88 23       	and	r24, r24
     996:	31 f0       	breq	.+12     	; 0x9a4 <processFrets+0x15c>
     998:	82 81       	ldd	r24, Z+2	; 0x02
     99a:	88 23       	and	r24, r24
     99c:	19 f0       	breq	.+6      	; 0x9a4 <processFrets+0x15c>
     99e:	81 81       	ldd	r24, Z+1	; 0x01
     9a0:	81 11       	cpse	r24, r1
		   data->yellowOn   &&
		   data->redOn)
		   {data->yellowOn = 0;}
     9a2:	12 82       	std	Z+2, r1	; 0x02
		if(data->yellowOn  &&
     9a4:	82 81       	ldd	r24, Z+2	; 0x02
     9a6:	88 23       	and	r24, r24
     9a8:	31 f0       	breq	.+12     	; 0x9b6 <processFrets+0x16e>
     9aa:	81 81       	ldd	r24, Z+1	; 0x01
     9ac:	88 23       	and	r24, r24
     9ae:	19 f0       	breq	.+6      	; 0x9b6 <processFrets+0x16e>
     9b0:	80 81       	ld	r24, Z
     9b2:	81 11       	cpse	r24, r1
		   data->redOn   &&
		   data->greenOn)
		   {data->redOn = 0;}
     9b4:	11 82       	std	Z+1, r1	; 0x01

	}

	return;
}
     9b6:	df 91       	pop	r29
     9b8:	cf 91       	pop	r28
     9ba:	1f 91       	pop	r17
     9bc:	0f 91       	pop	r16
     9be:	ff 90       	pop	r15
     9c0:	df 90       	pop	r13
     9c2:	cf 90       	pop	r12
     9c4:	bf 90       	pop	r11
     9c6:	af 90       	pop	r10
     9c8:	08 95       	ret

000009ca <processStringState>:

void processStringState(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS], char controllerMode, 
									int greenTimers[NUMBER_OF_STRINGS], int triedGreen[NUMBER_OF_STRINGS])
{
     9ca:	ef 92       	push	r14
     9cc:	ff 92       	push	r15
     9ce:	0f 93       	push	r16
     9d0:	1f 93       	push	r17
	if (controllerMode == CHORDS) // If we're playing with Chords - default is FRETS
     9d2:	24 30       	cpi	r18, 0x04	; 4
     9d4:	19 f4       	brne	.+6      	; 0x9dc <processStringState+0x12>
		processChords(data, stringState, buttonStringPatterns);
     9d6:	0e 94 b5 00 	call	0x16a	; 0x16a <processChords>
     9da:	09 c0       	rjmp	.+18     	; 0x9ee <processStringState+0x24>

	else if (controllerMode == NOTES) // We're playing with notes
     9dc:	22 30       	cpi	r18, 0x02	; 2
     9de:	19 f4       	brne	.+6      	; 0x9e6 <processStringState+0x1c>
		processNotes(data, stringState, buttonStringPatterns);
     9e0:	0e 94 62 03 	call	0x6c4	; 0x6c4 <processNotes>
     9e4:	04 c0       	rjmp	.+8      	; 0x9ee <processStringState+0x24>
	
	else // We're playing with frets
		processFrets(data, stringState,	buttonStringPatterns, greenTimers, triedGreen);
     9e6:	98 01       	movw	r18, r16
     9e8:	87 01       	movw	r16, r14
     9ea:	0e 94 24 04 	call	0x848	; 0x848 <processFrets>

	return;	
}
     9ee:	1f 91       	pop	r17
     9f0:	0f 91       	pop	r16
     9f2:	ff 90       	pop	r15
     9f4:	ef 90       	pop	r14
     9f6:	08 95       	ret

000009f8 <displayTransitionState>:

// This simple function takes in the controller mode and sets the
//  data struct to certain patterns to give the user feedback
//  as to what state is being pressed
void displayTransitionState(dataForController* data, int controllerMode)
{
     9f8:	fc 01       	movw	r30, r24
	if (controllerMode == FRETS_TO_NOTES)
     9fa:	61 30       	cpi	r22, 0x01	; 1
     9fc:	71 05       	cpc	r23, r1
     9fe:	21 f4       	brne	.+8      	; 0xa08 <displayTransitionState+0x10>
	{
		data->blueOn = 1;
     a00:	81 e0       	ldi	r24, 0x01	; 1
     a02:	83 83       	std	Z+3, r24	; 0x03
		data->yellowOn = 1;
     a04:	82 83       	std	Z+2, r24	; 0x02
     a06:	08 95       	ret
	}
	else if (controllerMode == NOTES_TO_CHORDS)
     a08:	63 30       	cpi	r22, 0x03	; 3
     a0a:	71 05       	cpc	r23, r1
     a0c:	21 f4       	brne	.+8      	; 0xa16 <displayTransitionState+0x1e>
	{
		data->blueOn = 1;
     a0e:	81 e0       	ldi	r24, 0x01	; 1
     a10:	83 83       	std	Z+3, r24	; 0x03
		data->orangeOn = 1;
     a12:	84 83       	std	Z+4, r24	; 0x04
     a14:	08 95       	ret
	}
	else if (controllerMode == CHORDS_TO_FRETS)
     a16:	65 30       	cpi	r22, 0x05	; 5
     a18:	71 05       	cpc	r23, r1
     a1a:	19 f4       	brne	.+6      	; 0xa22 <displayTransitionState+0x2a>
	{
		data->yellowOn = 1;
     a1c:	81 e0       	ldi	r24, 0x01	; 1
     a1e:	82 83       	std	Z+2, r24	; 0x02
		data->orangeOn = 1;
     a20:	84 83       	std	Z+4, r24	; 0x04
     a22:	08 95       	ret

00000a24 <configSetButtonData>:
/* This function sets up the data struct when we're in config mode so that it shows
 *  the user which colors are currently being programmed.
 */
void configSetButtonData(dataForController* data, int* buttonToAssign, int buttonStringPatterns[][6], 
						int stringState[], char controllerMode, char* plusLock, char* previousPlusOn, int* debounceTimer)
{
     a24:	af 92       	push	r10
     a26:	bf 92       	push	r11
     a28:	cf 92       	push	r12
     a2a:	df 92       	push	r13
     a2c:	ef 92       	push	r14
     a2e:	ff 92       	push	r15
     a30:	0f 93       	push	r16
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
     a36:	fc 01       	movw	r30, r24
     a38:	db 01       	movw	r26, r22
     a3a:	b9 01       	movw	r22, r18
     a3c:	95 01       	movw	r18, r10
	// Since 'colorOn' is 1 when a fret is pressed, we invert, shift, invert, and & it to set the
	// corresponding button bit to zero, which corresponds to a button press.
	if (*buttonToAssign == 0)
     a3e:	8d 91       	ld	r24, X+
     a40:	9c 91       	ld	r25, X
     a42:	11 97       	sbiw	r26, 0x01	; 1
     a44:	00 97       	sbiw	r24, 0x00	; 0
     a46:	19 f4       	brne	.+6      	; 0xa4e <configSetButtonData+0x2a>
		data->greenOn = 1;
     a48:	81 e0       	ldi	r24, 0x01	; 1
     a4a:	80 83       	st	Z, r24
     a4c:	34 c0       	rjmp	.+104    	; 0xab6 <configSetButtonData+0x92>
	else if(*buttonToAssign == 1)
     a4e:	81 30       	cpi	r24, 0x01	; 1
     a50:	91 05       	cpc	r25, r1
     a52:	11 f4       	brne	.+4      	; 0xa58 <configSetButtonData+0x34>
		data->redOn = 1;
     a54:	81 e0       	ldi	r24, 0x01	; 1
     a56:	15 c0       	rjmp	.+42     	; 0xa82 <configSetButtonData+0x5e>
	else if(*buttonToAssign == 2)
     a58:	82 30       	cpi	r24, 0x02	; 2
     a5a:	91 05       	cpc	r25, r1
     a5c:	11 f4       	brne	.+4      	; 0xa62 <configSetButtonData+0x3e>
		data->yellowOn = 1;
     a5e:	81 e0       	ldi	r24, 0x01	; 1
     a60:	23 c0       	rjmp	.+70     	; 0xaa8 <configSetButtonData+0x84>
	else if(*buttonToAssign == 3)
     a62:	83 30       	cpi	r24, 0x03	; 3
     a64:	91 05       	cpc	r25, r1
     a66:	11 f4       	brne	.+4      	; 0xa6c <configSetButtonData+0x48>
		data->blueOn = 1;
     a68:	81 e0       	ldi	r24, 0x01	; 1
     a6a:	24 c0       	rjmp	.+72     	; 0xab4 <configSetButtonData+0x90>
	else if(*buttonToAssign == 4)
     a6c:	84 30       	cpi	r24, 0x04	; 4
     a6e:	91 05       	cpc	r25, r1
     a70:	19 f4       	brne	.+6      	; 0xa78 <configSetButtonData+0x54>
		data->orangeOn = 1;
     a72:	81 e0       	ldi	r24, 0x01	; 1
     a74:	84 83       	std	Z+4, r24	; 0x04
     a76:	1f c0       	rjmp	.+62     	; 0xab6 <configSetButtonData+0x92>
	else if(*buttonToAssign == 5)
     a78:	85 30       	cpi	r24, 0x05	; 5
     a7a:	91 05       	cpc	r25, r1
     a7c:	21 f4       	brne	.+8      	; 0xa86 <configSetButtonData+0x62>
	{
		data->greenOn = 1;
     a7e:	81 e0       	ldi	r24, 0x01	; 1
     a80:	80 83       	st	Z, r24
		data->redOn = 1;
     a82:	81 83       	std	Z+1, r24	; 0x01
     a84:	18 c0       	rjmp	.+48     	; 0xab6 <configSetButtonData+0x92>
	}
	else if(*buttonToAssign == 6)
     a86:	86 30       	cpi	r24, 0x06	; 6
     a88:	91 05       	cpc	r25, r1
     a8a:	19 f4       	brne	.+6      	; 0xa92 <configSetButtonData+0x6e>
	{
		data->redOn = 1;
     a8c:	81 e0       	ldi	r24, 0x01	; 1
     a8e:	81 83       	std	Z+1, r24	; 0x01
     a90:	0b c0       	rjmp	.+22     	; 0xaa8 <configSetButtonData+0x84>
		data->yellowOn = 1;
	}
	else if(*buttonToAssign == 7)
     a92:	87 30       	cpi	r24, 0x07	; 7
     a94:	91 05       	cpc	r25, r1
     a96:	19 f4       	brne	.+6      	; 0xa9e <configSetButtonData+0x7a>
	{
		data->yellowOn = 1;
     a98:	81 e0       	ldi	r24, 0x01	; 1
     a9a:	82 83       	std	Z+2, r24	; 0x02
     a9c:	0b c0       	rjmp	.+22     	; 0xab4 <configSetButtonData+0x90>
		data->blueOn = 1;
	}
	else if(*buttonToAssign == 8)
     a9e:	88 30       	cpi	r24, 0x08	; 8
     aa0:	91 05       	cpc	r25, r1
     aa2:	21 f4       	brne	.+8      	; 0xaac <configSetButtonData+0x88>
	{
		data->greenOn = 1;
     aa4:	81 e0       	ldi	r24, 0x01	; 1
     aa6:	80 83       	st	Z, r24
		data->yellowOn = 1;
     aa8:	82 83       	std	Z+2, r24	; 0x02
     aaa:	05 c0       	rjmp	.+10     	; 0xab6 <configSetButtonData+0x92>
	}
	else if(*buttonToAssign == 9)
     aac:	09 97       	sbiw	r24, 0x09	; 9
     aae:	19 f4       	brne	.+6      	; 0xab6 <configSetButtonData+0x92>
	{
		data->redOn = 1;
     ab0:	81 e0       	ldi	r24, 0x01	; 1
     ab2:	81 83       	std	Z+1, r24	; 0x01
		data->blueOn = 1;
     ab4:	83 83       	std	Z+3, r24	; 0x03
	}



	// Code to debounce our plus button, the current state of plusOn to it's recent history
	if (data->plusOn != 0)  // So we're pressing plus
     ab6:	87 81       	ldd	r24, Z+7	; 0x07
     ab8:	88 23       	and	r24, r24
     aba:	09 f1       	breq	.+66     	; 0xafe <configSetButtonData+0xda>
	{ 
		if (*previousPlusOn == 0)  // If we weren't pressing plus last time through the main loop
     abc:	e6 01       	movw	r28, r12
     abe:	88 81       	ld	r24, Y
     ac0:	88 23       	and	r24, r24
     ac2:	59 f4       	brne	.+22     	; 0xada <configSetButtonData+0xb6>
		{ 
			*debounceTimer = TCNT1;  // Set up a timer
     ac4:	80 91 84 00 	lds	r24, 0x0084
     ac8:	90 91 85 00 	lds	r25, 0x0085
     acc:	e9 01       	movw	r28, r18
     ace:	99 83       	std	Y+1, r25	; 0x01
     ad0:	88 83       	st	Y, r24
			*previousPlusOn = 1;     // remember plus was pressed for the next iteration
     ad2:	81 e0       	ldi	r24, 0x01	; 1
     ad4:	e6 01       	movw	r28, r12
     ad6:	88 83       	st	Y, r24
     ad8:	10 c0       	rjmp	.+32     	; 0xafa <configSetButtonData+0xd6>
			data->plusOn = 0;        // but for now, consider plus not pressed.
		}
		else if ( (TCNT1 - *debounceTimer < DEBOUNCE_DELAY) && (TCNT1 - *debounceTimer >= 0))
     ada:	80 91 84 00 	lds	r24, 0x0084
     ade:	90 91 85 00 	lds	r25, 0x0085
     ae2:	e9 01       	movw	r28, r18
     ae4:	28 81       	ld	r18, Y
     ae6:	39 81       	ldd	r19, Y+1	; 0x01
     ae8:	82 1b       	sub	r24, r18
     aea:	93 0b       	sbc	r25, r19
     aec:	88 5e       	subi	r24, 0xE8	; 232
     aee:	93 40       	sbci	r25, 0x03	; 3
     af0:	40 f4       	brcc	.+16     	; 0xb02 <configSetButtonData+0xde>
     af2:	80 91 84 00 	lds	r24, 0x0084
     af6:	90 91 85 00 	lds	r25, 0x0085
		{
			data->plusOn = 0;  // This keeps telling us plus wasn't pressed until it's been held long enough
     afa:	17 82       	std	Z+7, r1	; 0x07
     afc:	02 c0       	rjmp	.+4      	; 0xb02 <configSetButtonData+0xde>
		}		
	}
	else
	{
		*previousPlusOn = 0; // and if plus wasn't pressed, remember that for next time
     afe:	e6 01       	movw	r28, r12
     b00:	18 82       	st	Y, r1
	}

	// Now, if you press plus, it will lock in whatever string pattern
	// and advance to working on the next pattern.
	if((data->plusOn) && (*plusLock == 0))
     b02:	87 81       	ldd	r24, Z+7	; 0x07
     b04:	88 23       	and	r24, r24
     b06:	09 f4       	brne	.+2      	; 0xb0a <configSetButtonData+0xe6>
     b08:	f7 c0       	rjmp	.+494    	; 0xcf8 <configSetButtonData+0x2d4>
     b0a:	f7 01       	movw	r30, r14
     b0c:	80 81       	ld	r24, Z
     b0e:	88 23       	and	r24, r24
     b10:	09 f0       	breq	.+2      	; 0xb14 <configSetButtonData+0xf0>
     b12:	f4 c0       	rjmp	.+488    	; 0xcfc <configSetButtonData+0x2d8>
	{

		if (controllerMode == CHORDS) 
     b14:	04 30       	cpi	r16, 0x04	; 4
     b16:	09 f0       	breq	.+2      	; 0xb1a <configSetButtonData+0xf6>
     b18:	60 c0       	rjmp	.+192    	; 0xbda <configSetButtonData+0x1b6>
		{   // Set the pattern to nothing pressed
			buttonStringPatterns[*buttonToAssign][0] = 0;
     b1a:	8d 91       	ld	r24, X+
     b1c:	9c 91       	ld	r25, X
     b1e:	11 97       	sbiw	r26, 0x01	; 1
     b20:	fc 01       	movw	r30, r24
     b22:	ee 0f       	add	r30, r30
     b24:	ff 1f       	adc	r31, r31
     b26:	e8 0f       	add	r30, r24
     b28:	f9 1f       	adc	r31, r25
     b2a:	ee 0f       	add	r30, r30
     b2c:	ff 1f       	adc	r31, r31
     b2e:	ee 0f       	add	r30, r30
     b30:	ff 1f       	adc	r31, r31
     b32:	e4 0f       	add	r30, r20
     b34:	f5 1f       	adc	r31, r21
     b36:	11 82       	std	Z+1, r1	; 0x01
     b38:	10 82       	st	Z, r1
			buttonStringPatterns[*buttonToAssign][1] = 0;
     b3a:	8d 91       	ld	r24, X+
     b3c:	9c 91       	ld	r25, X
     b3e:	11 97       	sbiw	r26, 0x01	; 1
     b40:	fc 01       	movw	r30, r24
     b42:	ee 0f       	add	r30, r30
     b44:	ff 1f       	adc	r31, r31
     b46:	e8 0f       	add	r30, r24
     b48:	f9 1f       	adc	r31, r25
     b4a:	ee 0f       	add	r30, r30
     b4c:	ff 1f       	adc	r31, r31
     b4e:	ee 0f       	add	r30, r30
     b50:	ff 1f       	adc	r31, r31
     b52:	e4 0f       	add	r30, r20
     b54:	f5 1f       	adc	r31, r21
     b56:	13 82       	std	Z+3, r1	; 0x03
     b58:	12 82       	std	Z+2, r1	; 0x02
			buttonStringPatterns[*buttonToAssign][2] = 0;
     b5a:	8d 91       	ld	r24, X+
     b5c:	9c 91       	ld	r25, X
     b5e:	11 97       	sbiw	r26, 0x01	; 1
     b60:	fc 01       	movw	r30, r24
     b62:	ee 0f       	add	r30, r30
     b64:	ff 1f       	adc	r31, r31
     b66:	e8 0f       	add	r30, r24
     b68:	f9 1f       	adc	r31, r25
     b6a:	ee 0f       	add	r30, r30
     b6c:	ff 1f       	adc	r31, r31
     b6e:	ee 0f       	add	r30, r30
     b70:	ff 1f       	adc	r31, r31
     b72:	e4 0f       	add	r30, r20
     b74:	f5 1f       	adc	r31, r21
     b76:	15 82       	std	Z+5, r1	; 0x05
     b78:	14 82       	std	Z+4, r1	; 0x04
			buttonStringPatterns[*buttonToAssign][3] = 0;
     b7a:	8d 91       	ld	r24, X+
     b7c:	9c 91       	ld	r25, X
     b7e:	11 97       	sbiw	r26, 0x01	; 1
     b80:	fc 01       	movw	r30, r24
     b82:	ee 0f       	add	r30, r30
     b84:	ff 1f       	adc	r31, r31
     b86:	e8 0f       	add	r30, r24
     b88:	f9 1f       	adc	r31, r25
     b8a:	ee 0f       	add	r30, r30
     b8c:	ff 1f       	adc	r31, r31
     b8e:	ee 0f       	add	r30, r30
     b90:	ff 1f       	adc	r31, r31
     b92:	e4 0f       	add	r30, r20
     b94:	f5 1f       	adc	r31, r21
     b96:	17 82       	std	Z+7, r1	; 0x07
     b98:	16 82       	std	Z+6, r1	; 0x06
			buttonStringPatterns[*buttonToAssign][4] = 0;
     b9a:	8d 91       	ld	r24, X+
     b9c:	9c 91       	ld	r25, X
     b9e:	11 97       	sbiw	r26, 0x01	; 1
     ba0:	fc 01       	movw	r30, r24
     ba2:	ee 0f       	add	r30, r30
     ba4:	ff 1f       	adc	r31, r31
     ba6:	e8 0f       	add	r30, r24
     ba8:	f9 1f       	adc	r31, r25
     baa:	ee 0f       	add	r30, r30
     bac:	ff 1f       	adc	r31, r31
     bae:	ee 0f       	add	r30, r30
     bb0:	ff 1f       	adc	r31, r31
     bb2:	e4 0f       	add	r30, r20
     bb4:	f5 1f       	adc	r31, r21
     bb6:	11 86       	std	Z+9, r1	; 0x09
     bb8:	10 86       	std	Z+8, r1	; 0x08
			buttonStringPatterns[*buttonToAssign][5] = 0;
     bba:	8d 91       	ld	r24, X+
     bbc:	9c 91       	ld	r25, X
     bbe:	11 97       	sbiw	r26, 0x01	; 1
     bc0:	fc 01       	movw	r30, r24
     bc2:	ee 0f       	add	r30, r30
     bc4:	ff 1f       	adc	r31, r31
     bc6:	e8 0f       	add	r30, r24
     bc8:	f9 1f       	adc	r31, r25
     bca:	ee 0f       	add	r30, r30
     bcc:	ff 1f       	adc	r31, r31
     bce:	ee 0f       	add	r30, r30
     bd0:	ff 1f       	adc	r31, r31
     bd2:	e4 0f       	add	r30, r20
     bd4:	f5 1f       	adc	r31, r21
     bd6:	13 86       	std	Z+11, r1	; 0x0b
     bd8:	12 86       	std	Z+10, r1	; 0x0a
		}
			// Assign what's being pressed on the frets to what matches the current button press
		buttonStringPatterns[*buttonToAssign][0] |= stringState[0];
     bda:	8d 91       	ld	r24, X+
     bdc:	9c 91       	ld	r25, X
     bde:	11 97       	sbiw	r26, 0x01	; 1
     be0:	fc 01       	movw	r30, r24
     be2:	ee 0f       	add	r30, r30
     be4:	ff 1f       	adc	r31, r31
     be6:	e8 0f       	add	r30, r24
     be8:	f9 1f       	adc	r31, r25
     bea:	ee 0f       	add	r30, r30
     bec:	ff 1f       	adc	r31, r31
     bee:	ee 0f       	add	r30, r30
     bf0:	ff 1f       	adc	r31, r31
     bf2:	e4 0f       	add	r30, r20
     bf4:	f5 1f       	adc	r31, r21
     bf6:	80 81       	ld	r24, Z
     bf8:	91 81       	ldd	r25, Z+1	; 0x01
     bfa:	eb 01       	movw	r28, r22
     bfc:	28 81       	ld	r18, Y
     bfe:	39 81       	ldd	r19, Y+1	; 0x01
     c00:	82 2b       	or	r24, r18
     c02:	93 2b       	or	r25, r19
     c04:	91 83       	std	Z+1, r25	; 0x01
     c06:	80 83       	st	Z, r24
		buttonStringPatterns[*buttonToAssign][1] |= stringState[1];
     c08:	8d 91       	ld	r24, X+
     c0a:	9c 91       	ld	r25, X
     c0c:	11 97       	sbiw	r26, 0x01	; 1
     c0e:	fc 01       	movw	r30, r24
     c10:	ee 0f       	add	r30, r30
     c12:	ff 1f       	adc	r31, r31
     c14:	e8 0f       	add	r30, r24
     c16:	f9 1f       	adc	r31, r25
     c18:	ee 0f       	add	r30, r30
     c1a:	ff 1f       	adc	r31, r31
     c1c:	ee 0f       	add	r30, r30
     c1e:	ff 1f       	adc	r31, r31
     c20:	e4 0f       	add	r30, r20
     c22:	f5 1f       	adc	r31, r21
     c24:	82 81       	ldd	r24, Z+2	; 0x02
     c26:	93 81       	ldd	r25, Z+3	; 0x03
     c28:	2a 81       	ldd	r18, Y+2	; 0x02
     c2a:	3b 81       	ldd	r19, Y+3	; 0x03
     c2c:	82 2b       	or	r24, r18
     c2e:	93 2b       	or	r25, r19
     c30:	93 83       	std	Z+3, r25	; 0x03
     c32:	82 83       	std	Z+2, r24	; 0x02
		buttonStringPatterns[*buttonToAssign][2] |= stringState[2];
     c34:	8d 91       	ld	r24, X+
     c36:	9c 91       	ld	r25, X
     c38:	11 97       	sbiw	r26, 0x01	; 1
     c3a:	fc 01       	movw	r30, r24
     c3c:	ee 0f       	add	r30, r30
     c3e:	ff 1f       	adc	r31, r31
     c40:	e8 0f       	add	r30, r24
     c42:	f9 1f       	adc	r31, r25
     c44:	ee 0f       	add	r30, r30
     c46:	ff 1f       	adc	r31, r31
     c48:	ee 0f       	add	r30, r30
     c4a:	ff 1f       	adc	r31, r31
     c4c:	e4 0f       	add	r30, r20
     c4e:	f5 1f       	adc	r31, r21
     c50:	84 81       	ldd	r24, Z+4	; 0x04
     c52:	95 81       	ldd	r25, Z+5	; 0x05
     c54:	2c 81       	ldd	r18, Y+4	; 0x04
     c56:	3d 81       	ldd	r19, Y+5	; 0x05
     c58:	82 2b       	or	r24, r18
     c5a:	93 2b       	or	r25, r19
     c5c:	95 83       	std	Z+5, r25	; 0x05
     c5e:	84 83       	std	Z+4, r24	; 0x04
		buttonStringPatterns[*buttonToAssign][3] |= stringState[3];
     c60:	8d 91       	ld	r24, X+
     c62:	9c 91       	ld	r25, X
     c64:	11 97       	sbiw	r26, 0x01	; 1
     c66:	fc 01       	movw	r30, r24
     c68:	ee 0f       	add	r30, r30
     c6a:	ff 1f       	adc	r31, r31
     c6c:	e8 0f       	add	r30, r24
     c6e:	f9 1f       	adc	r31, r25
     c70:	ee 0f       	add	r30, r30
     c72:	ff 1f       	adc	r31, r31
     c74:	ee 0f       	add	r30, r30
     c76:	ff 1f       	adc	r31, r31
     c78:	e4 0f       	add	r30, r20
     c7a:	f5 1f       	adc	r31, r21
     c7c:	86 81       	ldd	r24, Z+6	; 0x06
     c7e:	97 81       	ldd	r25, Z+7	; 0x07
     c80:	2e 81       	ldd	r18, Y+6	; 0x06
     c82:	3f 81       	ldd	r19, Y+7	; 0x07
     c84:	82 2b       	or	r24, r18
     c86:	93 2b       	or	r25, r19
     c88:	97 83       	std	Z+7, r25	; 0x07
     c8a:	86 83       	std	Z+6, r24	; 0x06
		buttonStringPatterns[*buttonToAssign][4] |= stringState[4];
     c8c:	8d 91       	ld	r24, X+
     c8e:	9c 91       	ld	r25, X
     c90:	11 97       	sbiw	r26, 0x01	; 1
     c92:	fc 01       	movw	r30, r24
     c94:	ee 0f       	add	r30, r30
     c96:	ff 1f       	adc	r31, r31
     c98:	e8 0f       	add	r30, r24
     c9a:	f9 1f       	adc	r31, r25
     c9c:	ee 0f       	add	r30, r30
     c9e:	ff 1f       	adc	r31, r31
     ca0:	ee 0f       	add	r30, r30
     ca2:	ff 1f       	adc	r31, r31
     ca4:	e4 0f       	add	r30, r20
     ca6:	f5 1f       	adc	r31, r21
     ca8:	80 85       	ldd	r24, Z+8	; 0x08
     caa:	91 85       	ldd	r25, Z+9	; 0x09
     cac:	28 85       	ldd	r18, Y+8	; 0x08
     cae:	39 85       	ldd	r19, Y+9	; 0x09
     cb0:	82 2b       	or	r24, r18
     cb2:	93 2b       	or	r25, r19
     cb4:	91 87       	std	Z+9, r25	; 0x09
     cb6:	80 87       	std	Z+8, r24	; 0x08
		buttonStringPatterns[*buttonToAssign][5] |= stringState[5];
     cb8:	8d 91       	ld	r24, X+
     cba:	9c 91       	ld	r25, X
     cbc:	11 97       	sbiw	r26, 0x01	; 1
     cbe:	fc 01       	movw	r30, r24
     cc0:	ee 0f       	add	r30, r30
     cc2:	ff 1f       	adc	r31, r31
     cc4:	e8 0f       	add	r30, r24
     cc6:	f9 1f       	adc	r31, r25
     cc8:	ee 0f       	add	r30, r30
     cca:	ff 1f       	adc	r31, r31
     ccc:	ee 0f       	add	r30, r30
     cce:	ff 1f       	adc	r31, r31
     cd0:	e4 0f       	add	r30, r20
     cd2:	f5 1f       	adc	r31, r21
     cd4:	82 85       	ldd	r24, Z+10	; 0x0a
     cd6:	93 85       	ldd	r25, Z+11	; 0x0b
     cd8:	2a 85       	ldd	r18, Y+10	; 0x0a
     cda:	3b 85       	ldd	r19, Y+11	; 0x0b
     cdc:	82 2b       	or	r24, r18
     cde:	93 2b       	or	r25, r19
     ce0:	93 87       	std	Z+11, r25	; 0x0b
     ce2:	82 87       	std	Z+10, r24	; 0x0a

		*plusLock = 1;  // we set up a lock, so we don't assign all the buttons at once
     ce4:	81 e0       	ldi	r24, 0x01	; 1
     ce6:	f7 01       	movw	r30, r14
     ce8:	80 83       	st	Z, r24
		*buttonToAssign += 1;
     cea:	8d 91       	ld	r24, X+
     cec:	9c 91       	ld	r25, X
     cee:	11 97       	sbiw	r26, 0x01	; 1
     cf0:	01 96       	adiw	r24, 0x01	; 1
     cf2:	8d 93       	st	X+, r24
     cf4:	9c 93       	st	X, r25
     cf6:	02 c0       	rjmp	.+4      	; 0xcfc <configSetButtonData+0x2d8>
	}
	else if(data->plusOn == 0)
	{
		*plusLock = 0;
     cf8:	e7 01       	movw	r28, r14
     cfa:	18 82       	st	Y, r1
	}
	return;
}
     cfc:	df 91       	pop	r29
     cfe:	cf 91       	pop	r28
     d00:	0f 91       	pop	r16
     d02:	ff 90       	pop	r15
     d04:	ef 90       	pop	r14
     d06:	df 90       	pop	r13
     d08:	cf 90       	pop	r12
     d0a:	bf 90       	pop	r11
     d0c:	af 90       	pop	r10
     d0e:	08 95       	ret

00000d10 <setPins>:
#include "guitarInitFunctions.h"

void setPins(void)
{
	// Set the fret pins as input pins, with internal resistor
	fret_ddr &= ~(1<<green_pin);        // input
     d10:	21 98       	cbi	0x04, 1	; 4
	fret_port |= (1<<green_pin);		//pull-up enabled	
     d12:	29 9a       	sbi	0x05, 1	; 5
	fret_ddr &= ~(1<<red_pin);
     d14:	22 98       	cbi	0x04, 2	; 4
	fret_port |= (1<<red_pin);
     d16:	2a 9a       	sbi	0x05, 2	; 5
	fret_ddr &= ~(1<<yellow_pin);
     d18:	23 98       	cbi	0x04, 3	; 4
	fret_port |= (1<<yellow_pin);
     d1a:	2b 9a       	sbi	0x05, 3	; 5
	fret_ddr &= ~(1<<blue_pin);
     d1c:	24 98       	cbi	0x04, 4	; 4
	fret_port |= (1<<blue_pin);
     d1e:	2c 9a       	sbi	0x05, 4	; 5
	fret_ddr &= ~(1<<orange_pin);
     d20:	25 98       	cbi	0x04, 5	; 4
	fret_port |= (1<<orange_pin);
     d22:	2d 9a       	sbi	0x05, 5	; 5

	// Set the pins on strumming and plus as inputs, with internal resistor
	misc_ddr &= ~(1<<plus_pin);
     d24:	38 98       	cbi	0x07, 0	; 7
	misc_port |= (1<<plus_pin);
     d26:	40 9a       	sbi	0x08, 0	; 8
	misc_ddr &= ~(1<<minus_pin);
     d28:	39 98       	cbi	0x07, 1	; 7
	misc_port |= (1<<minus_pin);
     d2a:	41 9a       	sbi	0x08, 1	; 8

	pick_ddr &= ~(1<<strum_pin);
     d2c:	3a 98       	cbi	0x07, 2	; 7
	pick_port |= (1<<strum_pin);
     d2e:	42 9a       	sbi	0x08, 2	; 8

	// Set the string pins as output pins, outputting HIGH
	/* MAKE SURE YOU HAVE DIODES OPPOSING THIS CURRENT OUTFLOW! */
	string_ddr |= (1<<first_string);  //output
     d30:	57 9a       	sbi	0x0a, 7	; 10
	string_port |= (1<<first_string); // set high
     d32:	5f 9a       	sbi	0x0b, 7	; 11
	string_ddr |= (1<<second_string);  
     d34:	56 9a       	sbi	0x0a, 6	; 10
	string_port |= (1<<second_string);
     d36:	5e 9a       	sbi	0x0b, 6	; 11
	string_ddr |= (1<<third_string);  
     d38:	55 9a       	sbi	0x0a, 5	; 10
	string_port |= (1<<third_string);
     d3a:	5d 9a       	sbi	0x0b, 5	; 11
	string_ddr |= (1<<fourth_string);  
     d3c:	52 9a       	sbi	0x0a, 2	; 10
	string_port |= (1<<fourth_string);
     d3e:	5a 9a       	sbi	0x0b, 2	; 11
	string_ddr |= (1<<fifth_string);  
     d40:	51 9a       	sbi	0x0a, 1	; 10
	string_port |= (1<<fifth_string);
     d42:	59 9a       	sbi	0x0b, 1	; 11
	string_ddr |= (1<<sixth_string);  
     d44:	50 9a       	sbi	0x0a, 0	; 10
	string_port |= (1<<sixth_string);
     d46:	58 9a       	sbi	0x0b, 0	; 11
}
     d48:	08 95       	ret

00000d4a <setTimer>:

void setTimer(void) //This sets up a timer to handle the green button thing
{
	PRR &= ~(1<<PRTIM1);	// ensure power to Timer/Counter1
     d4a:	e4 e6       	ldi	r30, 0x64	; 100
     d4c:	f0 e0       	ldi	r31, 0x00	; 0
     d4e:	80 81       	ld	r24, Z
     d50:	87 7f       	andi	r24, 0xF7	; 247
     d52:	80 83       	st	Z, r24

	TCCR1A &= ~(1<<COM1A1);  // This prevents OC2A pin from doing anything
     d54:	e0 e8       	ldi	r30, 0x80	; 128
     d56:	f0 e0       	ldi	r31, 0x00	; 0
     d58:	80 81       	ld	r24, Z
     d5a:	8f 77       	andi	r24, 0x7F	; 127
     d5c:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<COM1A0);  //  to the pins on the chip. Otherwise, we might
     d5e:	80 81       	ld	r24, Z
     d60:	8f 7b       	andi	r24, 0xBF	; 191
     d62:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<COM1B1);  //  get signals coming out of some of the pins we might use
     d64:	80 81       	ld	r24, Z
     d66:	8f 7d       	andi	r24, 0xDF	; 223
     d68:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<COM1B0);
     d6a:	80 81       	ld	r24, Z
     d6c:	8f 7e       	andi	r24, 0xEF	; 239
     d6e:	80 83       	st	Z, r24

	TCCR1A &= ~(1<<WGM11);  // These bits set up normal mode on the Waveform Generation
     d70:	80 81       	ld	r24, Z
     d72:	8d 7f       	andi	r24, 0xFD	; 253
     d74:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<WGM10);  // This means that the counter acts like a normal timer,
     d76:	80 81       	ld	r24, Z
     d78:	8e 7f       	andi	r24, 0xFE	; 254
     d7a:	80 83       	st	Z, r24
	TCCR1B &= ~(1<<WGM12);  // not some sort of fancy digital-analog converter or anything
     d7c:	e1 e8       	ldi	r30, 0x81	; 129
     d7e:	f0 e0       	ldi	r31, 0x00	; 0
     d80:	80 81       	ld	r24, Z
     d82:	87 7f       	andi	r24, 0xF7	; 247
     d84:	80 83       	st	Z, r24
	TCCR1B &= ~(1<<WGM13);  // It counts up to 65536 and overflows to zero
     d86:	80 81       	ld	r24, Z
     d88:	8f 7e       	andi	r24, 0xEF	; 239
     d8a:	80 83       	st	Z, r24

	TCCR1B |= (1<<CS12);   // These set the clock to CPU (8MHz) / 1024 
     d8c:	80 81       	ld	r24, Z
     d8e:	84 60       	ori	r24, 0x04	; 4
     d90:	80 83       	st	Z, r24
	TCCR1B &= ~(1<<CS11);  // or roughly 8 kHz (7.8125 kHz)
     d92:	80 81       	ld	r24, Z
     d94:	8d 7f       	andi	r24, 0xFD	; 253
     d96:	80 83       	st	Z, r24
	TCCR1B |= (1<<CS10);   // When counting from zero to 0xFFFF, it takes about 8 seconds
     d98:	80 81       	ld	r24, Z
     d9a:	81 60       	ori	r24, 0x01	; 1
     d9c:	80 83       	st	Z, r24

	// The counter's value is stored in TCNT1
}
     d9e:	08 95       	ret

00000da0 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
     da0:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     da2:	f9 99       	sbic	0x1f, 1	; 31
     da4:	fe cf       	rjmp	.-4      	; 0xda2 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     da6:	32 bd       	out	0x22, r19	; 34
     da8:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     daa:	f8 9a       	sbi	0x1f, 0	; 31
     dac:	80 b5       	in	r24, 0x20	; 32
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
     dae:	08 95       	ret

00000db0 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
     db0:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     db2:	f9 99       	sbic	0x1f, 1	; 31
     db4:	fe cf       	rjmp	.-4      	; 0xdb2 <eeprom_write_byte+0x2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     db6:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     db8:	32 bd       	out	0x22, r19	; 34
     dba:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
     dbc:	60 bd       	out	0x20, r22	; 32

    __asm__ __volatile__ (
     dbe:	0f b6       	in	r0, 0x3f	; 63
     dc0:	f8 94       	cli
     dc2:	fa 9a       	sbi	0x1f, 2	; 31
     dc4:	f9 9a       	sbi	0x1f, 1	; 31
     dc6:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
     dc8:	08 95       	ret

00000dca <readFrets>:
};

//readF reads the frets for a single string, and returns an int acting as a boolean array
//  telling which frets are being touched by the string.
int readFrets(int guitarString)
{
     dca:	1f 93       	push	r17
     dcc:	cf 93       	push	r28
     dce:	df 93       	push	r29
  	string_port &= ~(1<<guitarString);  // Set the string LOW
     dd0:	9b b1       	in	r25, 0x0b	; 11
     dd2:	21 e0       	ldi	r18, 0x01	; 1
     dd4:	30 e0       	ldi	r19, 0x00	; 0
     dd6:	02 c0       	rjmp	.+4      	; 0xddc <readFrets+0x12>
     dd8:	22 0f       	add	r18, r18
     dda:	33 1f       	adc	r19, r19
     ddc:	8a 95       	dec	r24
     dde:	e2 f7       	brpl	.-8      	; 0xdd8 <readFrets+0xe>
     de0:	12 2f       	mov	r17, r18
     de2:	82 2f       	mov	r24, r18
     de4:	80 95       	com	r24
     de6:	89 23       	and	r24, r25
     de8:	8b b9       	out	0x0b, r24	; 11
     dea:	84 e1       	ldi	r24, 0x14	; 20
     dec:	90 e0       	ldi	r25, 0x00	; 0
	// Macro to as many NOPs as we want
	inline void doXnops(int x)
	{
		while (x >= 0)
		{
			nop();
     dee:	00 00       	nop
			x--;
     df0:	01 97       	sbiw	r24, 0x01	; 1
	#define nop() asm volatile("nop")

	// Macro to as many NOPs as we want
	inline void doXnops(int x)
	{
		while (x >= 0)
     df2:	2f ef       	ldi	r18, 0xFF	; 255
     df4:	8f 3f       	cpi	r24, 0xFF	; 255
     df6:	92 07       	cpc	r25, r18
     df8:	d1 f7       	brne	.-12     	; 0xdee <readFrets+0x24>

	// Then we have to delay for a while, since right after the switch, the pin values
	// jump around a bit
	doXnops(20);	
	// Read the values on the frets
  	int i = fret_pin;               
     dfa:	83 b1       	in	r24, 0x03	; 3
	i = fret_pin;
     dfc:	83 b1       	in	r24, 0x03	; 3
	i = fret_pin;		// More delay funcitonality... without these delays, there is some bouncing
     dfe:	83 b1       	in	r24, 0x03	; 3
	i = fret_pin;		// on the pins, so the read screws up.
     e00:	83 b1       	in	r24, 0x03	; 3
	// Next, since the fret pin is zero if the a fret is grounded, we do a mask to isolate each pin from 
	//  the port, which will return a zero if pressed and non-zero if unpressed. So we ! that to get a 1 if
	//  the string touches that fret and a zero if it doesn't touch, which we then load into our storage 
	//  integer.

 	stringState |= ( (!(i & (1<<green_pin))) << 1); //green fret
     e02:	81 fd       	sbrc	r24, 1
     e04:	03 c0       	rjmp	.+6      	; 0xe0c <readFrets+0x42>
     e06:	c2 e0       	ldi	r28, 0x02	; 2
     e08:	d0 e0       	ldi	r29, 0x00	; 0
     e0a:	02 c0       	rjmp	.+4      	; 0xe10 <readFrets+0x46>
     e0c:	c0 e0       	ldi	r28, 0x00	; 0
     e0e:	d0 e0       	ldi	r29, 0x00	; 0
 	stringState |= ( (!(i & (1<<red_pin))) << 2); //red fret
     e10:	82 fd       	sbrc	r24, 2
     e12:	03 c0       	rjmp	.+6      	; 0xe1a <readFrets+0x50>
     e14:	a4 e0       	ldi	r26, 0x04	; 4
     e16:	b0 e0       	ldi	r27, 0x00	; 0
     e18:	02 c0       	rjmp	.+4      	; 0xe1e <readFrets+0x54>
     e1a:	a0 e0       	ldi	r26, 0x00	; 0
     e1c:	b0 e0       	ldi	r27, 0x00	; 0
 	stringState |= ( (!(i & (1<<yellow_pin))) << 3); //yellow fret
     e1e:	83 fd       	sbrc	r24, 3
     e20:	03 c0       	rjmp	.+6      	; 0xe28 <readFrets+0x5e>
     e22:	e8 e0       	ldi	r30, 0x08	; 8
     e24:	f0 e0       	ldi	r31, 0x00	; 0
     e26:	02 c0       	rjmp	.+4      	; 0xe2c <readFrets+0x62>
     e28:	e0 e0       	ldi	r30, 0x00	; 0
     e2a:	f0 e0       	ldi	r31, 0x00	; 0
 	stringState |= ( (!(i & (1<<blue_pin))) << 4); //blue fret
     e2c:	84 fd       	sbrc	r24, 4
     e2e:	03 c0       	rjmp	.+6      	; 0xe36 <readFrets+0x6c>
     e30:	60 e1       	ldi	r22, 0x10	; 16
     e32:	70 e0       	ldi	r23, 0x00	; 0
     e34:	02 c0       	rjmp	.+4      	; 0xe3a <readFrets+0x70>
     e36:	60 e0       	ldi	r22, 0x00	; 0
     e38:	70 e0       	ldi	r23, 0x00	; 0
 	stringState |= ( (!(i & (1<<orange_pin))) << 5); //orange fret
     e3a:	85 fd       	sbrc	r24, 5
     e3c:	03 c0       	rjmp	.+6      	; 0xe44 <readFrets+0x7a>
     e3e:	40 e2       	ldi	r20, 0x20	; 32
     e40:	50 e0       	ldi	r21, 0x00	; 0
     e42:	02 c0       	rjmp	.+4      	; 0xe48 <readFrets+0x7e>
     e44:	40 e0       	ldi	r20, 0x00	; 0
     e46:	50 e0       	ldi	r21, 0x00	; 0

	// Also, if we strummed a string, hold that in the 'zeroth' fret
	i = pick_pin;
     e48:	26 b1       	in	r18, 0x06	; 6
	//  the port, which will return a zero if pressed and non-zero if unpressed. So we ! that to get a 1 if
	//  the string touches that fret and a zero if it doesn't touch, which we then load into our storage 
	//  integer.

 	stringState |= ( (!(i & (1<<green_pin))) << 1); //green fret
 	stringState |= ( (!(i & (1<<red_pin))) << 2); //red fret
     e4a:	30 e0       	ldi	r19, 0x00	; 0
     e4c:	36 95       	lsr	r19
     e4e:	27 95       	ror	r18
     e50:	36 95       	lsr	r19
     e52:	27 95       	ror	r18
     e54:	20 95       	com	r18
     e56:	30 95       	com	r19
     e58:	21 70       	andi	r18, 0x01	; 1
     e5a:	30 70       	andi	r19, 0x00	; 0
     e5c:	2c 2b       	or	r18, r28
     e5e:	3d 2b       	or	r19, r29
 	stringState |= ( (!(i & (1<<yellow_pin))) << 3); //yellow fret
     e60:	2a 2b       	or	r18, r26
     e62:	3b 2b       	or	r19, r27
 	stringState |= ( (!(i & (1<<blue_pin))) << 4); //blue fret
     e64:	2e 2b       	or	r18, r30
     e66:	3f 2b       	or	r19, r31
 	stringState |= ( (!(i & (1<<orange_pin))) << 5); //orange fret
     e68:	26 2b       	or	r18, r22
     e6a:	37 2b       	or	r19, r23
	// Also, if we strummed a string, hold that in the 'zeroth' fret
	i = pick_pin;
 	stringState |= ( (!(i & (1<<strum_pin))) << 0); //pick touching the string

	//Turn the string back HIGH and return
	string_port |= (1<<guitarString); 
     e6c:	8b b1       	in	r24, 0x0b	; 11
     e6e:	18 2b       	or	r17, r24
     e70:	1b b9       	out	0x0b, r17	; 11
     e72:	24 2b       	or	r18, r20
     e74:	35 2b       	or	r19, r21
	return stringState;
}
     e76:	c9 01       	movw	r24, r18
     e78:	df 91       	pop	r29
     e7a:	cf 91       	pop	r28
     e7c:	1f 91       	pop	r17
     e7e:	08 95       	ret

00000e80 <main>:
	 -Under config mode, the loop reads in the values of the strings and frets, assigns that current
	  string-fret combination to correspond to a button press, then locks that combination in when 
	  'Plus' is pressed and moves on to changing the next button.  It also sets the button data structure
	  to display the current controller button being programmed, and then sends that data to the controller.
*/ 
{	
     e80:	2f 92       	push	r2
     e82:	3f 92       	push	r3
     e84:	4f 92       	push	r4
     e86:	5f 92       	push	r5
     e88:	6f 92       	push	r6
     e8a:	7f 92       	push	r7
     e8c:	8f 92       	push	r8
     e8e:	9f 92       	push	r9
     e90:	af 92       	push	r10
     e92:	bf 92       	push	r11
     e94:	cf 92       	push	r12
     e96:	df 92       	push	r13
     e98:	ef 92       	push	r14
     e9a:	ff 92       	push	r15
     e9c:	0f 93       	push	r16
     e9e:	1f 93       	push	r17
     ea0:	df 93       	push	r29
     ea2:	cf 93       	push	r28
     ea4:	cd b7       	in	r28, 0x3d	; 61
     ea6:	de b7       	in	r29, 0x3e	; 62
     ea8:	c7 54       	subi	r28, 0x47	; 71
     eaa:	d1 40       	sbci	r29, 0x01	; 1
     eac:	0f b6       	in	r0, 0x3f	; 63
     eae:	f8 94       	cli
     eb0:	de bf       	out	0x3e, r29	; 62
     eb2:	0f be       	out	0x3f, r0	; 63
     eb4:	cd bf       	out	0x3d, r28	; 61
	// First, set up the guitar stuff - These functions are stored in guitarInitFunctions.h/.c
	setPins();
     eb6:	0e 94 88 06 	call	0xd10	; 0xd10 <setPins>
	setTimer();	
     eba:	0e 94 a5 06 	call	0xd4a	; 0xd4a <setTimer>
 	
	// Now set up all the communication stuff - initialization routines
 	//  set specially in the interface functions - see ps3interface.h, wiiinterface.h, etc.
	startDualShockCommunication();
     ebe:	0e 94 1b 0c 	call	0x1836	; 0x1836 <startDualShockCommunication>
// 	startPS3Communication();
// 	startWiiCommunication();
    
	// Declaration of variables used in Main()
	int greenTimers[NUMBER_OF_STRINGS] = {0,0,0,0,0,0}; //These give timing to properly read green buttons on each string.
     ec2:	8c e0       	ldi	r24, 0x0C	; 12
     ec4:	9e 01       	movw	r18, r28
     ec6:	2e 5e       	subi	r18, 0xEE	; 238
     ec8:	3f 4f       	sbci	r19, 0xFF	; 255
     eca:	d9 01       	movw	r26, r18
     ecc:	e8 2f       	mov	r30, r24
     ece:	1d 92       	st	X+, r1
     ed0:	ea 95       	dec	r30
     ed2:	e9 f7       	brne	.-6      	; 0xece <main+0x4e>
	int triedGreen[NUMBER_OF_STRINGS] = {0,0,0,0,0,0};  // Also used for the green button timing thing
     ed4:	ae 01       	movw	r20, r28
     ed6:	42 5e       	subi	r20, 0xE2	; 226
     ed8:	5f 4f       	sbci	r21, 0xFF	; 255
     eda:	da 01       	movw	r26, r20
     edc:	e8 2f       	mov	r30, r24
     ede:	1d 92       	st	X+, r1
     ee0:	ea 95       	dec	r30
     ee2:	e9 f7       	brne	.-6      	; 0xede <main+0x5e>
	int stringState[6] = {0,0,0,0,0,0}; // This stores an int for each string,
     ee4:	fe 01       	movw	r30, r28
     ee6:	ba 96       	adiw	r30, 0x2a	; 42
     ee8:	df 01       	movw	r26, r30
     eea:	98 2f       	mov	r25, r24
     eec:	1d 92       	st	X+, r1
     eee:	9a 95       	dec	r25
     ef0:	e9 f7       	brne	.-6      	; 0xeec <main+0x6c>
	int buttonStringPatterns[NUM_CHORDS_BUTTONS][NUMBER_OF_STRINGS]; //This holds the button patterns the
																	 // controller compares the string presses
																	 // to in order to judge if a button is being
																	 // pressed. It's the size of all the chord combinations,
																	 // but in Note Mode, only the first 5 blocks get looked at. 
    int stringStateTimers[NUMBER_OF_STRINGS] = {0,0,0,0,0,0};
     ef2:	be 01       	movw	r22, r28
     ef4:	6e 5b       	subi	r22, 0xBE	; 190
     ef6:	7f 4f       	sbci	r23, 0xFF	; 255
     ef8:	db 01       	movw	r26, r22
     efa:	1d 92       	st	X+, r1
     efc:	8a 95       	dec	r24
     efe:	e9 f7       	brne	.-6      	; 0xefa <main+0x7a>

	char configMode = 0; // Start in normal mode
	int buttonToAssign = 0; // declare some variables
     f00:	1c 82       	std	Y+4, r1	; 0x04
     f02:	1b 82       	std	Y+3, r1	; 0x03
	char plusLock = 0;
     f04:	19 82       	std	Y+1, r1	; 0x01
	char previousPlusOn = 0; // This is used as a lock so we don't program all the buttons at once
     f06:	1a 82       	std	Y+2, r1	; 0x02
	int debounceTimer = 0; // This is used as a global timer for debouncing buttons
     f08:	1e 82       	std	Y+6, r1	; 0x06
     f0a:	1d 82       	std	Y+5, r1	; 0x05
		char homeOn;
	} dataForController;

	inline void clearData(dataForController* data)
	{
		data->orangeOn = 0;
     f0c:	1b 86       	std	Y+11, r1	; 0x0b
		data->blueOn   = 0;
     f0e:	1a 86       	std	Y+10, r1	; 0x0a
		data->yellowOn = 0;
     f10:	19 86       	std	Y+9, r1	; 0x09
		data->redOn    = 0;
     f12:	18 86       	std	Y+8, r1	; 0x08
		data->greenOn  = 0;
     f14:	1f 82       	std	Y+7, r1	; 0x07
		data->upOn     = 0;
     f16:	1c 86       	std	Y+12, r1	; 0x0c
		data->downOn   = 0;
     f18:	1d 86       	std	Y+13, r1	; 0x0d
		data->plusOn   = 0;
     f1a:	1e 86       	std	Y+14, r1	; 0x0e
		data->minusOn  = 0;
     f1c:	1f 86       	std	Y+15, r1	; 0x0f
		data->numberOfStringsPressed = 0;
     f1e:	18 8a       	std	Y+16, r1	; 0x10
		data->homeOn   = 0;
     f20:	19 8a       	std	Y+17, r1	; 0x11
     f22:	44 24       	eor	r4, r4
     f24:	55 24       	eor	r5, r5
        tempStringState[0] = readFrets(first_string);
		tempStringState[1] = readFrets(second_string);
		tempStringState[2] = readFrets(third_string);
		tempStringState[3] = readFrets(fourth_string);
		tempStringState[4] = readFrets(fifth_string);
		tempStringState[5] = readFrets(sixth_string);
     f26:	c0 5c       	subi	r28, 0xC0	; 192
     f28:	de 4f       	sbci	r29, 0xFE	; 254
     f2a:	e8 83       	st	Y, r30
     f2c:	c0 54       	subi	r28, 0x40	; 64
     f2e:	d1 40       	sbci	r29, 0x01	; 1
     f30:	cf 5b       	subi	r28, 0xBF	; 191
     f32:	de 4f       	sbci	r29, 0xFE	; 254
     f34:	f8 83       	st	Y, r31
     f36:	c1 54       	subi	r28, 0x41	; 65
     f38:	d1 40       	sbci	r29, 0x01	; 1
     f3a:	db 01       	movw	r26, r22
     f3c:	ce 5b       	subi	r28, 0xBE	; 190
     f3e:	de 4f       	sbci	r29, 0xFE	; 254
     f40:	68 83       	st	Y, r22
     f42:	c2 54       	subi	r28, 0x42	; 66
     f44:	d1 40       	sbci	r29, 0x01	; 1
     f46:	cd 5b       	subi	r28, 0xBD	; 189
     f48:	de 4f       	sbci	r29, 0xFE	; 254
     f4a:	b8 83       	st	Y, r27
     f4c:	c3 54       	subi	r28, 0x43	; 67
     f4e:	d1 40       	sbci	r29, 0x01	; 1

        // Debounce the strings by making sure what is being fretted
        // remains for a certain number of cycles through the main loop
        for (int i = 0; i <= 6; i++)
     f50:	e6 e3       	ldi	r30, 0x36	; 54
     f52:	f0 e0       	ldi	r31, 0x00	; 0
     f54:	ec 0f       	add	r30, r28
     f56:	fd 1f       	adc	r31, r29
     f58:	3e 96       	adiw	r30, 0x0e	; 14
     f5a:	c2 5c       	subi	r28, 0xC2	; 194
     f5c:	de 4f       	sbci	r29, 0xFE	; 254
     f5e:	f9 83       	std	Y+1, r31	; 0x01
     f60:	e8 83       	st	Y, r30
     f62:	ce 53       	subi	r28, 0x3E	; 62
     f64:	d1 40       	sbci	r29, 0x01	; 1
	// array as something big enough for all 21 chord mode combinations, but we
	// only write the first 5 patterns when we write these ones to EEPROM
	int buttonStringPatterns[NUM_CHORDS_BUTTONS][NUMBER_OF_STRINGS];

    buttonStringPatterns[0][0] = 0b0000000; // [0][0] through [0][5] - green button
    buttonStringPatterns[0][0] = 0x0000000; // [0][0] through [0][5] - green button
     f66:	96 ec       	ldi	r25, 0xC6	; 198
     f68:	89 2e       	mov	r8, r25
     f6a:	91 2c       	mov	r9, r1
     f6c:	8c 0e       	add	r8, r28
     f6e:	9d 1e       	adc	r9, r29

	eeprom_write_block( (void*)&buttonStringPatterns, notesAddress, EEPROM_NOTES_BLOCK_SIZE);


	// Now write the default chord mapping
	buttonStringPatterns[0][0] = 0b0001110; // [0][0] through [0][5] - green button
     f70:	8e e0       	ldi	r24, 0x0E	; 14
     f72:	28 2e       	mov	r2, r24
     f74:	31 2c       	mov	r3, r1
			// Next, using our strumState array, we process that data to figure out what sort
			//  of buttons on the controller we want to emulate pressing.
			// find out if we're in a transitional controller mode or not
			if (!(controllerMode % 2)) // Not a transitional mode
			{	//  This function can be found in processStringState.h/.c
				processStringState(&data, stringState, buttonStringPatterns, controllerMode, greenTimers, triedGreen);
     f76:	0e e4       	ldi	r16, 0x4E	; 78
     f78:	60 2e       	mov	r6, r16
     f7a:	71 2c       	mov	r7, r1
     f7c:	6c 0e       	add	r6, r28
     f7e:	7d 1e       	adc	r7, r29
     f80:	cc 5b       	subi	r28, 0xBC	; 188
     f82:	de 4f       	sbci	r29, 0xFE	; 254
     f84:	28 83       	st	Y, r18
     f86:	c4 54       	subi	r28, 0x44	; 68
     f88:	d1 40       	sbci	r29, 0x01	; 1
     f8a:	cb 5b       	subi	r28, 0xBB	; 187
     f8c:	de 4f       	sbci	r29, 0xFE	; 254
     f8e:	38 83       	st	Y, r19
     f90:	c5 54       	subi	r28, 0x45	; 69
     f92:	d1 40       	sbci	r29, 0x01	; 1
     f94:	ca 5b       	subi	r28, 0xBA	; 186
     f96:	de 4f       	sbci	r29, 0xFE	; 254
     f98:	48 83       	st	Y, r20
     f9a:	c6 54       	subi	r28, 0x46	; 70
     f9c:	d1 40       	sbci	r29, 0x01	; 1
     f9e:	c9 5b       	subi	r28, 0xB9	; 185
     fa0:	de 4f       	sbci	r29, 0xFE	; 254
     fa2:	58 83       	st	Y, r21
     fa4:	c7 54       	subi	r28, 0x47	; 71
     fa6:	d1 40       	sbci	r29, 0x01	; 1
 					 /* main event loop */
    while(1)
	{   
		// We first read all the strings for button hits and store them into
		//  our stringState array.  Strum processing is also handled here for now.
        tempStringState[0] = readFrets(first_string);
     fa8:	87 e0       	ldi	r24, 0x07	; 7
     faa:	90 e0       	ldi	r25, 0x00	; 0
     fac:	0e 94 e5 06 	call	0xdca	; 0xdca <readFrets>
     fb0:	9f ab       	std	Y+55, r25	; 0x37
     fb2:	8e ab       	std	Y+54, r24	; 0x36
		tempStringState[1] = readFrets(second_string);
     fb4:	86 e0       	ldi	r24, 0x06	; 6
     fb6:	90 e0       	ldi	r25, 0x00	; 0
     fb8:	0e 94 e5 06 	call	0xdca	; 0xdca <readFrets>
     fbc:	99 af       	std	Y+57, r25	; 0x39
     fbe:	88 af       	std	Y+56, r24	; 0x38
		tempStringState[2] = readFrets(third_string);
     fc0:	85 e0       	ldi	r24, 0x05	; 5
     fc2:	90 e0       	ldi	r25, 0x00	; 0
     fc4:	0e 94 e5 06 	call	0xdca	; 0xdca <readFrets>
     fc8:	9b af       	std	Y+59, r25	; 0x3b
     fca:	8a af       	std	Y+58, r24	; 0x3a
		tempStringState[3] = readFrets(fourth_string);
     fcc:	82 e0       	ldi	r24, 0x02	; 2
     fce:	90 e0       	ldi	r25, 0x00	; 0
     fd0:	0e 94 e5 06 	call	0xdca	; 0xdca <readFrets>
     fd4:	9d af       	std	Y+61, r25	; 0x3d
     fd6:	8c af       	std	Y+60, r24	; 0x3c
		tempStringState[4] = readFrets(fifth_string);
     fd8:	81 e0       	ldi	r24, 0x01	; 1
     fda:	90 e0       	ldi	r25, 0x00	; 0
     fdc:	0e 94 e5 06 	call	0xdca	; 0xdca <readFrets>
     fe0:	9f af       	std	Y+63, r25	; 0x3f
     fe2:	8e af       	std	Y+62, r24	; 0x3e
		tempStringState[5] = readFrets(sixth_string);
     fe4:	80 e0       	ldi	r24, 0x00	; 0
     fe6:	90 e0       	ldi	r25, 0x00	; 0
     fe8:	0e 94 e5 06 	call	0xdca	; 0xdca <readFrets>
     fec:	22 96       	adiw	r28, 0x02	; 2
     fee:	9f af       	std	Y+63, r25	; 0x3f
     ff0:	8e af       	std	Y+62, r24	; 0x3e
     ff2:	22 97       	sbiw	r28, 0x02	; 2
     ff4:	9e 01       	movw	r18, r28
     ff6:	2a 5c       	subi	r18, 0xCA	; 202
     ff8:	3f 4f       	sbci	r19, 0xFF	; 255
     ffa:	c0 5c       	subi	r28, 0xC0	; 192
     ffc:	de 4f       	sbci	r29, 0xFE	; 254
     ffe:	88 81       	ld	r24, Y
    1000:	c0 54       	subi	r28, 0x40	; 64
    1002:	d1 40       	sbci	r29, 0x01	; 1
    1004:	cf 5b       	subi	r28, 0xBF	; 191
    1006:	de 4f       	sbci	r29, 0xFE	; 254
    1008:	98 81       	ld	r25, Y
    100a:	c1 54       	subi	r28, 0x41	; 65
    100c:	d1 40       	sbci	r29, 0x01	; 1
    100e:	bc 01       	movw	r22, r24
    1010:	ce 5b       	subi	r28, 0xBE	; 190
    1012:	de 4f       	sbci	r29, 0xFE	; 254
    1014:	88 81       	ld	r24, Y
    1016:	c2 54       	subi	r28, 0x42	; 66
    1018:	d1 40       	sbci	r29, 0x01	; 1
    101a:	cd 5b       	subi	r28, 0xBD	; 189
    101c:	de 4f       	sbci	r29, 0xFE	; 254
    101e:	98 81       	ld	r25, Y
    1020:	c3 54       	subi	r28, 0x43	; 67
    1022:	d1 40       	sbci	r29, 0x01	; 1
    1024:	fc 01       	movw	r30, r24

        // Debounce the strings by making sure what is being fretted
        // remains for a certain number of cycles through the main loop
        for (int i = 0; i <= 6; i++)
        {
                if (tempStringState[i] == stringState[i])
    1026:	d9 01       	movw	r26, r18
    1028:	4d 91       	ld	r20, X+
    102a:	5c 91       	ld	r21, X
    102c:	db 01       	movw	r26, r22
    102e:	8d 91       	ld	r24, X+
    1030:	9c 91       	ld	r25, X
    1032:	48 17       	cp	r20, r24
    1034:	59 07       	cpc	r21, r25
    1036:	19 f4       	brne	.+6      	; 0x103e <main+0x1be>
                        stringStateTimers[i] = 0;
    1038:	11 82       	std	Z+1, r1	; 0x01
    103a:	10 82       	st	Z, r1
    103c:	05 c0       	rjmp	.+10     	; 0x1048 <main+0x1c8>
                else
                        stringStateTimers[i] += 1;
    103e:	80 81       	ld	r24, Z
    1040:	91 81       	ldd	r25, Z+1	; 0x01
    1042:	01 96       	adiw	r24, 0x01	; 1
    1044:	91 83       	std	Z+1, r25	; 0x01
    1046:	80 83       	st	Z, r24
                // If we've seen enough cycles of a new string state, update stringState 
                if (stringStateTimers[i] >= STRING_DEBOUNCE_DELAY)
    1048:	80 81       	ld	r24, Z
    104a:	91 81       	ldd	r25, Z+1	; 0x01
    104c:	0f 97       	sbiw	r24, 0x0f	; 15
    104e:	2c f0       	brlt	.+10     	; 0x105a <main+0x1da>
                {
                        stringState[i] = tempStringState[i];
    1050:	db 01       	movw	r26, r22
    1052:	4d 93       	st	X+, r20
    1054:	5c 93       	st	X, r21
                        stringStateTimers[i] = 0;
    1056:	11 82       	std	Z+1, r1	; 0x01
    1058:	10 82       	st	Z, r1
    105a:	2e 5f       	subi	r18, 0xFE	; 254
    105c:	3f 4f       	sbci	r19, 0xFF	; 255
    105e:	6e 5f       	subi	r22, 0xFE	; 254
    1060:	7f 4f       	sbci	r23, 0xFF	; 255
    1062:	32 96       	adiw	r30, 0x02	; 2
		tempStringState[4] = readFrets(fifth_string);
		tempStringState[5] = readFrets(sixth_string);

        // Debounce the strings by making sure what is being fretted
        // remains for a certain number of cycles through the main loop
        for (int i = 0; i <= 6; i++)
    1064:	c2 5c       	subi	r28, 0xC2	; 194
    1066:	de 4f       	sbci	r29, 0xFE	; 254
    1068:	88 81       	ld	r24, Y
    106a:	99 81       	ldd	r25, Y+1	; 0x01
    106c:	ce 53       	subi	r28, 0x3E	; 62
    106e:	d1 40       	sbci	r29, 0x01	; 1
    1070:	28 17       	cp	r18, r24
    1072:	39 07       	cpc	r19, r25
    1074:	c1 f6       	brne	.-80     	; 0x1026 <main+0x1a6>
		char homeOn;
	} dataForController;

	inline void clearData(dataForController* data)
	{
		data->orangeOn = 0;
    1076:	1b 86       	std	Y+11, r1	; 0x0b
		data->blueOn   = 0;
    1078:	1a 86       	std	Y+10, r1	; 0x0a
		data->yellowOn = 0;
    107a:	19 86       	std	Y+9, r1	; 0x09
		data->redOn    = 0;
    107c:	18 86       	std	Y+8, r1	; 0x08
		data->greenOn  = 0;
    107e:	1f 82       	std	Y+7, r1	; 0x07
		data->upOn     = 0;
    1080:	1c 86       	std	Y+12, r1	; 0x0c
		data->downOn   = 0;
    1082:	1d 86       	std	Y+13, r1	; 0x0d
		data->plusOn   = 0;
		data->minusOn  = 0;
		data->numberOfStringsPressed = 0;
    1084:	18 8a       	std	Y+16, r1	; 0x10
		data->homeOn   = 0;
    1086:	19 8a       	std	Y+17, r1	; 0x11

// This function just reads our plus and minus buttons and sets the data struct accordingly
inline void readOtherButtons(dataForController* data)
{
	// read our plus and minus buttons
	int i = misc_pin; // check for plus and minus
    1088:	86 b1       	in	r24, 0x06	; 6
    108a:	90 e0       	ldi	r25, 0x00	; 0
	data->plusOn = !(i & (1<<plus_pin)); //Plus and minus are held high normally, but pressing it drops it low
    108c:	41 e0       	ldi	r20, 0x01	; 1
    108e:	50 e0       	ldi	r21, 0x00	; 0
    1090:	9c 01       	movw	r18, r24
    1092:	24 27       	eor	r18, r20
    1094:	35 27       	eor	r19, r21
    1096:	21 70       	andi	r18, 0x01	; 1
    1098:	2e 87       	std	Y+14, r18	; 0x0e
	data->minusOn = !(i & (1<<minus_pin));
    109a:	96 95       	lsr	r25
    109c:	87 95       	ror	r24
    109e:	84 27       	eor	r24, r20
    10a0:	95 27       	eor	r25, r21
    10a2:	81 70       	andi	r24, 0x01	; 1
    10a4:	8f 87       	std	Y+15, r24	; 0x0f
		return 0;
}

inline int testForResetButtonPatterns(int stringState[])
{
	if ((stringState[0] == 0b00100000) &&
    10a6:	8a a5       	ldd	r24, Y+42	; 0x2a
    10a8:	9b a5       	ldd	r25, Y+43	; 0x2b
    10aa:	80 97       	sbiw	r24, 0x20	; 32
    10ac:	09 f0       	breq	.+2      	; 0x10b0 <main+0x230>
    10ae:	22 c1       	rjmp	.+580    	; 0x12f4 <main+0x474>
    10b0:	8c a5       	ldd	r24, Y+44	; 0x2c
    10b2:	9d a5       	ldd	r25, Y+45	; 0x2d
    10b4:	89 2b       	or	r24, r25
    10b6:	09 f0       	breq	.+2      	; 0x10ba <main+0x23a>
    10b8:	1d c1       	rjmp	.+570    	; 0x12f4 <main+0x474>
    10ba:	8e a5       	ldd	r24, Y+46	; 0x2e
    10bc:	9f a5       	ldd	r25, Y+47	; 0x2f
    10be:	80 97       	sbiw	r24, 0x20	; 32
    10c0:	09 f0       	breq	.+2      	; 0x10c4 <main+0x244>
    10c2:	18 c1       	rjmp	.+560    	; 0x12f4 <main+0x474>
    10c4:	88 a9       	ldd	r24, Y+48	; 0x30
    10c6:	99 a9       	ldd	r25, Y+49	; 0x31
    10c8:	89 2b       	or	r24, r25
    10ca:	09 f0       	breq	.+2      	; 0x10ce <main+0x24e>
    10cc:	13 c1       	rjmp	.+550    	; 0x12f4 <main+0x474>
    10ce:	8a a9       	ldd	r24, Y+50	; 0x32
    10d0:	9b a9       	ldd	r25, Y+51	; 0x33
    10d2:	80 97       	sbiw	r24, 0x20	; 32
    10d4:	09 f0       	breq	.+2      	; 0x10d8 <main+0x258>
    10d6:	0e c1       	rjmp	.+540    	; 0x12f4 <main+0x474>
    10d8:	8c a9       	ldd	r24, Y+52	; 0x34
    10da:	9d a9       	ldd	r25, Y+53	; 0x35
    10dc:	89 2b       	or	r24, r25
    10de:	09 f0       	breq	.+2      	; 0x10e2 <main+0x262>
    10e0:	09 c1       	rjmp	.+530    	; 0x12f4 <main+0x474>
	// array as something big enough for all 21 chord mode combinations, but we
	// only write the first 5 patterns when we write these ones to EEPROM
	int buttonStringPatterns[NUM_CHORDS_BUTTONS][NUMBER_OF_STRINGS];

    buttonStringPatterns[0][0] = 0b0000000; // [0][0] through [0][5] - green button
    buttonStringPatterns[0][0] = 0x0000000; // [0][0] through [0][5] - green button
    10e2:	d4 01       	movw	r26, r8
    10e4:	11 96       	adiw	r26, 0x01	; 1
    10e6:	1c 92       	st	X, r1
    10e8:	1e 92       	st	-X, r1
	buttonStringPatterns[0][1] = 0b0001100; 
    10ea:	ec e0       	ldi	r30, 0x0C	; 12
    10ec:	f0 e0       	ldi	r31, 0x00	; 0
    10ee:	13 96       	adiw	r26, 0x03	; 3
    10f0:	fc 93       	st	X, r31
    10f2:	ee 93       	st	-X, r30
    10f4:	12 97       	sbiw	r26, 0x02	; 2
	buttonStringPatterns[0][2] = 0b0000000;	
    10f6:	15 96       	adiw	r26, 0x05	; 5
    10f8:	1c 92       	st	X, r1
    10fa:	1e 92       	st	-X, r1
    10fc:	14 97       	sbiw	r26, 0x04	; 4
	buttonStringPatterns[0][3] = 0b0000110;
    10fe:	06 e0       	ldi	r16, 0x06	; 6
    1100:	10 e0       	ldi	r17, 0x00	; 0
    1102:	17 96       	adiw	r26, 0x07	; 7
    1104:	1c 93       	st	X, r17
    1106:	0e 93       	st	-X, r16
    1108:	16 97       	sbiw	r26, 0x06	; 6
	buttonStringPatterns[0][4] = 0b0000000;
    110a:	19 96       	adiw	r26, 0x09	; 9
    110c:	1c 92       	st	X, r1
    110e:	1e 92       	st	-X, r1
    1110:	18 97       	sbiw	r26, 0x08	; 8
	buttonStringPatterns[0][5] = 0b0000010;
    1112:	82 e0       	ldi	r24, 0x02	; 2
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	1b 96       	adiw	r26, 0x0b	; 11
    1118:	9c 93       	st	X, r25
    111a:	8e 93       	st	-X, r24
    111c:	1a 97       	sbiw	r26, 0x0a	; 10

	buttonStringPatterns[1][0] = 0b0000010; // [1][0] through [1][5] - red button
    111e:	1d 96       	adiw	r26, 0x0d	; 13
    1120:	9c 93       	st	X, r25
    1122:	8e 93       	st	-X, r24
    1124:	1c 97       	sbiw	r26, 0x0c	; 12
	buttonStringPatterns[1][1] = 0b0000000; 
    1126:	1f 96       	adiw	r26, 0x0f	; 15
    1128:	1c 92       	st	X, r1
    112a:	1e 92       	st	-X, r1
    112c:	1e 97       	sbiw	r26, 0x0e	; 14
	buttonStringPatterns[1][2] = 0b0000001;
    112e:	51 96       	adiw	r26, 0x11	; 17
    1130:	5c 93       	st	X, r21
    1132:	4e 93       	st	-X, r20
    1134:	50 97       	sbiw	r26, 0x10	; 16
	buttonStringPatterns[1][3] = 0b0000000;
    1136:	53 96       	adiw	r26, 0x13	; 19
    1138:	1c 92       	st	X, r1
    113a:	1e 92       	st	-X, r1
    113c:	52 97       	sbiw	r26, 0x12	; 18
	buttonStringPatterns[1][4] = 0b0000001;
    113e:	55 96       	adiw	r26, 0x15	; 21
    1140:	5c 93       	st	X, r21
    1142:	4e 93       	st	-X, r20
    1144:	54 97       	sbiw	r26, 0x14	; 20
	buttonStringPatterns[1][5] = 0b0001100;
    1146:	57 96       	adiw	r26, 0x17	; 23
    1148:	fc 93       	st	X, r31
    114a:	ee 93       	st	-X, r30
    114c:	56 97       	sbiw	r26, 0x16	; 22

	buttonStringPatterns[2][0] = 0b0001100; // [2][0] through [2][5] - yellow button
    114e:	59 96       	adiw	r26, 0x19	; 25
    1150:	fc 93       	st	X, r31
    1152:	ee 93       	st	-X, r30
    1154:	58 97       	sbiw	r26, 0x18	; 24
	buttonStringPatterns[2][1] = 0b0000000; // This is an A chord.
    1156:	5b 96       	adiw	r26, 0x1b	; 27
    1158:	1c 92       	st	X, r1
    115a:	1e 92       	st	-X, r1
    115c:	5a 97       	sbiw	r26, 0x1a	; 26
	buttonStringPatterns[2][2] = 0b0000110;
    115e:	5d 96       	adiw	r26, 0x1d	; 29
    1160:	1c 93       	st	X, r17
    1162:	0e 93       	st	-X, r16
    1164:	5c 97       	sbiw	r26, 0x1c	; 28
	buttonStringPatterns[2][3] = 0b0000000;
    1166:	5f 96       	adiw	r26, 0x1f	; 31
    1168:	1c 92       	st	X, r1
    116a:	1e 92       	st	-X, r1
    116c:	5e 97       	sbiw	r26, 0x1e	; 30
	buttonStringPatterns[2][4] = 0b0000010;
    116e:	91 96       	adiw	r26, 0x21	; 33
    1170:	9c 93       	st	X, r25
    1172:	8e 93       	st	-X, r24
    1174:	90 97       	sbiw	r26, 0x20	; 32
	buttonStringPatterns[2][5] = 0b0000000;
    1176:	93 96       	adiw	r26, 0x23	; 35
    1178:	1c 92       	st	X, r1
    117a:	1e 92       	st	-X, r1
    117c:	92 97       	sbiw	r26, 0x22	; 34
							  
	buttonStringPatterns[3][0] = 0b0000000; // [3][0] through [3][5] - blue button
    117e:	95 96       	adiw	r26, 0x25	; 37
    1180:	1c 92       	st	X, r1
    1182:	1e 92       	st	-X, r1
    1184:	94 97       	sbiw	r26, 0x24	; 36
	buttonStringPatterns[3][1] = 0b0000001; 
    1186:	97 96       	adiw	r26, 0x27	; 39
    1188:	5c 93       	st	X, r21
    118a:	4e 93       	st	-X, r20
    118c:	96 97       	sbiw	r26, 0x26	; 38
	buttonStringPatterns[3][2] = 0b0001100;
    118e:	99 96       	adiw	r26, 0x29	; 41
    1190:	fc 93       	st	X, r31
    1192:	ee 93       	st	-X, r30
    1194:	98 97       	sbiw	r26, 0x28	; 40
	buttonStringPatterns[3][3] = 0b0000000;
    1196:	9b 96       	adiw	r26, 0x2b	; 43
    1198:	1c 92       	st	X, r1
    119a:	1e 92       	st	-X, r1
    119c:	9a 97       	sbiw	r26, 0x2a	; 42
	buttonStringPatterns[3][4] = 0b0001100;
    119e:	9d 96       	adiw	r26, 0x2d	; 45
    11a0:	fc 93       	st	X, r31
    11a2:	ee 93       	st	-X, r30
    11a4:	9c 97       	sbiw	r26, 0x2c	; 44
	buttonStringPatterns[3][5] = 0b0000000;
    11a6:	9f 96       	adiw	r26, 0x2f	; 47
    11a8:	1c 92       	st	X, r1
    11aa:	1e 92       	st	-X, r1
    11ac:	9e 97       	sbiw	r26, 0x2e	; 46

	buttonStringPatterns[4][0] = 0b0000000; // [4][0] through [4][5] - orange button
    11ae:	d1 96       	adiw	r26, 0x31	; 49
    11b0:	1c 92       	st	X, r1
    11b2:	1e 92       	st	-X, r1
    11b4:	d0 97       	sbiw	r26, 0x30	; 48
	buttonStringPatterns[4][1] = 0b0000110; 
    11b6:	d3 96       	adiw	r26, 0x33	; 51
    11b8:	1c 93       	st	X, r17
    11ba:	0e 93       	st	-X, r16
    11bc:	d2 97       	sbiw	r26, 0x32	; 50
	buttonStringPatterns[4][2] = 0b0000000;
    11be:	d5 96       	adiw	r26, 0x35	; 53
    11c0:	1c 92       	st	X, r1
    11c2:	1e 92       	st	-X, r1
    11c4:	d4 97       	sbiw	r26, 0x34	; 52
	buttonStringPatterns[4][3] = 0b0000001;
    11c6:	d7 96       	adiw	r26, 0x37	; 55
    11c8:	5c 93       	st	X, r21
    11ca:	4e 93       	st	-X, r20
    11cc:	d6 97       	sbiw	r26, 0x36	; 54
	buttonStringPatterns[4][4] = 0b0000000;
    11ce:	d9 96       	adiw	r26, 0x39	; 57
    11d0:	1c 92       	st	X, r1
    11d2:	1e 92       	st	-X, r1
    11d4:	d8 97       	sbiw	r26, 0x38	; 56
	buttonStringPatterns[4][5] = 0b0000001;
    11d6:	db 96       	adiw	r26, 0x3b	; 59
    11d8:	5c 93       	st	X, r21
    11da:	4e 93       	st	-X, r20
    11dc:	da 97       	sbiw	r26, 0x3a	; 58
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    11de:	80 e0       	ldi	r24, 0x00	; 0
    11e0:	90 e0       	ldi	r25, 0x00	; 0
    11e2:	b4 01       	movw	r22, r8
    11e4:	4c e3       	ldi	r20, 0x3C	; 60
    11e6:	50 e0       	ldi	r21, 0x00	; 0
    11e8:	28 ed       	ldi	r18, 0xD8	; 216
    11ea:	36 e0       	ldi	r19, 0x06	; 6
    11ec:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <__eewr_block>

	eeprom_write_block( (void*)&buttonStringPatterns, notesAddress, EEPROM_NOTES_BLOCK_SIZE);


	// Now write the default chord mapping
	buttonStringPatterns[0][0] = 0b0001110; // [0][0] through [0][5] - green button
    11f0:	d4 01       	movw	r26, r8
    11f2:	11 96       	adiw	r26, 0x01	; 1
    11f4:	3c 92       	st	X, r3
    11f6:	2e 92       	st	-X, r2
	buttonStringPatterns[0][1] = 0b0001110; // This is a G Chord
    11f8:	13 96       	adiw	r26, 0x03	; 3
    11fa:	3c 92       	st	X, r3
    11fc:	2e 92       	st	-X, r2
    11fe:	12 97       	sbiw	r26, 0x02	; 2
	buttonStringPatterns[0][2] = 0b0000000;	
    1200:	15 96       	adiw	r26, 0x05	; 5
    1202:	1c 92       	st	X, r1
    1204:	1e 92       	st	-X, r1
    1206:	14 97       	sbiw	r26, 0x04	; 4
	buttonStringPatterns[0][3] = 0b0000000;
    1208:	17 96       	adiw	r26, 0x07	; 7
    120a:	1c 92       	st	X, r1
    120c:	1e 92       	st	-X, r1
    120e:	16 97       	sbiw	r26, 0x06	; 6
	buttonStringPatterns[0][4] = 0b0000000;
    1210:	19 96       	adiw	r26, 0x09	; 9
    1212:	1c 92       	st	X, r1
    1214:	1e 92       	st	-X, r1
    1216:	18 97       	sbiw	r26, 0x08	; 8
	buttonStringPatterns[0][5] = 0b0001110;
    1218:	1b 96       	adiw	r26, 0x0b	; 11
    121a:	3c 92       	st	X, r3
    121c:	2e 92       	st	-X, r2
    121e:	1a 97       	sbiw	r26, 0x0a	; 10

	buttonStringPatterns[1][0] = 0b0000000; // [1][0] through [1][5] - red button
    1220:	1d 96       	adiw	r26, 0x0d	; 13
    1222:	1c 92       	st	X, r1
    1224:	1e 92       	st	-X, r1
    1226:	1c 97       	sbiw	r26, 0x0c	; 12
	buttonStringPatterns[1][1] = 0b0001110; // This is a C chord
    1228:	1f 96       	adiw	r26, 0x0f	; 15
    122a:	3c 92       	st	X, r3
    122c:	2e 92       	st	-X, r2
    122e:	1e 97       	sbiw	r26, 0x0e	; 14
	buttonStringPatterns[1][2] = 0b0001110;
    1230:	51 96       	adiw	r26, 0x11	; 17
    1232:	3c 92       	st	X, r3
    1234:	2e 92       	st	-X, r2
    1236:	50 97       	sbiw	r26, 0x10	; 16
	buttonStringPatterns[1][3] = 0b0000000;
    1238:	53 96       	adiw	r26, 0x13	; 19
    123a:	1c 92       	st	X, r1
    123c:	1e 92       	st	-X, r1
    123e:	52 97       	sbiw	r26, 0x12	; 18
	buttonStringPatterns[1][4] = 0b0001110;
    1240:	55 96       	adiw	r26, 0x15	; 21
    1242:	3c 92       	st	X, r3
    1244:	2e 92       	st	-X, r2
    1246:	54 97       	sbiw	r26, 0x14	; 20
	buttonStringPatterns[1][5] = 0b0000000;
    1248:	57 96       	adiw	r26, 0x17	; 23
    124a:	1c 92       	st	X, r1
    124c:	1e 92       	st	-X, r1
    124e:	56 97       	sbiw	r26, 0x16	; 22

	buttonStringPatterns[2][0] = 0b0000000; // [2][0] through [2][5] - yellow button
    1250:	59 96       	adiw	r26, 0x19	; 25
    1252:	1c 92       	st	X, r1
    1254:	1e 92       	st	-X, r1
    1256:	58 97       	sbiw	r26, 0x18	; 24
	buttonStringPatterns[2][1] = 0b0000110; // This is an E chord.
    1258:	5b 96       	adiw	r26, 0x1b	; 27
    125a:	1c 93       	st	X, r17
    125c:	0e 93       	st	-X, r16
    125e:	5a 97       	sbiw	r26, 0x1a	; 26
	buttonStringPatterns[2][2] = 0b0000110;
    1260:	5d 96       	adiw	r26, 0x1d	; 29
    1262:	1c 93       	st	X, r17
    1264:	0e 93       	st	-X, r16
    1266:	5c 97       	sbiw	r26, 0x1c	; 28
	buttonStringPatterns[2][3] = 0b0000110;
    1268:	5f 96       	adiw	r26, 0x1f	; 31
    126a:	1c 93       	st	X, r17
    126c:	0e 93       	st	-X, r16
    126e:	5e 97       	sbiw	r26, 0x1e	; 30
	buttonStringPatterns[2][4] = 0b0000000;
    1270:	91 96       	adiw	r26, 0x21	; 33
    1272:	1c 92       	st	X, r1
    1274:	1e 92       	st	-X, r1
    1276:	90 97       	sbiw	r26, 0x20	; 32
	buttonStringPatterns[2][5] = 0b0000000;
    1278:	93 96       	adiw	r26, 0x23	; 35
    127a:	1c 92       	st	X, r1
    127c:	1e 92       	st	-X, r1
    127e:	92 97       	sbiw	r26, 0x22	; 34
									  
	buttonStringPatterns[3][0] = 0b0000000; // [3][0] through [3][5] - blue button
    1280:	95 96       	adiw	r26, 0x25	; 37
    1282:	1c 92       	st	X, r1
    1284:	1e 92       	st	-X, r1
    1286:	94 97       	sbiw	r26, 0x24	; 36
	buttonStringPatterns[3][1] = 0b0000000; // This an A chord
    1288:	97 96       	adiw	r26, 0x27	; 39
    128a:	1c 92       	st	X, r1
    128c:	1e 92       	st	-X, r1
    128e:	96 97       	sbiw	r26, 0x26	; 38
	buttonStringPatterns[3][2] = 0b0000110;
    1290:	99 96       	adiw	r26, 0x29	; 41
    1292:	1c 93       	st	X, r17
    1294:	0e 93       	st	-X, r16
    1296:	98 97       	sbiw	r26, 0x28	; 40
	buttonStringPatterns[3][3] = 0b0000110;
    1298:	9b 96       	adiw	r26, 0x2b	; 43
    129a:	1c 93       	st	X, r17
    129c:	0e 93       	st	-X, r16
    129e:	9a 97       	sbiw	r26, 0x2a	; 42
	buttonStringPatterns[3][4] = 0b0000110;
    12a0:	9d 96       	adiw	r26, 0x2d	; 45
    12a2:	1c 93       	st	X, r17
    12a4:	0e 93       	st	-X, r16
    12a6:	9c 97       	sbiw	r26, 0x2c	; 44
	buttonStringPatterns[3][5] = 0b0000000;
    12a8:	9f 96       	adiw	r26, 0x2f	; 47
    12aa:	1c 92       	st	X, r1
    12ac:	1e 92       	st	-X, r1
    12ae:	9e 97       	sbiw	r26, 0x2e	; 46

	buttonStringPatterns[4][0] = 0b0000000; // [4][0] through [4][5] - blue button
    12b0:	d1 96       	adiw	r26, 0x31	; 49
    12b2:	1c 92       	st	X, r1
    12b4:	1e 92       	st	-X, r1
    12b6:	d0 97       	sbiw	r26, 0x30	; 48
	buttonStringPatterns[4][1] = 0b0000000;	// This is a D chord 
    12b8:	d3 96       	adiw	r26, 0x33	; 51
    12ba:	1c 92       	st	X, r1
    12bc:	1e 92       	st	-X, r1
    12be:	d2 97       	sbiw	r26, 0x32	; 50
	buttonStringPatterns[4][2] = 0b0000000;
    12c0:	d5 96       	adiw	r26, 0x35	; 53
    12c2:	1c 92       	st	X, r1
    12c4:	1e 92       	st	-X, r1
    12c6:	d4 97       	sbiw	r26, 0x34	; 52
	buttonStringPatterns[4][3] = 0b0001110;
    12c8:	d7 96       	adiw	r26, 0x37	; 55
    12ca:	3c 92       	st	X, r3
    12cc:	2e 92       	st	-X, r2
    12ce:	d6 97       	sbiw	r26, 0x36	; 54
	buttonStringPatterns[4][4] = 0b0001110;
    12d0:	d9 96       	adiw	r26, 0x39	; 57
    12d2:	3c 92       	st	X, r3
    12d4:	2e 92       	st	-X, r2
    12d6:	d8 97       	sbiw	r26, 0x38	; 56
	buttonStringPatterns[4][5] = 0b0001110;
    12d8:	db 96       	adiw	r26, 0x3b	; 59
    12da:	3c 92       	st	X, r3
    12dc:	2e 92       	st	-X, r2
    12de:	da 97       	sbiw	r26, 0x3a	; 58
    12e0:	88 e7       	ldi	r24, 0x78	; 120
    12e2:	90 e0       	ldi	r25, 0x00	; 0
    12e4:	b4 01       	movw	r22, r8
    12e6:	48 e7       	ldi	r20, 0x78	; 120
    12e8:	50 e0       	ldi	r21, 0x00	; 0
    12ea:	28 ed       	ldi	r18, 0xD8	; 216
    12ec:	36 e0       	ldi	r19, 0x06	; 6
    12ee:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <__eewr_block>
    12f2:	55 24       	eor	r5, r5
		return 0;
}

inline int testForHomeChord(int stringState[])
{
	if ((stringState[0] == 0b00100000) &&
    12f4:	2a a5       	ldd	r18, Y+42	; 0x2a
    12f6:	3b a5       	ldd	r19, Y+43	; 0x2b
    12f8:	20 32       	cpi	r18, 0x20	; 32
    12fa:	31 05       	cpc	r19, r1
    12fc:	b1 f4       	brne	.+44     	; 0x132a <main+0x4aa>
    12fe:	8c a5       	ldd	r24, Y+44	; 0x2c
    1300:	9d a5       	ldd	r25, Y+45	; 0x2d
    1302:	89 2b       	or	r24, r25
    1304:	91 f4       	brne	.+36     	; 0x132a <main+0x4aa>
    1306:	8e a5       	ldd	r24, Y+46	; 0x2e
    1308:	9f a5       	ldd	r25, Y+47	; 0x2f
    130a:	89 2b       	or	r24, r25
    130c:	71 f4       	brne	.+28     	; 0x132a <main+0x4aa>
    130e:	88 a9       	ldd	r24, Y+48	; 0x30
    1310:	99 a9       	ldd	r25, Y+49	; 0x31
    1312:	89 2b       	or	r24, r25
    1314:	51 f4       	brne	.+20     	; 0x132a <main+0x4aa>
    1316:	8a a9       	ldd	r24, Y+50	; 0x32
    1318:	9b a9       	ldd	r25, Y+51	; 0x33
    131a:	89 2b       	or	r24, r25
    131c:	31 f4       	brne	.+12     	; 0x132a <main+0x4aa>
    131e:	8c a9       	ldd	r24, Y+52	; 0x34
    1320:	9d a9       	ldd	r25, Y+53	; 0x35
    1322:	80 97       	sbiw	r24, 0x20	; 32
    1324:	11 f4       	brne	.+4      	; 0x132a <main+0x4aa>
		}
		
		// Test if we're trying to hit the Home button
		if(testForHomeChord(stringState))
		{
			data.homeOn = 1;
    1326:	b1 e0       	ldi	r27, 0x01	; 1
    1328:	b9 8b       	std	Y+17, r27	; 0x11
		}

		// Check to see if we're trying to enter Config Mode;
		// disabled if we're playing with frets
		if ((controllerMode == NOTES) || (controllerMode == CHORDS))
    132a:	e2 e0       	ldi	r30, 0x02	; 2
    132c:	5e 16       	cp	r5, r30
    132e:	21 f0       	breq	.+8      	; 0x1338 <main+0x4b8>
    1330:	f4 e0       	ldi	r31, 0x04	; 4
    1332:	5f 16       	cp	r5, r31
    1334:	09 f0       	breq	.+2      	; 0x1338 <main+0x4b8>
    1336:	f1 c0       	rjmp	.+482    	; 0x151a <main+0x69a>
		{
			if (configMode == 0)
    1338:	44 20       	and	r4, r4
    133a:	09 f0       	breq	.+2      	; 0x133e <main+0x4be>
    133c:	9e c0       	rjmp	.+316    	; 0x147a <main+0x5fa>

// This function tests to see if you're pressing the top 4 strings on the orange fret,
//  thereby activating config mode. Works with both chords and scales.
inline char testForConfigMode(int stringState[])
{
	if ((stringState[0] == 0b00100000) &&
    133e:	20 32       	cpi	r18, 0x20	; 32
    1340:	31 05       	cpc	r19, r1
    1342:	09 f0       	breq	.+2      	; 0x1346 <main+0x4c6>
    1344:	97 c0       	rjmp	.+302    	; 0x1474 <main+0x5f4>
    1346:	8c a5       	ldd	r24, Y+44	; 0x2c
    1348:	9d a5       	ldd	r25, Y+45	; 0x2d
    134a:	80 97       	sbiw	r24, 0x20	; 32
    134c:	09 f0       	breq	.+2      	; 0x1350 <main+0x4d0>
    134e:	92 c0       	rjmp	.+292    	; 0x1474 <main+0x5f4>
    1350:	8e a5       	ldd	r24, Y+46	; 0x2e
    1352:	9f a5       	ldd	r25, Y+47	; 0x2f
    1354:	80 97       	sbiw	r24, 0x20	; 32
    1356:	09 f0       	breq	.+2      	; 0x135a <main+0x4da>
    1358:	8d c0       	rjmp	.+282    	; 0x1474 <main+0x5f4>
    135a:	88 a9       	ldd	r24, Y+48	; 0x30
    135c:	99 a9       	ldd	r25, Y+49	; 0x31
    135e:	89 2b       	or	r24, r25
    1360:	09 f0       	breq	.+2      	; 0x1364 <main+0x4e4>
    1362:	88 c0       	rjmp	.+272    	; 0x1474 <main+0x5f4>
    1364:	8a a9       	ldd	r24, Y+50	; 0x32
    1366:	9b a9       	ldd	r25, Y+51	; 0x33
    1368:	89 2b       	or	r24, r25
    136a:	09 f0       	breq	.+2      	; 0x136e <main+0x4ee>
    136c:	83 c0       	rjmp	.+262    	; 0x1474 <main+0x5f4>
    136e:	8c a9       	ldd	r24, Y+52	; 0x34
    1370:	9d a9       	ldd	r25, Y+53	; 0x35
    1372:	89 2b       	or	r24, r25
    1374:	09 f0       	breq	.+2      	; 0x1378 <main+0x4f8>
    1376:	7e c0       	rjmp	.+252    	; 0x1474 <main+0x5f4>
			{
				configMode = testForConfigMode(stringState);
				
				// If we're playing with notes, when we enter config mode, we need to clear the 
				//  button string patterns once so we can rebuild them.
				if (configMode == 1 && controllerMode == NOTES)
    1378:	82 e0       	ldi	r24, 0x02	; 2
    137a:	58 16       	cp	r5, r24
    137c:	09 f0       	breq	.+2      	; 0x1380 <main+0x500>
    137e:	78 c0       	rjmp	.+240    	; 0x1470 <main+0x5f0>
	return stringState;
}

inline void clearButtonStringPatterns(int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
	buttonStringPatterns[0][0] = 0;	buttonStringPatterns[0][1] = 0;
    1380:	d3 01       	movw	r26, r6
    1382:	11 96       	adiw	r26, 0x01	; 1
    1384:	1c 92       	st	X, r1
    1386:	1e 92       	st	-X, r1
    1388:	13 96       	adiw	r26, 0x03	; 3
    138a:	1c 92       	st	X, r1
    138c:	1e 92       	st	-X, r1
    138e:	12 97       	sbiw	r26, 0x02	; 2
	buttonStringPatterns[0][2] = 0;	buttonStringPatterns[0][3] = 0;
    1390:	15 96       	adiw	r26, 0x05	; 5
    1392:	1c 92       	st	X, r1
    1394:	1e 92       	st	-X, r1
    1396:	14 97       	sbiw	r26, 0x04	; 4
    1398:	17 96       	adiw	r26, 0x07	; 7
    139a:	1c 92       	st	X, r1
    139c:	1e 92       	st	-X, r1
    139e:	16 97       	sbiw	r26, 0x06	; 6
	buttonStringPatterns[0][4] = 0;	buttonStringPatterns[0][5] = 0;
    13a0:	19 96       	adiw	r26, 0x09	; 9
    13a2:	1c 92       	st	X, r1
    13a4:	1e 92       	st	-X, r1
    13a6:	18 97       	sbiw	r26, 0x08	; 8
    13a8:	1b 96       	adiw	r26, 0x0b	; 11
    13aa:	1c 92       	st	X, r1
    13ac:	1e 92       	st	-X, r1
    13ae:	1a 97       	sbiw	r26, 0x0a	; 10
	buttonStringPatterns[1][0] = 0;	buttonStringPatterns[1][1] = 0;
    13b0:	1d 96       	adiw	r26, 0x0d	; 13
    13b2:	1c 92       	st	X, r1
    13b4:	1e 92       	st	-X, r1
    13b6:	1c 97       	sbiw	r26, 0x0c	; 12
    13b8:	1f 96       	adiw	r26, 0x0f	; 15
    13ba:	1c 92       	st	X, r1
    13bc:	1e 92       	st	-X, r1
    13be:	1e 97       	sbiw	r26, 0x0e	; 14
	buttonStringPatterns[1][2] = 0;	buttonStringPatterns[1][3] = 0;
    13c0:	51 96       	adiw	r26, 0x11	; 17
    13c2:	1c 92       	st	X, r1
    13c4:	1e 92       	st	-X, r1
    13c6:	50 97       	sbiw	r26, 0x10	; 16
    13c8:	53 96       	adiw	r26, 0x13	; 19
    13ca:	1c 92       	st	X, r1
    13cc:	1e 92       	st	-X, r1
    13ce:	52 97       	sbiw	r26, 0x12	; 18
	buttonStringPatterns[1][4] = 0;	buttonStringPatterns[1][5] = 0;
    13d0:	55 96       	adiw	r26, 0x15	; 21
    13d2:	1c 92       	st	X, r1
    13d4:	1e 92       	st	-X, r1
    13d6:	54 97       	sbiw	r26, 0x14	; 20
    13d8:	57 96       	adiw	r26, 0x17	; 23
    13da:	1c 92       	st	X, r1
    13dc:	1e 92       	st	-X, r1
    13de:	56 97       	sbiw	r26, 0x16	; 22
	buttonStringPatterns[2][0] = 0;	buttonStringPatterns[2][1] = 0;
    13e0:	59 96       	adiw	r26, 0x19	; 25
    13e2:	1c 92       	st	X, r1
    13e4:	1e 92       	st	-X, r1
    13e6:	58 97       	sbiw	r26, 0x18	; 24
    13e8:	5b 96       	adiw	r26, 0x1b	; 27
    13ea:	1c 92       	st	X, r1
    13ec:	1e 92       	st	-X, r1
    13ee:	5a 97       	sbiw	r26, 0x1a	; 26
	buttonStringPatterns[2][2] = 0;	buttonStringPatterns[2][3] = 0;
    13f0:	5d 96       	adiw	r26, 0x1d	; 29
    13f2:	1c 92       	st	X, r1
    13f4:	1e 92       	st	-X, r1
    13f6:	5c 97       	sbiw	r26, 0x1c	; 28
    13f8:	5f 96       	adiw	r26, 0x1f	; 31
    13fa:	1c 92       	st	X, r1
    13fc:	1e 92       	st	-X, r1
    13fe:	5e 97       	sbiw	r26, 0x1e	; 30
	buttonStringPatterns[2][4] = 0;	buttonStringPatterns[2][5] = 0;
    1400:	91 96       	adiw	r26, 0x21	; 33
    1402:	1c 92       	st	X, r1
    1404:	1e 92       	st	-X, r1
    1406:	90 97       	sbiw	r26, 0x20	; 32
    1408:	93 96       	adiw	r26, 0x23	; 35
    140a:	1c 92       	st	X, r1
    140c:	1e 92       	st	-X, r1
    140e:	92 97       	sbiw	r26, 0x22	; 34
	buttonStringPatterns[3][0] = 0;	buttonStringPatterns[3][1] = 0;
    1410:	95 96       	adiw	r26, 0x25	; 37
    1412:	1c 92       	st	X, r1
    1414:	1e 92       	st	-X, r1
    1416:	94 97       	sbiw	r26, 0x24	; 36
    1418:	97 96       	adiw	r26, 0x27	; 39
    141a:	1c 92       	st	X, r1
    141c:	1e 92       	st	-X, r1
    141e:	96 97       	sbiw	r26, 0x26	; 38
	buttonStringPatterns[3][2] = 0;	buttonStringPatterns[3][3] = 0;
    1420:	99 96       	adiw	r26, 0x29	; 41
    1422:	1c 92       	st	X, r1
    1424:	1e 92       	st	-X, r1
    1426:	98 97       	sbiw	r26, 0x28	; 40
    1428:	9b 96       	adiw	r26, 0x2b	; 43
    142a:	1c 92       	st	X, r1
    142c:	1e 92       	st	-X, r1
    142e:	9a 97       	sbiw	r26, 0x2a	; 42
	buttonStringPatterns[3][4] = 0;	buttonStringPatterns[3][5] = 0;
    1430:	9d 96       	adiw	r26, 0x2d	; 45
    1432:	1c 92       	st	X, r1
    1434:	1e 92       	st	-X, r1
    1436:	9c 97       	sbiw	r26, 0x2c	; 44
    1438:	9f 96       	adiw	r26, 0x2f	; 47
    143a:	1c 92       	st	X, r1
    143c:	1e 92       	st	-X, r1
    143e:	9e 97       	sbiw	r26, 0x2e	; 46
	buttonStringPatterns[4][0] = 0;	buttonStringPatterns[4][1] = 0;
    1440:	d1 96       	adiw	r26, 0x31	; 49
    1442:	1c 92       	st	X, r1
    1444:	1e 92       	st	-X, r1
    1446:	d0 97       	sbiw	r26, 0x30	; 48
    1448:	d3 96       	adiw	r26, 0x33	; 51
    144a:	1c 92       	st	X, r1
    144c:	1e 92       	st	-X, r1
    144e:	d2 97       	sbiw	r26, 0x32	; 50
	buttonStringPatterns[4][2] = 0;	buttonStringPatterns[4][3] = 0;
    1450:	d5 96       	adiw	r26, 0x35	; 53
    1452:	1c 92       	st	X, r1
    1454:	1e 92       	st	-X, r1
    1456:	d4 97       	sbiw	r26, 0x34	; 52
    1458:	d7 96       	adiw	r26, 0x37	; 55
    145a:	1c 92       	st	X, r1
    145c:	1e 92       	st	-X, r1
    145e:	d6 97       	sbiw	r26, 0x36	; 54
	buttonStringPatterns[4][4] = 0;	buttonStringPatterns[4][5] = 0;
    1460:	d9 96       	adiw	r26, 0x39	; 57
    1462:	1c 92       	st	X, r1
    1464:	1e 92       	st	-X, r1
    1466:	d8 97       	sbiw	r26, 0x38	; 56
    1468:	db 96       	adiw	r26, 0x3b	; 59
    146a:	1c 92       	st	X, r1
    146c:	1e 92       	st	-X, r1
    146e:	da 97       	sbiw	r26, 0x3a	; 58
    1470:	44 24       	eor	r4, r4
    1472:	43 94       	inc	r4
				//  button string patterns once so we can rebuild them.
				if (configMode == 1 && controllerMode == NOTES)
				{
					clearButtonStringPatterns(buttonStringPatterns);
				}
				buttonToAssign = 0; // This variable keeps track of which button we're assigning
    1474:	1c 82       	std	Y+4, r1	; 0x04
    1476:	1b 82       	std	Y+3, r1	; 0x03
				plusLock = 0; // This is a tool to let us test that in the prior cycle, plus was or wasn't on
    1478:	19 82       	std	Y+1, r1	; 0x01
			}

			// Config Mode operation
			if (configMode == 1) 
    147a:	b1 e0       	ldi	r27, 0x01	; 1
    147c:	4b 16       	cp	r4, r27
    147e:	09 f0       	breq	.+2      	; 0x1482 <main+0x602>
    1480:	4c c0       	rjmp	.+152    	; 0x151a <main+0x69a>
}

//This function tests to see if we're pressing the correct string combination to end config mode
inline char testForEndConfigMode(int stringState[])
{
	if ((stringState[0] == 0b00000000) &&
    1482:	23 2b       	or	r18, r19
    1484:	09 f0       	breq	.+2      	; 0x1488 <main+0x608>
    1486:	e8 c0       	rjmp	.+464    	; 0x1658 <main+0x7d8>
    1488:	8c a5       	ldd	r24, Y+44	; 0x2c
    148a:	9d a5       	ldd	r25, Y+45	; 0x2d
    148c:	80 97       	sbiw	r24, 0x20	; 32
    148e:	09 f0       	breq	.+2      	; 0x1492 <main+0x612>
    1490:	e3 c0       	rjmp	.+454    	; 0x1658 <main+0x7d8>
    1492:	8e a5       	ldd	r24, Y+46	; 0x2e
    1494:	9f a5       	ldd	r25, Y+47	; 0x2f
    1496:	80 97       	sbiw	r24, 0x20	; 32
    1498:	09 f0       	breq	.+2      	; 0x149c <main+0x61c>
    149a:	de c0       	rjmp	.+444    	; 0x1658 <main+0x7d8>
    149c:	88 a9       	ldd	r24, Y+48	; 0x30
    149e:	99 a9       	ldd	r25, Y+49	; 0x31
    14a0:	80 97       	sbiw	r24, 0x20	; 32
    14a2:	09 f0       	breq	.+2      	; 0x14a6 <main+0x626>
    14a4:	d9 c0       	rjmp	.+434    	; 0x1658 <main+0x7d8>
    14a6:	8a a9       	ldd	r24, Y+50	; 0x32
    14a8:	9b a9       	ldd	r25, Y+51	; 0x33
    14aa:	89 2b       	or	r24, r25
    14ac:	09 f0       	breq	.+2      	; 0x14b0 <main+0x630>
    14ae:	d4 c0       	rjmp	.+424    	; 0x1658 <main+0x7d8>
    14b0:	8c a9       	ldd	r24, Y+52	; 0x34
    14b2:	9d a9       	ldd	r25, Y+53	; 0x35
    14b4:	89 2b       	or	r24, r25
    14b6:	09 f0       	breq	.+2      	; 0x14ba <main+0x63a>
    14b8:	cf c0       	rjmp	.+414    	; 0x1658 <main+0x7d8>
				if (testForEndConfigMode(stringState))
					{
						// Now save this new button mapping to the EEPROM 
						// Since we're already passing in buttonsStringPatterns
						// as a pointer, we don't use the '&' operator
						if (controllerMode == NOTES)
    14ba:	e2 e0       	ldi	r30, 0x02	; 2
    14bc:	5e 16       	cp	r5, r30
    14be:	31 f4       	brne	.+12     	; 0x14cc <main+0x64c>
    14c0:	80 e0       	ldi	r24, 0x00	; 0
    14c2:	90 e0       	ldi	r25, 0x00	; 0
    14c4:	b3 01       	movw	r22, r6
    14c6:	4c e3       	ldi	r20, 0x3C	; 60
    14c8:	50 e0       	ldi	r21, 0x00	; 0
    14ca:	22 c0       	rjmp	.+68     	; 0x1510 <main+0x690>
							eeprom_write_block( (void*)buttonStringPatterns, (void*)&notesModeButtonPatterns, EEPROM_NOTES_BLOCK_SIZE);
						else if (controllerMode == CHORDS)
    14cc:	f4 e0       	ldi	r31, 0x04	; 4
    14ce:	5f 16       	cp	r5, r31
    14d0:	39 f5       	brne	.+78     	; 0x1520 <main+0x6a0>
    14d2:	19 c0       	rjmp	.+50     	; 0x1506 <main+0x686>
					
					data.plusOn = 0; // Make sure we're not actually sending a "plus" signal to the controller, though.
									// If we were, it would pause the game.

					// If we've assigned allcolors in Notes mode, cycle back to programming Green 
					if (controllerMode == NOTES && buttonToAssign >= NUM_NOTES_BUTTONS && plusLock == 0 )
    14d4:	8b 81       	ldd	r24, Y+3	; 0x03
    14d6:	9c 81       	ldd	r25, Y+4	; 0x04
    14d8:	05 97       	sbiw	r24, 0x05	; 5
    14da:	0c f4       	brge	.+2      	; 0x14de <main+0x65e>
    14dc:	af c0       	rjmp	.+350    	; 0x163c <main+0x7bc>
    14de:	89 81       	ldd	r24, Y+1	; 0x01
    14e0:	88 23       	and	r24, r24
    14e2:	09 f0       	breq	.+2      	; 0x14e6 <main+0x666>
    14e4:	ab c0       	rjmp	.+342    	; 0x163c <main+0x7bc>
					{
						buttonToAssign = 0;
    14e6:	1c 82       	std	Y+4, r1	; 0x04
    14e8:	1b 82       	std	Y+3, r1	; 0x03
    14ea:	a8 c0       	rjmp	.+336    	; 0x163c <main+0x7bc>
					}
					
					// Or if we've programmed all 10 notes in Chord mode, exit programming mode
					if (controllerMode == CHORDS && buttonToAssign >= NUM_CHORDS_BUTTONS && plusLock == 0 )
    14ec:	24 e0       	ldi	r18, 0x04	; 4
    14ee:	52 16       	cp	r5, r18
    14f0:	09 f0       	breq	.+2      	; 0x14f4 <main+0x674>
    14f2:	a4 c0       	rjmp	.+328    	; 0x163c <main+0x7bc>
    14f4:	8b 81       	ldd	r24, Y+3	; 0x03
    14f6:	9c 81       	ldd	r25, Y+4	; 0x04
    14f8:	0a 97       	sbiw	r24, 0x0a	; 10
    14fa:	0c f4       	brge	.+2      	; 0x14fe <main+0x67e>
    14fc:	9f c0       	rjmp	.+318    	; 0x163c <main+0x7bc>
    14fe:	89 81       	ldd	r24, Y+1	; 0x01
    1500:	88 23       	and	r24, r24
    1502:	09 f0       	breq	.+2      	; 0x1506 <main+0x686>
    1504:	9b c0       	rjmp	.+310    	; 0x163c <main+0x7bc>
    1506:	88 e7       	ldi	r24, 0x78	; 120
    1508:	90 e0       	ldi	r25, 0x00	; 0
    150a:	b3 01       	movw	r22, r6
    150c:	48 e7       	ldi	r20, 0x78	; 120
    150e:	50 e0       	ldi	r21, 0x00	; 0
    1510:	28 ed       	ldi	r18, 0xD8	; 216
    1512:	36 e0       	ldi	r19, 0x06	; 6
    1514:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <__eewr_block>
    1518:	03 c0       	rjmp	.+6      	; 0x1520 <main+0x6a0>
					}
		}	}	}	 // End of Config Mode code

		
		// Normal operation
		if (configMode == 0)
    151a:	44 20       	and	r4, r4
    151c:	09 f0       	breq	.+2      	; 0x1520 <main+0x6a0>
    151e:	8e c0       	rjmp	.+284    	; 0x163c <main+0x7bc>
		return 0;
}

inline int testForMinusChord(int stringState[])
{
	if ((stringState[0] == 0b00000000) &&
    1520:	8a a5       	ldd	r24, Y+42	; 0x2a
    1522:	9b a5       	ldd	r25, Y+43	; 0x2b
    1524:	89 2b       	or	r24, r25
    1526:	09 f0       	breq	.+2      	; 0x152a <main+0x6aa>
    1528:	5b c0       	rjmp	.+182    	; 0x15e0 <main+0x760>
    152a:	8c a5       	ldd	r24, Y+44	; 0x2c
    152c:	9d a5       	ldd	r25, Y+45	; 0x2d
    152e:	89 2b       	or	r24, r25
    1530:	09 f0       	breq	.+2      	; 0x1534 <main+0x6b4>
    1532:	56 c0       	rjmp	.+172    	; 0x15e0 <main+0x760>
    1534:	2e a5       	ldd	r18, Y+46	; 0x2e
    1536:	3f a5       	ldd	r19, Y+47	; 0x2f
    1538:	21 15       	cp	r18, r1
    153a:	31 05       	cpc	r19, r1
    153c:	71 f4       	brne	.+28     	; 0x155a <main+0x6da>
    153e:	88 a9       	ldd	r24, Y+48	; 0x30
    1540:	99 a9       	ldd	r25, Y+49	; 0x31
    1542:	89 2b       	or	r24, r25
    1544:	51 f4       	brne	.+20     	; 0x155a <main+0x6da>
    1546:	8a a9       	ldd	r24, Y+50	; 0x32
    1548:	9b a9       	ldd	r25, Y+51	; 0x33
    154a:	89 2b       	or	r24, r25
    154c:	31 f4       	brne	.+12     	; 0x155a <main+0x6da>
    154e:	8c a9       	ldd	r24, Y+52	; 0x34
    1550:	9d a9       	ldd	r25, Y+53	; 0x35
    1552:	80 97       	sbiw	r24, 0x20	; 32
    1554:	11 f4       	brne	.+4      	; 0x155a <main+0x6da>
		{
			//Test if Minus is being played by the chord instead of the button
			// This means it won't get read in config mode, which is good.
			if(testForMinusChord(stringState))
				data.minusOn = 1;
    1556:	81 e0       	ldi	r24, 0x01	; 1
    1558:	8f 87       	std	Y+15, r24	; 0x0f
}

inline int testForSwitchModes(int stringState[])
{
	// Test for the right keypress to start the mode
	if ((stringState[0] == 0b00000000) &&
    155a:	20 32       	cpi	r18, 0x20	; 32
    155c:	31 05       	cpc	r19, r1
    155e:	81 f4       	brne	.+32     	; 0x1580 <main+0x700>
    1560:	88 a9       	ldd	r24, Y+48	; 0x30
    1562:	99 a9       	ldd	r25, Y+49	; 0x31
    1564:	80 97       	sbiw	r24, 0x20	; 32
    1566:	e1 f5       	brne	.+120    	; 0x15e0 <main+0x760>
    1568:	8a a9       	ldd	r24, Y+50	; 0x32
    156a:	9b a9       	ldd	r25, Y+51	; 0x33
    156c:	80 97       	sbiw	r24, 0x20	; 32
    156e:	c1 f5       	brne	.+112    	; 0x15e0 <main+0x760>
    1570:	8c a9       	ldd	r24, Y+52	; 0x34
    1572:	9d a9       	ldd	r25, Y+53	; 0x35
    1574:	89 2b       	or	r24, r25
    1576:	a1 f5       	brne	.+104    	; 0x15e0 <main+0x760>
static inline void switchPlayModes(int stringState[], int buttonStringPatterns[][6], char* controllerMode)
{
	// Test for the right keypress to start the mode
	if (testForSwitchModes(stringState))
	{
		if (*controllerMode % 2 == 0) // This means that the mode is a full mode
    1578:	50 fc       	sbrc	r5, 0
    157a:	32 c0       	rjmp	.+100    	; 0x15e0 <main+0x760>
			{++*controllerMode;}  //This puts it into a transitional mode
    157c:	53 94       	inc	r5
    157e:	30 c0       	rjmp	.+96     	; 0x15e0 <main+0x760>
		return 0;
}

inline int testForNoStringsPressed(int stringState[])
{
	if ((stringState[0] == 0b00000000) &&
    1580:	23 2b       	or	r18, r19
    1582:	71 f5       	brne	.+92     	; 0x15e0 <main+0x760>
    1584:	88 a9       	ldd	r24, Y+48	; 0x30
    1586:	99 a9       	ldd	r25, Y+49	; 0x31
    1588:	89 2b       	or	r24, r25
    158a:	51 f5       	brne	.+84     	; 0x15e0 <main+0x760>
    158c:	8a a9       	ldd	r24, Y+50	; 0x32
    158e:	9b a9       	ldd	r25, Y+51	; 0x33
    1590:	89 2b       	or	r24, r25
    1592:	31 f5       	brne	.+76     	; 0x15e0 <main+0x760>
    1594:	8c a9       	ldd	r24, Y+52	; 0x34
    1596:	9d a9       	ldd	r25, Y+53	; 0x35
    1598:	89 2b       	or	r24, r25
    159a:	11 f5       	brne	.+68     	; 0x15e0 <main+0x760>
	}
	// And if we're not pressing that anymore, switch from the transitional mode to the regular mode,
	//  resetting the button patterns as necessary
	else if(testForNoStringsPressed(stringState)) 
	{
		if (*controllerMode == CHORDS_TO_FRETS) // since these modes are just numbers, we need to wrap around
    159c:	95 e0       	ldi	r25, 0x05	; 5
    159e:	59 16       	cp	r5, r25
    15a0:	11 f4       	brne	.+4      	; 0x15a6 <main+0x726>
    15a2:	55 24       	eor	r5, r5
    15a4:	1d c0       	rjmp	.+58     	; 0x15e0 <main+0x760>
			{*controllerMode = FRETS;}

		// Now, reset the buttonStringPattern array to be appropriate for the mode
		// For this, we'll read it from the EEPROM memory.
		else if (*controllerMode  == FRETS_TO_NOTES)
    15a6:	a1 e0       	ldi	r26, 0x01	; 1
    15a8:	5a 16       	cp	r5, r26
    15aa:	61 f4       	brne	.+24     	; 0x15c4 <main+0x744>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    15ac:	c3 01       	movw	r24, r6
    15ae:	60 e0       	ldi	r22, 0x00	; 0
    15b0:	70 e0       	ldi	r23, 0x00	; 0
    15b2:	4c e3       	ldi	r20, 0x3C	; 60
    15b4:	50 e0       	ldi	r21, 0x00	; 0
    15b6:	20 ed       	ldi	r18, 0xD0	; 208
    15b8:	36 e0       	ldi	r19, 0x06	; 6
    15ba:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <__eerd_block>
    15be:	b2 e0       	ldi	r27, 0x02	; 2
    15c0:	5b 2e       	mov	r5, r27
    15c2:	0e c0       	rjmp	.+28     	; 0x15e0 <main+0x760>
		{
			// Notice, we're already passing in buttonStringPatterns as an address, so the EEPROM read looks a bit strange
			eeprom_read_block( (void*)buttonStringPatterns, (void*)&notesModeButtonPatterns, EEPROM_NOTES_BLOCK_SIZE);
			*controllerMode = NOTES;
		}
		else if (*controllerMode  == NOTES_TO_CHORDS)
    15c4:	b3 e0       	ldi	r27, 0x03	; 3
    15c6:	5b 16       	cp	r5, r27
    15c8:	59 f4       	brne	.+22     	; 0x15e0 <main+0x760>
    15ca:	c3 01       	movw	r24, r6
    15cc:	68 e7       	ldi	r22, 0x78	; 120
    15ce:	70 e0       	ldi	r23, 0x00	; 0
    15d0:	48 e7       	ldi	r20, 0x78	; 120
    15d2:	50 e0       	ldi	r21, 0x00	; 0
    15d4:	20 ed       	ldi	r18, 0xD0	; 208
    15d6:	36 e0       	ldi	r19, 0x06	; 6
    15d8:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <__eerd_block>
    15dc:	a4 e0       	ldi	r26, 0x04	; 4
    15de:	5a 2e       	mov	r5, r26
			switchPlayModes(stringState, buttonStringPatterns, &controllerMode);

			// Next, using our strumState array, we process that data to figure out what sort
			//  of buttons on the controller we want to emulate pressing.
			// find out if we're in a transitional controller mode or not
			if (!(controllerMode % 2)) // Not a transitional mode
    15e0:	65 2d       	mov	r22, r5
    15e2:	50 fc       	sbrc	r5, 0
    15e4:	25 c0       	rjmp	.+74     	; 0x1630 <main+0x7b0>
			{	//  This function can be found in processStringState.h/.c
				processStringState(&data, stringState, buttonStringPatterns, controllerMode, greenTimers, triedGreen);
    15e6:	ce 01       	movw	r24, r28
    15e8:	07 96       	adiw	r24, 0x07	; 7
    15ea:	c0 5c       	subi	r28, 0xC0	; 192
    15ec:	de 4f       	sbci	r29, 0xFE	; 254
    15ee:	68 81       	ld	r22, Y
    15f0:	c0 54       	subi	r28, 0x40	; 64
    15f2:	d1 40       	sbci	r29, 0x01	; 1
    15f4:	cf 5b       	subi	r28, 0xBF	; 191
    15f6:	de 4f       	sbci	r29, 0xFE	; 254
    15f8:	78 81       	ld	r23, Y
    15fa:	c1 54       	subi	r28, 0x41	; 65
    15fc:	d1 40       	sbci	r29, 0x01	; 1
    15fe:	a3 01       	movw	r20, r6
    1600:	25 2d       	mov	r18, r5
    1602:	cc 5b       	subi	r28, 0xBC	; 188
    1604:	de 4f       	sbci	r29, 0xFE	; 254
    1606:	08 81       	ld	r16, Y
    1608:	c4 54       	subi	r28, 0x44	; 68
    160a:	d1 40       	sbci	r29, 0x01	; 1
    160c:	cb 5b       	subi	r28, 0xBB	; 187
    160e:	de 4f       	sbci	r29, 0xFE	; 254
    1610:	18 81       	ld	r17, Y
    1612:	c5 54       	subi	r28, 0x45	; 69
    1614:	d1 40       	sbci	r29, 0x01	; 1
    1616:	ca 5b       	subi	r28, 0xBA	; 186
    1618:	de 4f       	sbci	r29, 0xFE	; 254
    161a:	e8 80       	ld	r14, Y
    161c:	c6 54       	subi	r28, 0x46	; 70
    161e:	d1 40       	sbci	r29, 0x01	; 1
    1620:	c9 5b       	subi	r28, 0xB9	; 185
    1622:	de 4f       	sbci	r29, 0xFE	; 254
    1624:	f8 80       	ld	r15, Y
    1626:	c7 54       	subi	r28, 0x47	; 71
    1628:	d1 40       	sbci	r29, 0x01	; 1
    162a:	0e 94 e5 04 	call	0x9ca	; 0x9ca <processStringState>
    162e:	05 c0       	rjmp	.+10     	; 0x163a <main+0x7ba>
			}
			else
			{   // Now, if we're in a transitional controller mode, we'll forget that data and substitue 
				// visual cue data to show that we're changing to a specific mode
				//  The function itself can be found in processStringState.h/.c
				displayTransitionState(&data, controllerMode);
    1630:	ce 01       	movw	r24, r28
    1632:	07 96       	adiw	r24, 0x07	; 7
    1634:	70 e0       	ldi	r23, 0x00	; 0
    1636:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <displayTransitionState>
    163a:	44 24       	eor	r4, r4
		}
			    
		// Now our processing is complete, so using those button presses, we set up the 
		// button data packet. This function depends on the console and is 
		// set specially in the interface functions - see ps3interface.h, wiiinterface.h, etc.
		sendDualShockData(data);
    163c:	ef 80       	ldd	r14, Y+7	; 0x07
    163e:	f8 84       	ldd	r15, Y+8	; 0x08
    1640:	09 85       	ldd	r16, Y+9	; 0x09
    1642:	1a 85       	ldd	r17, Y+10	; 0x0a
    1644:	2b 85       	ldd	r18, Y+11	; 0x0b
    1646:	3c 85       	ldd	r19, Y+12	; 0x0c
    1648:	4d 85       	ldd	r20, Y+13	; 0x0d
    164a:	5e 85       	ldd	r21, Y+14	; 0x0e
    164c:	6f 85       	ldd	r22, Y+15	; 0x0f
    164e:	78 89       	ldd	r23, Y+16	; 0x10
    1650:	89 89       	ldd	r24, Y+17	; 0x11
    1652:	0e 94 77 0b 	call	0x16ee	; 0x16ee <sendDualShockData>
    1656:	a8 cc       	rjmp	.-1712   	; 0xfa8 <main+0x128>
				else
				{
					// Now set up the data packet to the interface layer to say we're pressing whatever button we're currently
					// assigning, and if we're pressing 'plus', go ahead and lock that string combination in
					//  The function itself can be found in processStringState.h/.c
					configSetButtonData(&data, &buttonToAssign, buttonStringPatterns, stringState, controllerMode,
    1658:	ce 01       	movw	r24, r28
    165a:	07 96       	adiw	r24, 0x07	; 7
    165c:	be 01       	movw	r22, r28
    165e:	6d 5f       	subi	r22, 0xFD	; 253
    1660:	7f 4f       	sbci	r23, 0xFF	; 255
    1662:	a3 01       	movw	r20, r6
    1664:	c0 5c       	subi	r28, 0xC0	; 192
    1666:	de 4f       	sbci	r29, 0xFE	; 254
    1668:	28 81       	ld	r18, Y
    166a:	c0 54       	subi	r28, 0x40	; 64
    166c:	d1 40       	sbci	r29, 0x01	; 1
    166e:	cf 5b       	subi	r28, 0xBF	; 191
    1670:	de 4f       	sbci	r29, 0xFE	; 254
    1672:	38 81       	ld	r19, Y
    1674:	c1 54       	subi	r28, 0x41	; 65
    1676:	d1 40       	sbci	r29, 0x01	; 1
    1678:	05 2d       	mov	r16, r5
    167a:	7e 01       	movw	r14, r28
    167c:	08 94       	sec
    167e:	e1 1c       	adc	r14, r1
    1680:	f1 1c       	adc	r15, r1
    1682:	f2 e0       	ldi	r31, 0x02	; 2
    1684:	cf 2e       	mov	r12, r31
    1686:	d1 2c       	mov	r13, r1
    1688:	cc 0e       	add	r12, r28
    168a:	dd 1e       	adc	r13, r29
    168c:	e5 e0       	ldi	r30, 0x05	; 5
    168e:	ae 2e       	mov	r10, r30
    1690:	b1 2c       	mov	r11, r1
    1692:	ac 0e       	add	r10, r28
    1694:	bd 1e       	adc	r11, r29
    1696:	0e 94 12 05 	call	0xa24	; 0xa24 <configSetButtonData>
											&plusLock, &previousPlusOn, &debounceTimer);
					
					data.plusOn = 0; // Make sure we're not actually sending a "plus" signal to the controller, though.
    169a:	1e 86       	std	Y+14, r1	; 0x0e
									// If we were, it would pause the game.

					// If we've assigned allcolors in Notes mode, cycle back to programming Green 
					if (controllerMode == NOTES && buttonToAssign >= NUM_NOTES_BUTTONS && plusLock == 0 )
    169c:	e2 e0       	ldi	r30, 0x02	; 2
    169e:	5e 16       	cp	r5, r30
    16a0:	09 f0       	breq	.+2      	; 0x16a4 <main+0x824>
    16a2:	24 cf       	rjmp	.-440    	; 0x14ec <main+0x66c>
    16a4:	17 cf       	rjmp	.-466    	; 0x14d4 <main+0x654>

000016a6 <usbFunctionSetup>:
/* ------------------------------------------------------------------------- */
static uchar buffer[8];

usbMsgLen_t usbFunctionSetup(uchar data[8])
{
	usbRequest_t    *rq = (void *)data;
    16a6:	fc 01       	movw	r30, r24

    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS) {    /* class request */
    16a8:	80 81       	ld	r24, Z
    16aa:	80 76       	andi	r24, 0x60	; 96
    16ac:	80 32       	cpi	r24, 0x20	; 32
    16ae:	e9 f4       	brne	.+58     	; 0x16ea <usbFunctionSetup+0x44>
		/* wValue: ReportType (highbyte), ReportID (lowbyte) */
        if(rq->bRequest == USBRQ_HID_GET_REPORT) {
    16b0:	81 81       	ldd	r24, Z+1	; 0x01
    16b2:	81 30       	cpi	r24, 0x01	; 1
    16b4:	d1 f4       	brne	.+52     	; 0x16ea <usbFunctionSetup+0x44>
			 // set buffer data
			buffer[0] = 33;
    16b6:	81 e2       	ldi	r24, 0x21	; 33
    16b8:	80 93 02 01 	sts	0x0102, r24
			buffer[1] = 38;
    16bc:	86 e2       	ldi	r24, 0x26	; 38
    16be:	80 93 03 01 	sts	0x0103, r24
			buffer[2] =
    16c2:	10 92 09 01 	sts	0x0109, r1
    16c6:	10 92 08 01 	sts	0x0108, r1
    16ca:	10 92 07 01 	sts	0x0107, r1
    16ce:	10 92 06 01 	sts	0x0106, r1
    16d2:	10 92 05 01 	sts	0x0105, r1
    16d6:	10 92 04 01 	sts	0x0104, r1
			buffer[3] =
			buffer[4] =
			buffer[5] = 
			buffer[6] =
			buffer[7] = 0;
			usbMsgPtr = buffer;
    16da:	82 e0       	ldi	r24, 0x02	; 2
    16dc:	91 e0       	ldi	r25, 0x01	; 1
    16de:	90 93 2d 01 	sts	0x012D, r25
    16e2:	80 93 2c 01 	sts	0x012C, r24
    16e6:	88 e0       	ldi	r24, 0x08	; 8
    16e8:	08 95       	ret

			return 8; // send 8 bytes	
    16ea:	80 e0       	ldi	r24, 0x00	; 0
        }
    }

    return 0;   /* default for not implemented requests: return no data back to host */
}
    16ec:	08 95       	ret

000016ee <sendDualShockData>:
	usbPoll();
}


void sendDualShockData(dataForController data)
{
    16ee:	df 92       	push	r13
    16f0:	ef 92       	push	r14
    16f2:	ff 92       	push	r15
    16f4:	0f 93       	push	r16
    16f6:	1f 93       	push	r17
    16f8:	df 93       	push	r29
    16fa:	cf 93       	push	r28
    16fc:	cd b7       	in	r28, 0x3d	; 61
    16fe:	de b7       	in	r29, 0x3e	; 62
    1700:	2b 97       	sbiw	r28, 0x0b	; 11
    1702:	0f b6       	in	r0, 0x3f	; 63
    1704:	f8 94       	cli
    1706:	de bf       	out	0x3e, r29	; 62
    1708:	0f be       	out	0x3f, r0	; 63
    170a:	cd bf       	out	0x3d, r28	; 61
    170c:	e9 82       	std	Y+1, r14	; 0x01
    170e:	af 2d       	mov	r26, r15
    1710:	fa 82       	std	Y+2, r15	; 0x02
    1712:	b0 2f       	mov	r27, r16
    1714:	0b 83       	std	Y+3, r16	; 0x03
    1716:	f1 2f       	mov	r31, r17
    1718:	1c 83       	std	Y+4, r17	; 0x04
    171a:	e2 2f       	mov	r30, r18
    171c:	2d 83       	std	Y+5, r18	; 0x05
    171e:	13 2f       	mov	r17, r19
    1720:	3e 83       	std	Y+6, r19	; 0x06
    1722:	24 2f       	mov	r18, r20
    1724:	4f 83       	std	Y+7, r20	; 0x07
    1726:	35 2f       	mov	r19, r21
    1728:	58 87       	std	Y+8, r21	; 0x08
    172a:	69 87       	std	Y+9, r22	; 0x09
    172c:	97 2f       	mov	r25, r23
    172e:	7a 87       	std	Y+10, r23	; 0x0a
    1730:	8b 87       	std	Y+11, r24	; 0x0b
    1732:	5e 2d       	mov	r21, r14
    1734:	48 2f       	mov	r20, r24
        //set the buttons to all at default positions
        reportBuffer[0] = 0b00000000;
    1736:	10 92 0b 01 	sts	0x010B, r1
        reportBuffer[1] = 0b00000000;
    173a:	10 92 0c 01 	sts	0x010C, r1
        reportBuffer[2] = 0b00001000;
    173e:	88 e0       	ldi	r24, 0x08	; 8
    1740:	80 93 0d 01 	sts	0x010D, r24
        reportBuffer[3] = 0b10000000;
    1744:	80 e8       	ldi	r24, 0x80	; 128
    1746:	80 93 0e 01 	sts	0x010E, r24
        reportBuffer[4] = 0b10000000;
    174a:	80 93 0f 01 	sts	0x010F, r24
        reportBuffer[5] = 0b10000000;
    174e:	80 93 10 01 	sts	0x0110, r24
        reportBuffer[6] = 0b10000000;
    1752:	80 93 11 01 	sts	0x0111, r24

		// First, attack buttons are going to be done with strumming - 
		//  Punch - Strum Down
		//  Kick  - Strum Up

		if (data.upOn == 1)
    1756:	11 30       	cpi	r17, 0x01	; 1
    1758:	19 f4       	brne	.+6      	; 0x1760 <sendDualShockData+0x72>
			reportBuffer[0] = 0b00000010;
    175a:	82 e0       	ldi	r24, 0x02	; 2
    175c:	80 93 0b 01 	sts	0x010B, r24
		if (data.downOn == 1)
    1760:	21 30       	cpi	r18, 0x01	; 1
    1762:	11 f4       	brne	.+4      	; 0x1768 <sendDualShockData+0x7a>
			reportBuffer[0] = 0b00000001;
    1764:	20 93 0b 01 	sts	0x010B, r18
		// Red -   Down-Left if less than 3 strings are pressed, Up-Left if 3+ strings are pressed
		// Yellow - Down or Up, using the same conditions as above
		// Blue -  Down-Right or Up-Right, again
		// Orange - Right

		if (data.greenOn == 1)
    1768:	51 30       	cpi	r21, 0x01	; 1
    176a:	39 f4       	brne	.+14     	; 0x177a <sendDualShockData+0x8c>
		{
			reportBuffer[2] |= 0b0110;
    176c:	80 91 0d 01 	lds	r24, 0x010D
    1770:	86 60       	ori	r24, 0x06	; 6
    1772:	80 93 0d 01 	sts	0x010D, r24
			reportBuffer[3] = 0x00;
    1776:	10 92 0e 01 	sts	0x010E, r1
		}

		if (data.redOn == 1)
    177a:	a1 30       	cpi	r26, 0x01	; 1
    177c:	81 f4       	brne	.+32     	; 0x179e <sendDualShockData+0xb0>
		{
			if (data.numberOfStringsPressed >=3)
    177e:	93 30       	cpi	r25, 0x03	; 3
    1780:	30 f0       	brcs	.+12     	; 0x178e <sendDualShockData+0xa0>
			{
				reportBuffer[2] = 0b0111; // D-Pad Up-Left
    1782:	87 e0       	ldi	r24, 0x07	; 7
    1784:	80 93 0d 01 	sts	0x010D, r24
				reportBuffer[4] = 0x00; //Analog Up
    1788:	10 92 0f 01 	sts	0x010F, r1
    178c:	06 c0       	rjmp	.+12     	; 0x179a <sendDualShockData+0xac>
			}
			else
			{
				reportBuffer[2] = 0b0101; //D-Pad Down-Left
    178e:	85 e0       	ldi	r24, 0x05	; 5
    1790:	80 93 0d 01 	sts	0x010D, r24
				reportBuffer[4] = 0xFF; //Analog Down
    1794:	8f ef       	ldi	r24, 0xFF	; 255
    1796:	80 93 0f 01 	sts	0x010F, r24
			}
			reportBuffer[3] = 0x00; //Analog Left
    179a:	10 92 0e 01 	sts	0x010E, r1
		}

		if (data.yellowOn == 1)
    179e:	b1 30       	cpi	r27, 0x01	; 1
    17a0:	69 f4       	brne	.+26     	; 0x17bc <sendDualShockData+0xce>
		{
			if (data.numberOfStringsPressed >=3)
    17a2:	93 30       	cpi	r25, 0x03	; 3
    17a4:	28 f0       	brcs	.+10     	; 0x17b0 <sendDualShockData+0xc2>
			{
				reportBuffer[2] = 0b0000; // D-Pad Up
    17a6:	10 92 0d 01 	sts	0x010D, r1
				reportBuffer[4] = 0x00; //Analog Up
    17aa:	10 92 0f 01 	sts	0x010F, r1
    17ae:	06 c0       	rjmp	.+12     	; 0x17bc <sendDualShockData+0xce>
			}
			else
			{
				reportBuffer[2] = 0b0100; //D-Pad Down
    17b0:	84 e0       	ldi	r24, 0x04	; 4
    17b2:	80 93 0d 01 	sts	0x010D, r24
				reportBuffer[4] = 0xFF; //Analog Down
    17b6:	8f ef       	ldi	r24, 0xFF	; 255
    17b8:	80 93 0f 01 	sts	0x010F, r24
			}
		}

		if (data.blueOn == 1)
    17bc:	f1 30       	cpi	r31, 0x01	; 1
    17be:	81 f4       	brne	.+32     	; 0x17e0 <sendDualShockData+0xf2>
		{
			if (data.numberOfStringsPressed >=3)
    17c0:	93 30       	cpi	r25, 0x03	; 3
    17c2:	28 f0       	brcs	.+10     	; 0x17ce <sendDualShockData+0xe0>
			{
				reportBuffer[2] = 0b0001; // D-Pad Up-Right
    17c4:	f0 93 0d 01 	sts	0x010D, r31
				reportBuffer[4] = 0x00; //Analog Up
    17c8:	10 92 0f 01 	sts	0x010F, r1
    17cc:	06 c0       	rjmp	.+12     	; 0x17da <sendDualShockData+0xec>
			}
			else
			{
				reportBuffer[2] = 0b0011; //D-Pad Down-Right
    17ce:	83 e0       	ldi	r24, 0x03	; 3
    17d0:	80 93 0d 01 	sts	0x010D, r24
				reportBuffer[4] = 0xFF; //Analog Down
    17d4:	8f ef       	ldi	r24, 0xFF	; 255
    17d6:	80 93 0f 01 	sts	0x010F, r24
			}
			reportBuffer[3] = 0xFF; //Analog Right
    17da:	8f ef       	ldi	r24, 0xFF	; 255
    17dc:	80 93 0e 01 	sts	0x010E, r24
		}

		if (data.orangeOn == 1)
    17e0:	e1 30       	cpi	r30, 0x01	; 1
    17e2:	31 f4       	brne	.+12     	; 0x17f0 <sendDualShockData+0x102>
		{
			reportBuffer[2] = 0b0010; //D-Pad Right
    17e4:	82 e0       	ldi	r24, 0x02	; 2
    17e6:	80 93 0d 01 	sts	0x010D, r24
			reportBuffer[3] = 0xFF; //Analog Right
    17ea:	8f ef       	ldi	r24, 0xFF	; 255
    17ec:	80 93 0e 01 	sts	0x010E, r24
		}

		//Finally, Start, Star Power, and the Home button (not working yet)
		reportBuffer[1] |= (data.plusOn << START_BIT);
		reportBuffer[1] |= (data.homeOn << HOME_BIT);
    17f0:	33 0f       	add	r19, r19
    17f2:	42 95       	swap	r20
    17f4:	40 7f       	andi	r20, 0xF0	; 240
    17f6:	34 2b       	or	r19, r20
    17f8:	80 91 0c 01 	lds	r24, 0x010C
    17fc:	83 2b       	or	r24, r19
    17fe:	80 93 0c 01 	sts	0x010C, r24

        //Then we finish off some USB stuff.
        wdt_reset();  //Reset the watchdog timer
    1802:	a8 95       	wdr
        usbPoll();    //USB poll - must be called at least once per 10ms
    1804:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <usbPoll>

        // Now, regardless of mode, we have to send the data to the 
        // USB controlling library from the buffer we've been building
        if(usbInterruptIsReady())
    1808:	80 91 1d 01 	lds	r24, 0x011D
    180c:	84 ff       	sbrs	r24, 4
    180e:	05 c0       	rjmp	.+10     	; 0x181a <sendDualShockData+0x12c>
        {
            /* called after every poll of the interrupt endpoint */
            usbSetInterrupt((void *)&reportBuffer, sizeof(reportBuffer));
    1810:	8b e0       	ldi	r24, 0x0B	; 11
    1812:	91 e0       	ldi	r25, 0x01	; 1
    1814:	67 e0       	ldi	r22, 0x07	; 7
    1816:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <usbSetInterrupt>
        }
                

}
    181a:	2b 96       	adiw	r28, 0x0b	; 11
    181c:	0f b6       	in	r0, 0x3f	; 63
    181e:	f8 94       	cli
    1820:	de bf       	out	0x3e, r29	; 62
    1822:	0f be       	out	0x3f, r0	; 63
    1824:	cd bf       	out	0x3d, r28	; 61
    1826:	cf 91       	pop	r28
    1828:	df 91       	pop	r29
    182a:	1f 91       	pop	r17
    182c:	0f 91       	pop	r16
    182e:	ff 90       	pop	r15
    1830:	ef 90       	pop	r14
    1832:	df 90       	pop	r13
    1834:	08 95       	ret

00001836 <startDualShockCommunication>:
/* ------------------------------------------------------------------------- */

void startDualShockCommunication(void)
{
    // First, set up all the USB communication stuff
    wdt_enable(WDTO_1S);
    1836:	2e e0       	ldi	r18, 0x0E	; 14
    1838:	88 e1       	ldi	r24, 0x18	; 24
    183a:	90 e0       	ldi	r25, 0x00	; 0
    183c:	0f b6       	in	r0, 0x3f	; 63
    183e:	f8 94       	cli
    1840:	a8 95       	wdr
    1842:	80 93 60 00 	sts	0x0060, r24
    1846:	0f be       	out	0x3f, r0	; 63
    1848:	20 93 60 00 	sts	0x0060, r18
     * RESET status: all port bits are inputs without pull-up.
     * That's the way we need D+ and D-. Therefore we don't need any
     * additional hardware initialization.
     */

    usbInit();
    184c:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <usbInit>
    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
    1850:	54 9a       	sbi	0x0a, 4	; 10
    1852:	20 e0       	ldi	r18, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1854:	48 eb       	ldi	r20, 0xB8	; 184
    1856:	5b e0       	ldi	r21, 0x0B	; 11
    1858:	04 c0       	rjmp	.+8      	; 0x1862 <startDualShockCommunication+0x2c>
    uchar i = 0;
    while(--i){             /* fake USB disconnect for > 250 ms */
        wdt_reset();
    185a:	a8 95       	wdr
    185c:	ca 01       	movw	r24, r20
    185e:	01 97       	sbiw	r24, 0x01	; 1
    1860:	f1 f7       	brne	.-4      	; 0x185e <startDualShockCommunication+0x28>
     */

    usbInit();
    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
    uchar i = 0;
    while(--i){             /* fake USB disconnect for > 250 ms */
    1862:	21 50       	subi	r18, 0x01	; 1
    1864:	d1 f7       	brne	.-12     	; 0x185a <startDualShockCommunication+0x24>
        wdt_reset();
        _delay_ms(1);
    }
    usbDeviceConnect();
    1866:	54 98       	cbi	0x0a, 4	; 10
    sei();
    1868:	78 94       	sei
	usbPoll();
    186a:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <usbPoll>
}
    186e:	08 95       	ret

00001870 <usbCrc16>:
    1870:	a8 2f       	mov	r26, r24
    1872:	b9 2f       	mov	r27, r25
    1874:	80 e0       	ldi	r24, 0x00	; 0
    1876:	90 e0       	ldi	r25, 0x00	; 0
    1878:	41 e0       	ldi	r20, 0x01	; 1
    187a:	50 ea       	ldi	r21, 0xA0	; 160
    187c:	60 95       	com	r22
    187e:	30 e0       	ldi	r19, 0x00	; 0
    1880:	09 c0       	rjmp	.+18     	; 0x1894 <usbCrcLoopEntry>

00001882 <usbCrcByteLoop>:
    1882:	2d 91       	ld	r18, X+
    1884:	82 27       	eor	r24, r18

00001886 <usbCrcBitLoop>:
    1886:	97 95       	ror	r25
    1888:	87 95       	ror	r24
    188a:	10 f0       	brcs	.+4      	; 0x1890 <usbCrcNoXor>
    188c:	84 27       	eor	r24, r20
    188e:	95 27       	eor	r25, r21

00001890 <usbCrcNoXor>:
    1890:	30 5e       	subi	r19, 0xE0	; 224
    1892:	c8 f3       	brcs	.-14     	; 0x1886 <usbCrcBitLoop>

00001894 <usbCrcLoopEntry>:
    1894:	6f 5f       	subi	r22, 0xFF	; 255
    1896:	a8 f3       	brcs	.-22     	; 0x1882 <usbCrcByteLoop>

00001898 <usbCrcReady>:
    1898:	08 95       	ret

0000189a <usbCrc16Append>:
    189a:	ea df       	rcall	.-44     	; 0x1870 <usbCrc16>
    189c:	8d 93       	st	X+, r24
    189e:	9d 93       	st	X+, r25
    18a0:	08 95       	ret

000018a2 <__vector_2>:
    18a2:	cf 93       	push	r28
    18a4:	cf b7       	in	r28, 0x3f	; 63
    18a6:	cf 93       	push	r28

000018a8 <waitForJ>:
    18a8:	c3 95       	inc	r28
    18aa:	4c 9b       	sbis	0x09, 4	; 9
    18ac:	e9 f7       	brne	.-6      	; 0x18a8 <waitForJ>

000018ae <waitForK>:
    18ae:	4c 9b       	sbis	0x09, 4	; 9
    18b0:	09 c0       	rjmp	.+18     	; 0x18c4 <foundK>
    18b2:	4c 9b       	sbis	0x09, 4	; 9
    18b4:	07 c0       	rjmp	.+14     	; 0x18c4 <foundK>
    18b6:	4c 9b       	sbis	0x09, 4	; 9
    18b8:	05 c0       	rjmp	.+10     	; 0x18c4 <foundK>
    18ba:	4c 9b       	sbis	0x09, 4	; 9
    18bc:	03 c0       	rjmp	.+6      	; 0x18c4 <foundK>
    18be:	4c 9b       	sbis	0x09, 4	; 9
    18c0:	01 c0       	rjmp	.+2      	; 0x18c4 <foundK>
    18c2:	a3 c0       	rjmp	.+326    	; 0x1a0a <sofError>

000018c4 <foundK>:
    18c4:	df 93       	push	r29
    18c6:	c0 91 2b 01 	lds	r28, 0x012B
    18ca:	dd 27       	eor	r29, r29
    18cc:	ce 5c       	subi	r28, 0xCE	; 206
    18ce:	de 4f       	sbci	r29, 0xFE	; 254
    18d0:	4c 9b       	sbis	0x09, 4	; 9
    18d2:	02 c0       	rjmp	.+4      	; 0x18d8 <haveTwoBitsK>
    18d4:	df 91       	pop	r29
    18d6:	eb cf       	rjmp	.-42     	; 0x18ae <waitForK>

000018d8 <haveTwoBitsK>:
    18d8:	2f 93       	push	r18
    18da:	0f 93       	push	r16
    18dc:	1f 93       	push	r17
    18de:	09 b1       	in	r16, 0x09	; 9
    18e0:	2f ef       	ldi	r18, 0xFF	; 255
    18e2:	04 fb       	bst	r16, 4
    18e4:	20 f9       	bld	r18, 0
    18e6:	4f 93       	push	r20
    18e8:	3f 93       	push	r19
    18ea:	19 b1       	in	r17, 0x09	; 9
    18ec:	4f ef       	ldi	r20, 0xFF	; 255
    18ee:	01 27       	eor	r16, r17
    18f0:	04 fb       	bst	r16, 4
    18f2:	21 f9       	bld	r18, 1
    18f4:	3b e0       	ldi	r19, 0x0B	; 11
    18f6:	31 c0       	rjmp	.+98     	; 0x195a <rxbit2>

000018f8 <unstuff0>:
    18f8:	4e 7f       	andi	r20, 0xFE	; 254
    18fa:	01 2f       	mov	r16, r17
    18fc:	19 b1       	in	r17, 0x09	; 9
    18fe:	21 60       	ori	r18, 0x01	; 1
    1900:	28 c0       	rjmp	.+80     	; 0x1952 <didUnstuff0>

00001902 <unstuff1>:
    1902:	10 2f       	mov	r17, r16
    1904:	4d 7f       	andi	r20, 0xFD	; 253
    1906:	22 60       	ori	r18, 0x02	; 2
    1908:	00 00       	nop
    190a:	09 b1       	in	r16, 0x09	; 9
    190c:	29 c0       	rjmp	.+82     	; 0x1960 <didUnstuff1>

0000190e <unstuff2>:
    190e:	4b 7f       	andi	r20, 0xFB	; 251
    1910:	24 60       	ori	r18, 0x04	; 4
    1912:	01 2f       	mov	r16, r17
    1914:	00 00       	nop
    1916:	19 b1       	in	r17, 0x09	; 9
    1918:	2b c0       	rjmp	.+86     	; 0x1970 <didUnstuff2>

0000191a <unstuff3>:
    191a:	19 b1       	in	r17, 0x09	; 9
    191c:	47 7f       	andi	r20, 0xF7	; 247
    191e:	28 60       	ori	r18, 0x08	; 8
    1920:	2a c0       	rjmp	.+84     	; 0x1976 <didUnstuff3>

00001922 <unstuff4>:
    1922:	4f 7e       	andi	r20, 0xEF	; 239
    1924:	09 b1       	in	r16, 0x09	; 9
    1926:	20 61       	ori	r18, 0x10	; 16
    1928:	2c c0       	rjmp	.+88     	; 0x1982 <didUnstuff4>

0000192a <unstuff5>:
    192a:	4f 7d       	andi	r20, 0xDF	; 223
    192c:	19 b1       	in	r17, 0x09	; 9
    192e:	20 62       	ori	r18, 0x20	; 32
    1930:	2f c0       	rjmp	.+94     	; 0x1990 <didUnstuff5>

00001932 <unstuff6>:
    1932:	4f 7b       	andi	r20, 0xBF	; 191
    1934:	09 b1       	in	r16, 0x09	; 9
    1936:	20 64       	ori	r18, 0x40	; 64
    1938:	32 c0       	rjmp	.+100    	; 0x199e <didUnstuff6>

0000193a <rxLoop>:
    193a:	42 27       	eor	r20, r18
    193c:	09 b1       	in	r16, 0x09	; 9
    193e:	49 93       	st	Y+, r20
    1940:	4f ef       	ldi	r20, 0xFF	; 255
    1942:	00 00       	nop
    1944:	10 27       	eor	r17, r16
    1946:	14 fb       	bst	r17, 4
    1948:	20 f9       	bld	r18, 0
    194a:	19 b1       	in	r17, 0x09	; 9
    194c:	18 71       	andi	r17, 0x18	; 24
    194e:	c9 f1       	breq	.+114    	; 0x19c2 <se0>
    1950:	29 7f       	andi	r18, 0xF9	; 249

00001952 <didUnstuff0>:
    1952:	91 f2       	breq	.-92     	; 0x18f8 <unstuff0>
    1954:	01 27       	eor	r16, r17
    1956:	04 fb       	bst	r16, 4
    1958:	21 f9       	bld	r18, 1

0000195a <rxbit2>:
    195a:	09 b1       	in	r16, 0x09	; 9
    195c:	23 7f       	andi	r18, 0xF3	; 243
    195e:	89 f2       	breq	.-94     	; 0x1902 <unstuff1>

00001960 <didUnstuff1>:
    1960:	31 50       	subi	r19, 0x01	; 1
    1962:	58 f1       	brcs	.+86     	; 0x19ba <overflow>
    1964:	10 27       	eor	r17, r16
    1966:	14 fb       	bst	r17, 4
    1968:	22 f9       	bld	r18, 2
    196a:	19 b1       	in	r17, 0x09	; 9
    196c:	27 7e       	andi	r18, 0xE7	; 231
    196e:	79 f2       	breq	.-98     	; 0x190e <unstuff2>

00001970 <didUnstuff2>:
    1970:	01 27       	eor	r16, r17
    1972:	04 fb       	bst	r16, 4
    1974:	23 f9       	bld	r18, 3

00001976 <didUnstuff3>:
    1976:	2f 7c       	andi	r18, 0xCF	; 207
    1978:	81 f2       	breq	.-96     	; 0x191a <unstuff3>
    197a:	09 b1       	in	r16, 0x09	; 9
    197c:	10 27       	eor	r17, r16
    197e:	14 fb       	bst	r17, 4
    1980:	24 f9       	bld	r18, 4

00001982 <didUnstuff4>:
    1982:	2f 79       	andi	r18, 0x9F	; 159
    1984:	71 f2       	breq	.-100    	; 0x1922 <unstuff4>
    1986:	00 c0       	rjmp	.+0      	; 0x1988 <didUnstuff4+0x6>
    1988:	19 b1       	in	r17, 0x09	; 9
    198a:	01 27       	eor	r16, r17
    198c:	04 fb       	bst	r16, 4
    198e:	25 f9       	bld	r18, 5

00001990 <didUnstuff5>:
    1990:	2f 73       	andi	r18, 0x3F	; 63
    1992:	59 f2       	breq	.-106    	; 0x192a <unstuff5>
    1994:	00 c0       	rjmp	.+0      	; 0x1996 <didUnstuff5+0x6>
    1996:	09 b1       	in	r16, 0x09	; 9
    1998:	10 27       	eor	r17, r16
    199a:	14 fb       	bst	r17, 4
    199c:	26 f9       	bld	r18, 6

0000199e <didUnstuff6>:
    199e:	22 30       	cpi	r18, 0x02	; 2
    19a0:	40 f2       	brcs	.-112    	; 0x1932 <unstuff6>
    19a2:	00 c0       	rjmp	.+0      	; 0x19a4 <didUnstuff6+0x6>
    19a4:	19 b1       	in	r17, 0x09	; 9
    19a6:	01 27       	eor	r16, r17
    19a8:	04 fb       	bst	r16, 4
    19aa:	27 f9       	bld	r18, 7

000019ac <didUnstuff7>:
    19ac:	24 30       	cpi	r18, 0x04	; 4
    19ae:	28 f6       	brcc	.-118    	; 0x193a <rxLoop>

000019b0 <unstuff7>:
    19b0:	4f 77       	andi	r20, 0x7F	; 127
    19b2:	20 68       	ori	r18, 0x80	; 128
    19b4:	19 b1       	in	r17, 0x09	; 9
    19b6:	00 00       	nop
    19b8:	f9 cf       	rjmp	.-14     	; 0x19ac <didUnstuff7>

000019ba <overflow>:
    19ba:	12 e0       	ldi	r17, 0x02	; 2
    19bc:	1c bb       	out	0x1c, r17	; 28

000019be <ignorePacket>:
    19be:	00 27       	eor	r16, r16
    19c0:	19 c0       	rjmp	.+50     	; 0x19f4 <handleSetupOrOut>

000019c2 <se0>:
    19c2:	3b 50       	subi	r19, 0x0B	; 11
    19c4:	31 95       	neg	r19
    19c6:	c3 1b       	sub	r28, r19
    19c8:	d0 40       	sbci	r29, 0x00	; 0
    19ca:	12 e0       	ldi	r17, 0x02	; 2
    19cc:	1c bb       	out	0x1c, r17	; 28
    19ce:	08 81       	ld	r16, Y
    19d0:	03 3c       	cpi	r16, 0xC3	; 195
    19d2:	f9 f0       	breq	.+62     	; 0x1a12 <handleData>
    19d4:	0b 34       	cpi	r16, 0x4B	; 75
    19d6:	e9 f0       	breq	.+58     	; 0x1a12 <handleData>
    19d8:	20 91 29 01 	lds	r18, 0x0129
    19dc:	19 81       	ldd	r17, Y+1	; 0x01
    19de:	11 0f       	add	r17, r17
    19e0:	12 13       	cpse	r17, r18
    19e2:	ed cf       	rjmp	.-38     	; 0x19be <ignorePacket>
    19e4:	4a 81       	ldd	r20, Y+2	; 0x02
    19e6:	44 1f       	adc	r20, r20
    19e8:	09 36       	cpi	r16, 0x69	; 105
    19ea:	41 f1       	breq	.+80     	; 0x1a3c <handleIn>
    19ec:	0d 32       	cpi	r16, 0x2D	; 45
    19ee:	11 f0       	breq	.+4      	; 0x19f4 <handleSetupOrOut>
    19f0:	01 3e       	cpi	r16, 0xE1	; 225
    19f2:	29 f7       	brne	.-54     	; 0x19be <ignorePacket>

000019f4 <handleSetupOrOut>:
    19f4:	00 93 30 01 	sts	0x0130, r16

000019f8 <doReturn>:
    19f8:	3f 91       	pop	r19
    19fa:	4f 91       	pop	r20
    19fc:	1f 91       	pop	r17
    19fe:	0f 91       	pop	r16
    1a00:	2f 91       	pop	r18
    1a02:	df 91       	pop	r29
    1a04:	cc b3       	in	r28, 0x1c	; 28
    1a06:	c1 fd       	sbrc	r28, 1
    1a08:	4f cf       	rjmp	.-354    	; 0x18a8 <waitForJ>

00001a0a <sofError>:
    1a0a:	cf 91       	pop	r28
    1a0c:	cf bf       	out	0x3f, r28	; 63
    1a0e:	cf 91       	pop	r28
    1a10:	18 95       	reti

00001a12 <handleData>:
    1a12:	20 91 30 01 	lds	r18, 0x0130
    1a16:	22 23       	and	r18, r18
    1a18:	79 f3       	breq	.-34     	; 0x19f8 <doReturn>
    1a1a:	10 91 2e 01 	lds	r17, 0x012E
    1a1e:	11 23       	and	r17, r17
    1a20:	c1 f5       	brne	.+112    	; 0x1a92 <sendNakAndReti>
    1a22:	34 30       	cpi	r19, 0x04	; 4
    1a24:	c2 f1       	brmi	.+112    	; 0x1a96 <sendAckAndReti>
    1a26:	30 93 2e 01 	sts	0x012E, r19
    1a2a:	20 93 2a 01 	sts	0x012A, r18
    1a2e:	10 91 2b 01 	lds	r17, 0x012B
    1a32:	3b e0       	ldi	r19, 0x0B	; 11
    1a34:	31 1b       	sub	r19, r17
    1a36:	30 93 2b 01 	sts	0x012B, r19
    1a3a:	2d c0       	rjmp	.+90     	; 0x1a96 <sendAckAndReti>

00001a3c <handleIn>:
    1a3c:	00 91 2e 01 	lds	r16, 0x012E
    1a40:	01 30       	cpi	r16, 0x01	; 1
    1a42:	3c f5       	brge	.+78     	; 0x1a92 <sendNakAndReti>
    1a44:	0a e5       	ldi	r16, 0x5A	; 90
    1a46:	4f 70       	andi	r20, 0x0F	; 15
    1a48:	49 f4       	brne	.+18     	; 0x1a5c <handleIn1>
    1a4a:	30 91 00 01 	lds	r19, 0x0100
    1a4e:	34 fd       	sbrc	r19, 4
    1a50:	24 c0       	rjmp	.+72     	; 0x1a9a <sendCntAndReti>
    1a52:	00 93 00 01 	sts	0x0100, r16
    1a56:	c2 e1       	ldi	r28, 0x12	; 18
    1a58:	d1 e0       	ldi	r29, 0x01	; 1
    1a5a:	23 c0       	rjmp	.+70     	; 0x1aa2 <usbSendAndReti>

00001a5c <handleIn1>:
    1a5c:	41 35       	cpi	r20, 0x51	; 81
    1a5e:	49 f0       	breq	.+18     	; 0x1a72 <handleIn3>
    1a60:	30 91 1d 01 	lds	r19, 0x011D
    1a64:	34 fd       	sbrc	r19, 4
    1a66:	19 c0       	rjmp	.+50     	; 0x1a9a <sendCntAndReti>
    1a68:	00 93 1d 01 	sts	0x011D, r16
    1a6c:	ce e1       	ldi	r28, 0x1E	; 30
    1a6e:	d1 e0       	ldi	r29, 0x01	; 1
    1a70:	18 c0       	rjmp	.+48     	; 0x1aa2 <usbSendAndReti>

00001a72 <handleIn3>:
    1a72:	30 91 48 01 	lds	r19, 0x0148
    1a76:	34 fd       	sbrc	r19, 4
    1a78:	10 c0       	rjmp	.+32     	; 0x1a9a <sendCntAndReti>
    1a7a:	00 93 48 01 	sts	0x0148, r16
    1a7e:	c9 e4       	ldi	r28, 0x49	; 73
    1a80:	d1 e0       	ldi	r29, 0x01	; 1
    1a82:	0f c0       	rjmp	.+30     	; 0x1aa2 <usbSendAndReti>

00001a84 <stuffN1Delay>:
    1a84:	27 95       	ror	r18
    1a86:	a8 f4       	brcc	.+42     	; 0x1ab2 <doExorN1>
    1a88:	51 50       	subi	r21, 0x01	; 1
    1a8a:	a9 f4       	brne	.+42     	; 0x1ab6 <commonN1>
    1a8c:	22 0f       	add	r18, r18
    1a8e:	00 00       	nop
    1a90:	f9 cf       	rjmp	.-14     	; 0x1a84 <stuffN1Delay>

00001a92 <sendNakAndReti>:
    1a92:	4a e5       	ldi	r20, 0x5A	; 90
    1a94:	03 c0       	rjmp	.+6      	; 0x1a9c <usbSendX3>

00001a96 <sendAckAndReti>:
    1a96:	42 ed       	ldi	r20, 0xD2	; 210
    1a98:	01 c0       	rjmp	.+2      	; 0x1a9c <usbSendX3>

00001a9a <sendCntAndReti>:
    1a9a:	43 2f       	mov	r20, r19

00001a9c <usbSendX3>:
    1a9c:	c4 e1       	ldi	r28, 0x14	; 20
    1a9e:	d0 e0       	ldi	r29, 0x00	; 0
    1aa0:	32 e0       	ldi	r19, 0x02	; 2

00001aa2 <usbSendAndReti>:
    1aa2:	1a b1       	in	r17, 0x0a	; 10
    1aa4:	18 61       	ori	r17, 0x18	; 24
    1aa6:	5c 9a       	sbi	0x0b, 4	; 11
    1aa8:	1a b9       	out	0x0a, r17	; 10
    1aaa:	0b b1       	in	r16, 0x0b	; 11
    1aac:	20 e4       	ldi	r18, 0x40	; 64
    1aae:	18 e1       	ldi	r17, 0x18	; 24
    1ab0:	5f 93       	push	r21

00001ab2 <doExorN1>:
    1ab2:	01 27       	eor	r16, r17
    1ab4:	56 e0       	ldi	r21, 0x06	; 6

00001ab6 <commonN1>:
    1ab6:	0b b9       	out	0x0b, r16	; 11
    1ab8:	27 95       	ror	r18
    1aba:	20 f4       	brcc	.+8      	; 0x1ac4 <doExorN2>
    1abc:	51 50       	subi	r21, 0x01	; 1
    1abe:	21 f4       	brne	.+8      	; 0x1ac8 <commonN2>
    1ac0:	22 0f       	add	r18, r18
    1ac2:	f9 cf       	rjmp	.-14     	; 0x1ab6 <commonN1>

00001ac4 <doExorN2>:
    1ac4:	01 27       	eor	r16, r17
    1ac6:	56 e0       	ldi	r21, 0x06	; 6

00001ac8 <commonN2>:
    1ac8:	00 00       	nop
    1aca:	3b 5a       	subi	r19, 0xAB	; 171
    1acc:	0b b9       	out	0x0b, r16	; 11
    1ace:	d0 f2       	brcs	.-76     	; 0x1a84 <stuffN1Delay>

00001ad0 <stuff6Delay>:
    1ad0:	27 95       	ror	r18
    1ad2:	28 f4       	brcc	.+10     	; 0x1ade <doExor6>
    1ad4:	51 50       	subi	r21, 0x01	; 1
    1ad6:	29 f4       	brne	.+10     	; 0x1ae2 <common6>
    1ad8:	22 0f       	add	r18, r18
    1ada:	00 00       	nop
    1adc:	f9 cf       	rjmp	.-14     	; 0x1ad0 <stuff6Delay>

00001ade <doExor6>:
    1ade:	01 27       	eor	r16, r17
    1ae0:	56 e0       	ldi	r21, 0x06	; 6

00001ae2 <common6>:
    1ae2:	27 95       	ror	r18
    1ae4:	0b b9       	out	0x0b, r16	; 11
    1ae6:	20 f4       	brcc	.+8      	; 0x1af0 <doExor7>
    1ae8:	51 50       	subi	r21, 0x01	; 1
    1aea:	21 f4       	brne	.+8      	; 0x1af4 <common7>
    1aec:	22 0f       	add	r18, r18
    1aee:	f9 cf       	rjmp	.-14     	; 0x1ae2 <common6>

00001af0 <doExor7>:
    1af0:	01 27       	eor	r16, r17
    1af2:	56 e0       	ldi	r21, 0x06	; 6

00001af4 <common7>:
    1af4:	29 91       	ld	r18, Y+
    1af6:	33 23       	and	r19, r19
    1af8:	0b b9       	out	0x0b, r16	; 11
    1afa:	21 f6       	brne	.-120    	; 0x1a84 <stuffN1Delay>
    1afc:	07 7e       	andi	r16, 0xE7	; 231
    1afe:	10 91 2f 01 	lds	r17, 0x012F
    1b02:	11 0f       	add	r17, r17
    1b04:	c6 51       	subi	r28, 0x16	; 22
    1b06:	d0 40       	sbci	r29, 0x00	; 0
    1b08:	0b b9       	out	0x0b, r16	; 11
    1b0a:	11 f0       	breq	.+4      	; 0x1b10 <skipAddrAssign>
    1b0c:	10 93 29 01 	sts	0x0129, r17

00001b10 <skipAddrAssign>:
    1b10:	12 e0       	ldi	r17, 0x02	; 2
    1b12:	1c bb       	out	0x1c, r17	; 28
    1b14:	00 61       	ori	r16, 0x10	; 16
    1b16:	1a b1       	in	r17, 0x0a	; 10
    1b18:	17 7e       	andi	r17, 0xE7	; 231
    1b1a:	40 2f       	mov	r20, r16
    1b1c:	47 7e       	andi	r20, 0xE7	; 231
    1b1e:	5f 91       	pop	r21
    1b20:	00 c0       	rjmp	.+0      	; 0x1b22 <skipAddrAssign+0x12>
    1b22:	00 c0       	rjmp	.+0      	; 0x1b24 <skipAddrAssign+0x14>
    1b24:	0b b9       	out	0x0b, r16	; 11
    1b26:	1a b9       	out	0x0a, r17	; 10
    1b28:	4b b9       	out	0x0b, r20	; 11
    1b2a:	66 cf       	rjmp	.-308    	; 0x19f8 <doReturn>

00001b2c <usbInit>:
/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbInit(void)
{
#if USB_INTR_CFG_SET != 0
    USB_INTR_CFG |= USB_INTR_CFG_SET;
    1b2c:	e9 e6       	ldi	r30, 0x69	; 105
    1b2e:	f0 e0       	ldi	r31, 0x00	; 0
    1b30:	80 81       	ld	r24, Z
    1b32:	8c 60       	ori	r24, 0x0C	; 12
    1b34:	80 83       	st	Z, r24
#endif
#if USB_INTR_CFG_CLR != 0
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
    1b36:	e9 9a       	sbi	0x1d, 1	; 29
/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    1b38:	8b e4       	ldi	r24, 0x4B	; 75
    1b3a:	80 93 1e 01 	sts	0x011E, r24
#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    1b3e:	80 93 49 01 	sts	0x0149, r24
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
    usbResetDataToggling();
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    usbTxLen1 = USBPID_NAK;
    1b42:	8a e5       	ldi	r24, 0x5A	; 90
    1b44:	80 93 1d 01 	sts	0x011D, r24
#if USB_CFG_HAVE_INTRIN_ENDPOINT3
    usbTxLen3 = USBPID_NAK;
    1b48:	80 93 48 01 	sts	0x0148, r24
#endif
#endif
}
    1b4c:	08 95       	ret

00001b4e <usbPoll>:
}

/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbPoll(void)
{
    1b4e:	1f 93       	push	r17
    1b50:	cf 93       	push	r28
    1b52:	df 93       	push	r29
schar   len;
uchar   i;

    len = usbRxLen - 3;
    1b54:	90 91 2e 01 	lds	r25, 0x012E
    1b58:	93 50       	subi	r25, 0x03	; 3
    if(len >= 0){
    1b5a:	97 fd       	sbrc	r25, 7
    1b5c:	a8 c0       	rjmp	.+336    	; 0x1cae <usbPoll+0x160>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
    1b5e:	20 91 2b 01 	lds	r18, 0x012B
    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
        usbFunctionWriteOut(data, len);
        return;
    }
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
    1b62:	80 91 2a 01 	lds	r24, 0x012A
    1b66:	8d 32       	cpi	r24, 0x2D	; 45
    1b68:	09 f0       	breq	.+2      	; 0x1b6c <usbPoll+0x1e>
    1b6a:	9f c0       	rjmp	.+318    	; 0x1caa <usbPoll+0x15c>
        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
    1b6c:	98 30       	cpi	r25, 0x08	; 8
    1b6e:	09 f0       	breq	.+2      	; 0x1b72 <usbPoll+0x24>
    1b70:	9c c0       	rjmp	.+312    	; 0x1caa <usbPoll+0x15c>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
    1b72:	cc e0       	ldi	r28, 0x0C	; 12
    1b74:	d0 e0       	ldi	r29, 0x00	; 0
    1b76:	c2 1b       	sub	r28, r18
    1b78:	d1 09       	sbc	r29, r1
    1b7a:	ce 5c       	subi	r28, 0xCE	; 206
    1b7c:	de 4f       	sbci	r29, 0xFE	; 254
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
            return;
        usbMsgLen_t replyLen;
        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
    1b7e:	83 ec       	ldi	r24, 0xC3	; 195
    1b80:	80 93 12 01 	sts	0x0112, r24
        usbTxLen = USBPID_NAK;              /* abort pending transmit */
    1b84:	8a e5       	ldi	r24, 0x5A	; 90
    1b86:	80 93 00 01 	sts	0x0100, r24
        usbMsgFlags = 0;
    1b8a:	10 92 0a 01 	sts	0x010A, r1
        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
    1b8e:	88 81       	ld	r24, Y
    1b90:	80 76       	andi	r24, 0x60	; 96
    1b92:	29 f0       	breq	.+10     	; 0x1b9e <usbPoll+0x50>
            replyLen = usbFunctionSetup(data);
    1b94:	ce 01       	movw	r24, r28
    1b96:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <usbFunctionSetup>
    1b9a:	28 2f       	mov	r18, r24
    1b9c:	7d c0       	rjmp	.+250    	; 0x1c98 <usbPoll+0x14a>
 * standard requests instead of class and custom requests.
 */
static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
{
uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffer */
uchar   value = rq->wValue.bytes[0];
    1b9e:	9a 81       	ldd	r25, Y+2	; 0x02
#if USB_CFG_IMPLEMENT_HALT
uchar   index = rq->wIndex.bytes[0];
#endif

    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
    1ba0:	10 92 1b 01 	sts	0x011B, r1
    SWITCH_START(rq->bRequest)
    1ba4:	89 81       	ldd	r24, Y+1	; 0x01
    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
    1ba6:	88 23       	and	r24, r24
    1ba8:	21 f4       	brne	.+8      	; 0x1bb2 <usbPoll+0x64>
            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
#if USB_CFG_IMPLEMENT_HALT
        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
            dataPtr[0] = usbTxLen1 == USBPID_STALL;
#endif
        dataPtr[1] = 0;
    1baa:	10 92 1c 01 	sts	0x011C, r1
    1bae:	22 e0       	ldi	r18, 0x02	; 2
    1bb0:	6d c0       	rjmp	.+218    	; 0x1c8c <usbPoll+0x13e>
        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
            usbResetDataToggling();
        }
#endif
    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
    1bb2:	85 30       	cpi	r24, 0x05	; 5
    1bb4:	19 f4       	brne	.+6      	; 0x1bbc <usbPoll+0x6e>
        usbNewDeviceAddr = value;
    1bb6:	90 93 2f 01 	sts	0x012F, r25
    1bba:	67 c0       	rjmp	.+206    	; 0x1c8a <usbPoll+0x13c>
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
    1bbc:	86 30       	cpi	r24, 0x06	; 6
    1bbe:	09 f0       	breq	.+2      	; 0x1bc2 <usbPoll+0x74>
    1bc0:	4e c0       	rjmp	.+156    	; 0x1c5e <usbPoll+0x110>
static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
{
usbMsgLen_t len = 0;
uchar       flags = USB_FLG_MSGPTR_IS_ROM;

    SWITCH_START(rq->wValue.bytes[1])
    1bc2:	8b 81       	ldd	r24, Y+3	; 0x03
    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
    1bc4:	81 30       	cpi	r24, 0x01	; 1
    1bc6:	41 f4       	brne	.+16     	; 0x1bd8 <usbPoll+0x8a>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
    1bc8:	80 ef       	ldi	r24, 0xF0	; 240
    1bca:	90 e0       	ldi	r25, 0x00	; 0
    1bcc:	90 93 2d 01 	sts	0x012D, r25
    1bd0:	80 93 2c 01 	sts	0x012C, r24
    1bd4:	22 e1       	ldi	r18, 0x12	; 18
    1bd6:	3f c0       	rjmp	.+126    	; 0x1c56 <usbPoll+0x108>
    SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
    1bd8:	82 30       	cpi	r24, 0x02	; 2
    1bda:	41 f4       	brne	.+16     	; 0x1bec <usbPoll+0x9e>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
    1bdc:	82 e0       	ldi	r24, 0x02	; 2
    1bde:	91 e0       	ldi	r25, 0x01	; 1
    1be0:	90 93 2d 01 	sts	0x012D, r25
    1be4:	80 93 2c 01 	sts	0x012C, r24
    1be8:	29 e2       	ldi	r18, 0x29	; 41
    1bea:	35 c0       	rjmp	.+106    	; 0x1c56 <usbPoll+0x108>
    SWITCH_CASE(USBDESCR_STRING)    /* 3 */
    1bec:	83 30       	cpi	r24, 0x03	; 3
    1bee:	f1 f4       	brne	.+60     	; 0x1c2c <usbPoll+0xde>
        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
            flags = 0;
        len = usbFunctionDescriptor(rq);
#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
        SWITCH_START(rq->wValue.bytes[0])
        SWITCH_CASE(0)
    1bf0:	99 23       	and	r25, r25
    1bf2:	41 f4       	brne	.+16     	; 0x1c04 <usbPoll+0xb6>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
    1bf4:	8c eb       	ldi	r24, 0xBC	; 188
    1bf6:	90 e0       	ldi	r25, 0x00	; 0
    1bf8:	90 93 2d 01 	sts	0x012D, r25
    1bfc:	80 93 2c 01 	sts	0x012C, r24
    1c00:	24 e0       	ldi	r18, 0x04	; 4
    1c02:	29 c0       	rjmp	.+82     	; 0x1c56 <usbPoll+0x108>
        SWITCH_CASE(1)
    1c04:	91 30       	cpi	r25, 0x01	; 1
    1c06:	41 f4       	brne	.+16     	; 0x1c18 <usbPoll+0xca>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
    1c08:	80 ec       	ldi	r24, 0xC0	; 192
    1c0a:	90 e0       	ldi	r25, 0x00	; 0
    1c0c:	90 93 2d 01 	sts	0x012D, r25
    1c10:	80 93 2c 01 	sts	0x012C, r24
    1c14:	2c e1       	ldi	r18, 0x1C	; 28
    1c16:	1f c0       	rjmp	.+62     	; 0x1c56 <usbPoll+0x108>
        SWITCH_CASE(2)
    1c18:	92 30       	cpi	r25, 0x02	; 2
    1c1a:	e1 f4       	brne	.+56     	; 0x1c54 <usbPoll+0x106>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
    1c1c:	8c ed       	ldi	r24, 0xDC	; 220
    1c1e:	90 e0       	ldi	r25, 0x00	; 0
    1c20:	90 93 2d 01 	sts	0x012D, r25
    1c24:	80 93 2c 01 	sts	0x012C, r24
    1c28:	24 e1       	ldi	r18, 0x14	; 20
    1c2a:	15 c0       	rjmp	.+42     	; 0x1c56 <usbPoll+0x108>
                len = usbFunctionDescriptor(rq);
            }
        SWITCH_END
#endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
#if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
    SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
    1c2c:	81 32       	cpi	r24, 0x21	; 33
    1c2e:	41 f4       	brne	.+16     	; 0x1c40 <usbPoll+0xf2>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
    1c30:	84 e1       	ldi	r24, 0x14	; 20
    1c32:	91 e0       	ldi	r25, 0x01	; 1
    1c34:	90 93 2d 01 	sts	0x012D, r25
    1c38:	80 93 2c 01 	sts	0x012C, r24
    1c3c:	29 e0       	ldi	r18, 0x09	; 9
    1c3e:	0b c0       	rjmp	.+22     	; 0x1c56 <usbPoll+0x108>
    SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
    1c40:	82 32       	cpi	r24, 0x22	; 34
    1c42:	41 f4       	brne	.+16     	; 0x1c54 <usbPoll+0x106>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
    1c44:	88 e6       	ldi	r24, 0x68	; 104
    1c46:	90 e0       	ldi	r25, 0x00	; 0
    1c48:	90 93 2d 01 	sts	0x012D, r25
    1c4c:	80 93 2c 01 	sts	0x012C, r24
    1c50:	24 e5       	ldi	r18, 0x54	; 84
    1c52:	01 c0       	rjmp	.+2      	; 0x1c56 <usbPoll+0x108>
    1c54:	20 e0       	ldi	r18, 0x00	; 0
    SWITCH_DEFAULT
        if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
            len = usbFunctionDescriptor(rq);
        }
    SWITCH_END
    usbMsgFlags = flags;
    1c56:	80 e4       	ldi	r24, 0x40	; 64
    1c58:	80 93 0a 01 	sts	0x010A, r24
    1c5c:	1d c0       	rjmp	.+58     	; 0x1c98 <usbPoll+0x14a>
        usbNewDeviceAddr = value;
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
        len = usbDriverDescriptor(rq);
        goto skipMsgPtrAssignment;
    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
    1c5e:	88 30       	cpi	r24, 0x08	; 8
    1c60:	21 f4       	brne	.+8      	; 0x1c6a <usbPoll+0x11c>
    1c62:	21 e0       	ldi	r18, 0x01	; 1
    1c64:	81 e3       	ldi	r24, 0x31	; 49
    1c66:	91 e0       	ldi	r25, 0x01	; 1
    1c68:	13 c0       	rjmp	.+38     	; 0x1c90 <usbPoll+0x142>
        dataPtr = &usbConfiguration;  /* send current configuration value */
        len = 1;
    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
    1c6a:	89 30       	cpi	r24, 0x09	; 9
    1c6c:	19 f4       	brne	.+6      	; 0x1c74 <usbPoll+0x126>
        usbConfiguration = value;
    1c6e:	90 93 31 01 	sts	0x0131, r25
    1c72:	0b c0       	rjmp	.+22     	; 0x1c8a <usbPoll+0x13c>
        usbResetStall();
    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
    1c74:	8a 30       	cpi	r24, 0x0A	; 10
    1c76:	11 f4       	brne	.+4      	; 0x1c7c <usbPoll+0x12e>
    1c78:	21 e0       	ldi	r18, 0x01	; 1
    1c7a:	08 c0       	rjmp	.+16     	; 0x1c8c <usbPoll+0x13e>
        len = 1;
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
    1c7c:	8b 30       	cpi	r24, 0x0B	; 11
    1c7e:	29 f4       	brne	.+10     	; 0x1c8a <usbPoll+0x13c>
/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    1c80:	8b e4       	ldi	r24, 0x4B	; 75
    1c82:	80 93 1e 01 	sts	0x011E, r24
#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    1c86:	80 93 49 01 	sts	0x0149, r24
    1c8a:	20 e0       	ldi	r18, 0x00	; 0
    1c8c:	8b e1       	ldi	r24, 0x1B	; 27
    1c8e:	91 e0       	ldi	r25, 0x01	; 1
        usbResetStall();
#endif
    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
        /* Should we add an optional hook here? */
    SWITCH_END
    usbMsgPtr = dataPtr;
    1c90:	90 93 2d 01 	sts	0x012D, r25
    1c94:	80 93 2c 01 	sts	0x012C, r24
            }
            usbMsgFlags = USB_FLG_USE_USER_RW;
        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */
#endif
        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */
    1c98:	8f 81       	ldd	r24, Y+7	; 0x07
    1c9a:	88 23       	and	r24, r24
    1c9c:	21 f4       	brne	.+8      	; 0x1ca6 <usbPoll+0x158>
    1c9e:	8e 81       	ldd	r24, Y+6	; 0x06
    1ca0:	82 17       	cp	r24, r18
    1ca2:	08 f4       	brcc	.+2      	; 0x1ca6 <usbPoll+0x158>
    1ca4:	28 2f       	mov	r18, r24
                replyLen = rq->wLength.bytes[0];
        }else{
            if(replyLen > rq->wLength.word)     /* limit length to max */
                replyLen = rq->wLength.word;
        }
        usbMsgLen = replyLen;
    1ca6:	20 93 01 01 	sts	0x0101, r18
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
#if USB_CFG_HAVE_FLOWCONTROL
        if(usbRxLen > 0)    /* only mark as available if not inactivated */
            usbRxLen = 0;
#else
        usbRxLen = 0;       /* mark rx buffer as available */
    1caa:	10 92 2e 01 	sts	0x012E, r1
#endif
    }
    if(usbTxLen & 0x10){    /* transmit system idle */
    1cae:	80 91 00 01 	lds	r24, 0x0100
    1cb2:	84 ff       	sbrs	r24, 4
    1cb4:	4a c0       	rjmp	.+148    	; 0x1d4a <usbPoll+0x1fc>
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
    1cb6:	80 91 01 01 	lds	r24, 0x0101
    1cba:	8f 3f       	cpi	r24, 0xFF	; 255
    1cbc:	09 f4       	brne	.+2      	; 0x1cc0 <usbPoll+0x172>
    1cbe:	45 c0       	rjmp	.+138    	; 0x1d4a <usbPoll+0x1fc>
    1cc0:	18 2f       	mov	r17, r24
    1cc2:	89 30       	cpi	r24, 0x09	; 9
    1cc4:	08 f0       	brcs	.+2      	; 0x1cc8 <usbPoll+0x17a>
    1cc6:	18 e0       	ldi	r17, 0x08	; 8
uchar       len;

    wantLen = usbMsgLen;
    if(wantLen > 8)
        wantLen = 8;
    usbMsgLen -= wantLen;
    1cc8:	81 1b       	sub	r24, r17
    1cca:	80 93 01 01 	sts	0x0101, r24
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    1cce:	80 91 12 01 	lds	r24, 0x0112
    1cd2:	98 e8       	ldi	r25, 0x88	; 136
    1cd4:	89 27       	eor	r24, r25
    1cd6:	80 93 12 01 	sts	0x0112, r24
/* This function is similar to usbFunctionRead(), but it's also called for
 * data handled automatically by the driver (e.g. descriptor reads).
 */
static uchar usbDeviceRead(uchar *data, uchar len)
{
    if(len > 0){    /* don't bother app with 0 sized reads */
    1cda:	11 23       	and	r17, r17
    1cdc:	41 f1       	breq	.+80     	; 0x1d2e <usbPoll+0x1e0>
        if(usbMsgFlags & USB_FLG_USE_USER_RW){
            len = usbFunctionRead(data, len);
        }else
#endif
        {
            uchar i = len, *r = usbMsgPtr;
    1cde:	20 91 2c 01 	lds	r18, 0x012C
    1ce2:	30 91 2d 01 	lds	r19, 0x012D
            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
    1ce6:	80 91 0a 01 	lds	r24, 0x010A
    1cea:	86 ff       	sbrs	r24, 6
    1cec:	0d c0       	rjmp	.+26     	; 0x1d08 <usbPoll+0x1ba>
    1cee:	a3 e1       	ldi	r26, 0x13	; 19
    1cf0:	b1 e0       	ldi	r27, 0x01	; 1
    1cf2:	80 e0       	ldi	r24, 0x00	; 0
    1cf4:	90 e0       	ldi	r25, 0x00	; 0
                do{
                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */
    1cf6:	f9 01       	movw	r30, r18
    1cf8:	e8 0f       	add	r30, r24
    1cfa:	f9 1f       	adc	r31, r25
    1cfc:	e4 91       	lpm	r30, Z+
                    *data++ = c;
    1cfe:	ed 93       	st	X+, r30
    1d00:	01 96       	adiw	r24, 0x01	; 1
                    r++;
                }while(--i);
    1d02:	18 17       	cp	r17, r24
    1d04:	c1 f7       	brne	.-16     	; 0x1cf6 <usbPoll+0x1a8>
    1d06:	08 c0       	rjmp	.+16     	; 0x1d18 <usbPoll+0x1ca>
    1d08:	91 2f       	mov	r25, r17
    1d0a:	d9 01       	movw	r26, r18
    1d0c:	e3 e1       	ldi	r30, 0x13	; 19
    1d0e:	f1 e0       	ldi	r31, 0x01	; 1
            }else{  /* RAM data */
                do{
                    *data++ = *r++;
    1d10:	8d 91       	ld	r24, X+
    1d12:	81 93       	st	Z+, r24
                }while(--i);
    1d14:	91 50       	subi	r25, 0x01	; 1
    1d16:	e1 f7       	brne	.-8      	; 0x1d10 <usbPoll+0x1c2>
    1d18:	11 50       	subi	r17, 0x01	; 1
    1d1a:	81 2f       	mov	r24, r17
    1d1c:	90 e0       	ldi	r25, 0x00	; 0
    1d1e:	1f 5f       	subi	r17, 0xFF	; 255
    1d20:	01 96       	adiw	r24, 0x01	; 1
    1d22:	82 0f       	add	r24, r18
    1d24:	93 1f       	adc	r25, r19
            }
            usbMsgPtr = r;
    1d26:	90 93 2d 01 	sts	0x012D, r25
    1d2a:	80 93 2c 01 	sts	0x012C, r24
        wantLen = 8;
    usbMsgLen -= wantLen;
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    len = usbDeviceRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
        usbCrc16Append(&usbTxBuf[1], len);
    1d2e:	83 e1       	ldi	r24, 0x13	; 19
    1d30:	91 e0       	ldi	r25, 0x01	; 1
    1d32:	61 2f       	mov	r22, r17
    1d34:	0e 94 4d 0c 	call	0x189a	; 0x189a <usbCrc16Append>
        len += 4;           /* length including sync byte */
    1d38:	61 2f       	mov	r22, r17
    1d3a:	6c 5f       	subi	r22, 0xFC	; 252
        if(len < 12)        /* a partial package identifies end of message */
    1d3c:	6c 30       	cpi	r22, 0x0C	; 12
    1d3e:	19 f0       	breq	.+6      	; 0x1d46 <usbPoll+0x1f8>
            usbMsgLen = USB_NO_MSG;
    1d40:	8f ef       	ldi	r24, 0xFF	; 255
    1d42:	80 93 01 01 	sts	0x0101, r24
    }else{
        len = USBPID_STALL;   /* stall the endpoint */
        usbMsgLen = USB_NO_MSG;
    }
    usbTxLen = len;
    1d46:	60 93 00 01 	sts	0x0100, r22
    1d4a:	94 e1       	ldi	r25, 0x14	; 20
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 20; i > 0; i--){
        uchar usbLineStatus = USBIN & USBMASK;
    1d4c:	89 b1       	in	r24, 0x09	; 9
        if(usbLineStatus != 0)  /* SE0 has ended */
    1d4e:	88 71       	andi	r24, 0x18	; 24
    1d50:	31 f4       	brne	.+12     	; 0x1d5e <usbPoll+0x210>
    if(usbTxLen & 0x10){    /* transmit system idle */
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 20; i > 0; i--){
    1d52:	91 50       	subi	r25, 0x01	; 1
    1d54:	d9 f7       	brne	.-10     	; 0x1d4c <usbPoll+0x1fe>
        uchar usbLineStatus = USBIN & USBMASK;
        if(usbLineStatus != 0)  /* SE0 has ended */
            goto isNotReset;
    }
    /* RESET condition, called multiple times during reset */
    usbNewDeviceAddr = 0;
    1d56:	10 92 2f 01 	sts	0x012F, r1
    usbDeviceAddr = 0;
    1d5a:	10 92 29 01 	sts	0x0129, r1
    usbResetStall();
    DBG1(0xff, 0, 0);
isNotReset:
    usbHandleResetHook(i);
}
    1d5e:	df 91       	pop	r29
    1d60:	cf 91       	pop	r28
    1d62:	1f 91       	pop	r17
    1d64:	08 95       	ret

00001d66 <usbSetInterrupt3>:
}
#endif

#if USB_CFG_HAVE_INTRIN_ENDPOINT3
USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
{
    1d66:	1f 93       	push	r17
    1d68:	dc 01       	movw	r26, r24
    1d6a:	16 2f       	mov	r17, r22

#if USB_CFG_IMPLEMENT_HALT
    if(usbTxLen1 == USBPID_STALL)
        return;
#endif
    if(txStatus->len & 0x10){   /* packet buffer was empty */
    1d6c:	80 91 48 01 	lds	r24, 0x0148
    1d70:	84 ff       	sbrs	r24, 4
    1d72:	07 c0       	rjmp	.+14     	; 0x1d82 <usbSetInterrupt3+0x1c>
        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
    1d74:	80 91 49 01 	lds	r24, 0x0149
    1d78:	98 e8       	ldi	r25, 0x88	; 136
    1d7a:	89 27       	eor	r24, r25
    1d7c:	80 93 49 01 	sts	0x0149, r24
    1d80:	03 c0       	rjmp	.+6      	; 0x1d88 <usbSetInterrupt3+0x22>
    }else{
        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
    1d82:	8a e5       	ldi	r24, 0x5A	; 90
    1d84:	80 93 48 01 	sts	0x0148, r24
    1d88:	91 2f       	mov	r25, r17
    1d8a:	ea e4       	ldi	r30, 0x4A	; 74
    1d8c:	f1 e0       	ldi	r31, 0x01	; 1
    }
    p = txStatus->buffer + 1;
    i = len;
    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
        *p++ = *data++;
    1d8e:	8d 91       	ld	r24, X+
    1d90:	81 93       	st	Z+, r24
    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
    1d92:	91 50       	subi	r25, 0x01	; 1
    1d94:	e1 f7       	brne	.-8      	; 0x1d8e <usbSetInterrupt3+0x28>
    usbCrc16Append(&txStatus->buffer[1], len);
    1d96:	8a e4       	ldi	r24, 0x4A	; 74
    1d98:	91 e0       	ldi	r25, 0x01	; 1
    1d9a:	61 2f       	mov	r22, r17
    1d9c:	0e 94 4d 0c 	call	0x189a	; 0x189a <usbCrc16Append>
    txStatus->len = len + 4;    /* len must be given including sync byte */
    1da0:	1c 5f       	subi	r17, 0xFC	; 252
    1da2:	10 93 48 01 	sts	0x0148, r17

#if USB_CFG_HAVE_INTRIN_ENDPOINT3
USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
{
    usbGenericSetInterrupt(data, len, &usbTxStatus3);
}
    1da6:	1f 91       	pop	r17
    1da8:	08 95       	ret

00001daa <usbSetInterrupt>:
    txStatus->len = len + 4;    /* len must be given including sync byte */
    DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
}

USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
{
    1daa:	1f 93       	push	r17
    1dac:	dc 01       	movw	r26, r24
    1dae:	16 2f       	mov	r17, r22

#if USB_CFG_IMPLEMENT_HALT
    if(usbTxLen1 == USBPID_STALL)
        return;
#endif
    if(txStatus->len & 0x10){   /* packet buffer was empty */
    1db0:	80 91 1d 01 	lds	r24, 0x011D
    1db4:	84 ff       	sbrs	r24, 4
    1db6:	07 c0       	rjmp	.+14     	; 0x1dc6 <usbSetInterrupt+0x1c>
        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
    1db8:	80 91 1e 01 	lds	r24, 0x011E
    1dbc:	98 e8       	ldi	r25, 0x88	; 136
    1dbe:	89 27       	eor	r24, r25
    1dc0:	80 93 1e 01 	sts	0x011E, r24
    1dc4:	03 c0       	rjmp	.+6      	; 0x1dcc <usbSetInterrupt+0x22>
    }else{
        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
    1dc6:	8a e5       	ldi	r24, 0x5A	; 90
    1dc8:	80 93 1d 01 	sts	0x011D, r24
    1dcc:	91 2f       	mov	r25, r17
    1dce:	ef e1       	ldi	r30, 0x1F	; 31
    1dd0:	f1 e0       	ldi	r31, 0x01	; 1
    }
    p = txStatus->buffer + 1;
    i = len;
    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
        *p++ = *data++;
    1dd2:	8d 91       	ld	r24, X+
    1dd4:	81 93       	st	Z+, r24
    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
    1dd6:	91 50       	subi	r25, 0x01	; 1
    1dd8:	e1 f7       	brne	.-8      	; 0x1dd2 <usbSetInterrupt+0x28>
    usbCrc16Append(&txStatus->buffer[1], len);
    1dda:	8f e1       	ldi	r24, 0x1F	; 31
    1ddc:	91 e0       	ldi	r25, 0x01	; 1
    1dde:	61 2f       	mov	r22, r17
    1de0:	0e 94 4d 0c 	call	0x189a	; 0x189a <usbCrc16Append>
    txStatus->len = len + 4;    /* len must be given including sync byte */
    1de4:	1c 5f       	subi	r17, 0xFC	; 252
    1de6:	10 93 1d 01 	sts	0x011D, r17
}

USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
{
    usbGenericSetInterrupt(data, len, &usbTxStatus1);
}
    1dea:	1f 91       	pop	r17
    1dec:	08 95       	ret

00001dee <__eerd_block>:
    1dee:	a0 e0       	ldi	r26, 0x00	; 0
    1df0:	b0 e0       	ldi	r27, 0x00	; 0
    1df2:	ed ef       	ldi	r30, 0xFD	; 253
    1df4:	fe e0       	ldi	r31, 0x0E	; 14
    1df6:	0c 94 39 0f 	jmp	0x1e72	; 0x1e72 <__prologue_saves__+0x14>
    1dfa:	7c 01       	movw	r14, r24
    1dfc:	eb 01       	movw	r28, r22
    1dfe:	8a 01       	movw	r16, r20
    1e00:	69 01       	movw	r12, r18
    1e02:	09 c0       	rjmp	.+18     	; 0x1e16 <__eerd_block+0x28>
    1e04:	ce 01       	movw	r24, r28
    1e06:	21 96       	adiw	r28, 0x01	; 1
    1e08:	f6 01       	movw	r30, r12
    1e0a:	09 95       	icall
    1e0c:	f7 01       	movw	r30, r14
    1e0e:	81 93       	st	Z+, r24
    1e10:	7f 01       	movw	r14, r30
    1e12:	01 50       	subi	r16, 0x01	; 1
    1e14:	10 40       	sbci	r17, 0x00	; 0
    1e16:	01 15       	cp	r16, r1
    1e18:	11 05       	cpc	r17, r1
    1e1a:	a1 f7       	brne	.-24     	; 0x1e04 <__eerd_block+0x16>
    1e1c:	cd b7       	in	r28, 0x3d	; 61
    1e1e:	de b7       	in	r29, 0x3e	; 62
    1e20:	e8 e0       	ldi	r30, 0x08	; 8
    1e22:	0c 94 55 0f 	jmp	0x1eaa	; 0x1eaa <__epilogue_restores__+0x14>

00001e26 <__eewr_block>:
    1e26:	a0 e0       	ldi	r26, 0x00	; 0
    1e28:	b0 e0       	ldi	r27, 0x00	; 0
    1e2a:	e9 e1       	ldi	r30, 0x19	; 25
    1e2c:	ff e0       	ldi	r31, 0x0F	; 15
    1e2e:	0c 94 39 0f 	jmp	0x1e72	; 0x1e72 <__prologue_saves__+0x14>
    1e32:	ec 01       	movw	r28, r24
    1e34:	7b 01       	movw	r14, r22
    1e36:	8a 01       	movw	r16, r20
    1e38:	69 01       	movw	r12, r18
    1e3a:	09 c0       	rjmp	.+18     	; 0x1e4e <__eewr_block+0x28>
    1e3c:	ce 01       	movw	r24, r28
    1e3e:	21 96       	adiw	r28, 0x01	; 1
    1e40:	f7 01       	movw	r30, r14
    1e42:	61 91       	ld	r22, Z+
    1e44:	7f 01       	movw	r14, r30
    1e46:	f6 01       	movw	r30, r12
    1e48:	09 95       	icall
    1e4a:	01 50       	subi	r16, 0x01	; 1
    1e4c:	10 40       	sbci	r17, 0x00	; 0
    1e4e:	01 15       	cp	r16, r1
    1e50:	11 05       	cpc	r17, r1
    1e52:	a1 f7       	brne	.-24     	; 0x1e3c <__eewr_block+0x16>
    1e54:	cd b7       	in	r28, 0x3d	; 61
    1e56:	de b7       	in	r29, 0x3e	; 62
    1e58:	e8 e0       	ldi	r30, 0x08	; 8
    1e5a:	0c 94 55 0f 	jmp	0x1eaa	; 0x1eaa <__epilogue_restores__+0x14>

00001e5e <__prologue_saves__>:
    1e5e:	2f 92       	push	r2
    1e60:	3f 92       	push	r3
    1e62:	4f 92       	push	r4
    1e64:	5f 92       	push	r5
    1e66:	6f 92       	push	r6
    1e68:	7f 92       	push	r7
    1e6a:	8f 92       	push	r8
    1e6c:	9f 92       	push	r9
    1e6e:	af 92       	push	r10
    1e70:	bf 92       	push	r11
    1e72:	cf 92       	push	r12
    1e74:	df 92       	push	r13
    1e76:	ef 92       	push	r14
    1e78:	ff 92       	push	r15
    1e7a:	0f 93       	push	r16
    1e7c:	1f 93       	push	r17
    1e7e:	cf 93       	push	r28
    1e80:	df 93       	push	r29
    1e82:	cd b7       	in	r28, 0x3d	; 61
    1e84:	de b7       	in	r29, 0x3e	; 62
    1e86:	ca 1b       	sub	r28, r26
    1e88:	db 0b       	sbc	r29, r27
    1e8a:	0f b6       	in	r0, 0x3f	; 63
    1e8c:	f8 94       	cli
    1e8e:	de bf       	out	0x3e, r29	; 62
    1e90:	0f be       	out	0x3f, r0	; 63
    1e92:	cd bf       	out	0x3d, r28	; 61
    1e94:	09 94       	ijmp

00001e96 <__epilogue_restores__>:
    1e96:	2a 88       	ldd	r2, Y+18	; 0x12
    1e98:	39 88       	ldd	r3, Y+17	; 0x11
    1e9a:	48 88       	ldd	r4, Y+16	; 0x10
    1e9c:	5f 84       	ldd	r5, Y+15	; 0x0f
    1e9e:	6e 84       	ldd	r6, Y+14	; 0x0e
    1ea0:	7d 84       	ldd	r7, Y+13	; 0x0d
    1ea2:	8c 84       	ldd	r8, Y+12	; 0x0c
    1ea4:	9b 84       	ldd	r9, Y+11	; 0x0b
    1ea6:	aa 84       	ldd	r10, Y+10	; 0x0a
    1ea8:	b9 84       	ldd	r11, Y+9	; 0x09
    1eaa:	c8 84       	ldd	r12, Y+8	; 0x08
    1eac:	df 80       	ldd	r13, Y+7	; 0x07
    1eae:	ee 80       	ldd	r14, Y+6	; 0x06
    1eb0:	fd 80       	ldd	r15, Y+5	; 0x05
    1eb2:	0c 81       	ldd	r16, Y+4	; 0x04
    1eb4:	1b 81       	ldd	r17, Y+3	; 0x03
    1eb6:	aa 81       	ldd	r26, Y+2	; 0x02
    1eb8:	b9 81       	ldd	r27, Y+1	; 0x01
    1eba:	ce 0f       	add	r28, r30
    1ebc:	d1 1d       	adc	r29, r1
    1ebe:	0f b6       	in	r0, 0x3f	; 63
    1ec0:	f8 94       	cli
    1ec2:	de bf       	out	0x3e, r29	; 62
    1ec4:	0f be       	out	0x3f, r0	; 63
    1ec6:	cd bf       	out	0x3d, r28	; 61
    1ec8:	ed 01       	movw	r28, r26
    1eca:	08 95       	ret

00001ecc <_exit>:
    1ecc:	f8 94       	cli

00001ece <__stop_program>:
    1ece:	ff cf       	rjmp	.-2      	; 0x1ece <__stop_program>
