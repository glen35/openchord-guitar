
V1MIDI.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800100  00000c10  00000cc4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000c10  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000038  0080010e  0080010e  00000cd2  2**0
                  ALLOC
  3 .eeprom       00000168  00810000  00810000  00000cd2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000080  00000000  00000000  00000e3a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000002ae  00000000  00000000  00000eba  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000011fc  00000000  00000000  00001168  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000066c  00000000  00000000  00002364  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b99  00000000  00000000  000029d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000140  00000000  00000000  0000356c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000683  00000000  00000000  000036ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000058d  00000000  00000000  00003d2f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000e0  00000000  00000000  000042bc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 8e 00 	jmp	0x11c	; 0x11c <__ctors_end>
   4:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
   8:	0c 94 c9 04 	jmp	0x992	; 0x992 <__vector_2>
   c:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  10:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  14:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  18:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  1c:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  20:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  24:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  28:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  2c:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  30:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  34:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  38:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  3c:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  40:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  44:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  48:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  4c:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  50:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  54:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  58:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  5c:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  60:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
  64:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>

00000068 <deviceDescrMIDI>:
  68:	12 01 10 01 00 00 00 08 c0 16 e4 05 01 00 01 02     ................
  78:	00 01                                               ..

0000007a <configDescrMIDI>:
  7a:	09 02 65 00 02 01 00 80 32 09 04 00 00 00 01 01     ..e.....2.......
  8a:	00 00 09 24 01 00 01 09 00 01 01 09 04 01 00 02     ...$............
  9a:	01 03 00 00 07 24 01 00 01 41 00 06 24 02 01 01     .....$...A..$...
  aa:	00 06 24 02 02 02 00 09 24 03 01 03 01 02 01 00     ..$.....$.......
  ba:	09 24 03 02 04 01 01 01 00 09 05 01 03 08 00 02     .$..............
  ca:	00 00 05 25 01 01 01 09 05 81 03 08 00 02 00 00     ...%............
  da:	05 25 01 01 03                                      .%...

000000df <usbDescriptorString0>:
  df:	04 03 09 04                                         ....

000000e3 <usbDescriptorStringVendor>:
  e3:	22 03 77 00 77 00 77 00 2e 00 63 00 72 00 79 00     ".w.w.w...c.r.y.
  f3:	70 00 74 00 6f 00 6d 00 79 00 73 00 2e 00 64 00     p.t.o.m.y.s...d.
 103:	65 00                                               e.

00000105 <usbDescriptorStringDevice>:
 105:	16 03 56 00 2d 00 55 00 53 00 42 00 2d 00 4d 00     ..V.-.U.S.B.-.M.
 115:	49 00 44 00 49 00 00                                I.D.I..

0000011c <__ctors_end>:
 11c:	11 24       	eor	r1, r1
 11e:	1f be       	out	0x3f, r1	; 63
 120:	cf ef       	ldi	r28, 0xFF	; 255
 122:	d4 e0       	ldi	r29, 0x04	; 4
 124:	de bf       	out	0x3e, r29	; 62
 126:	cd bf       	out	0x3d, r28	; 61

00000128 <__do_copy_data>:
 128:	11 e0       	ldi	r17, 0x01	; 1
 12a:	a0 e0       	ldi	r26, 0x00	; 0
 12c:	b1 e0       	ldi	r27, 0x01	; 1
 12e:	e0 e1       	ldi	r30, 0x10	; 16
 130:	fc e0       	ldi	r31, 0x0C	; 12
 132:	02 c0       	rjmp	.+4      	; 0x138 <.do_copy_data_start>

00000134 <.do_copy_data_loop>:
 134:	05 90       	lpm	r0, Z+
 136:	0d 92       	st	X+, r0

00000138 <.do_copy_data_start>:
 138:	ae 30       	cpi	r26, 0x0E	; 14
 13a:	b1 07       	cpc	r27, r17
 13c:	d9 f7       	brne	.-10     	; 0x134 <.do_copy_data_loop>

0000013e <__do_clear_bss>:
 13e:	11 e0       	ldi	r17, 0x01	; 1
 140:	ae e0       	ldi	r26, 0x0E	; 14
 142:	b1 e0       	ldi	r27, 0x01	; 1
 144:	01 c0       	rjmp	.+2      	; 0x148 <.do_clear_bss_start>

00000146 <.do_clear_bss_loop>:
 146:	1d 92       	st	X+, r1

00000148 <.do_clear_bss_start>:
 148:	a6 34       	cpi	r26, 0x46	; 70
 14a:	b1 07       	cpc	r27, r17
 14c:	e1 f7       	brne	.-8      	; 0x146 <.do_clear_bss_loop>
 14e:	0e 94 6f 01 	call	0x2de	; 0x2de <main>
 152:	0c 94 06 06 	jmp	0xc0c	; 0xc0c <_exit>

00000156 <__bad_interrupt>:
 156:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000015a <setPins>:
#include "guitarInitFunctions.h"

void setPins(void)
{
	// Set the fret pins as input pins, with internal resistor
	fret_ddr &= ~(1<<green_pin);        // input
 15a:	21 98       	cbi	0x04, 1	; 4
	fret_port |= (1<<green_pin);		//pull-up enabled	
 15c:	29 9a       	sbi	0x05, 1	; 5
	fret_ddr &= ~(1<<red_pin);
 15e:	22 98       	cbi	0x04, 2	; 4
	fret_port |= (1<<red_pin);
 160:	2a 9a       	sbi	0x05, 2	; 5
	fret_ddr &= ~(1<<yellow_pin);
 162:	23 98       	cbi	0x04, 3	; 4
	fret_port |= (1<<yellow_pin);
 164:	2b 9a       	sbi	0x05, 3	; 5
	fret_ddr &= ~(1<<blue_pin);
 166:	24 98       	cbi	0x04, 4	; 4
	fret_port |= (1<<blue_pin);
 168:	2c 9a       	sbi	0x05, 4	; 5
	fret_ddr &= ~(1<<orange_pin);
 16a:	25 98       	cbi	0x04, 5	; 4
	fret_port |= (1<<orange_pin);
 16c:	2d 9a       	sbi	0x05, 5	; 5

	// Set the pins on strumming and plus as inputs, with internal resistor
	misc_ddr &= ~(1<<plus_pin);
 16e:	38 98       	cbi	0x07, 0	; 7
	misc_port |= (1<<plus_pin);
 170:	40 9a       	sbi	0x08, 0	; 8
	misc_ddr &= ~(1<<minus_pin);
 172:	39 98       	cbi	0x07, 1	; 7
	misc_port |= (1<<minus_pin);
 174:	41 9a       	sbi	0x08, 1	; 8

	pick_ddr &= ~(1<<strum_pin);
 176:	3a 98       	cbi	0x07, 2	; 7
	pick_port |= (1<<strum_pin);
 178:	42 9a       	sbi	0x08, 2	; 8

	// Set the string pins as output pins, outputting HIGH
	/* MAKE SURE YOU HAVE DIODES OPPOSING THIS CURRENT OUTFLOW! */
	string_1_ddr |= (1<<first_string);  //output
 17a:	57 9a       	sbi	0x0a, 7	; 10
	string_1_port |= (1<<first_string); // set high
 17c:	5f 9a       	sbi	0x0b, 7	; 11
	string_2_ddr |= (1<<second_string);  
 17e:	56 9a       	sbi	0x0a, 6	; 10
	string_2_port |= (1<<second_string);
 180:	5e 9a       	sbi	0x0b, 6	; 11
	string_3_ddr |= (1<<third_string);  
 182:	55 9a       	sbi	0x0a, 5	; 10
	string_3_port |= (1<<third_string);
 184:	5d 9a       	sbi	0x0b, 5	; 11
	string_4_ddr |= (1<<fourth_string);  
 186:	52 9a       	sbi	0x0a, 2	; 10
	string_4_port |= (1<<fourth_string);
 188:	5a 9a       	sbi	0x0b, 2	; 11
	string_5_ddr |= (1<<fifth_string);  
 18a:	20 9a       	sbi	0x04, 0	; 4
	string_5_port |= (1<<fifth_string);
 18c:	28 9a       	sbi	0x05, 0	; 5
	string_6_ddr |= (1<<sixth_string);  
 18e:	3b 9a       	sbi	0x07, 3	; 7
	string_6_port |= (1<<sixth_string);
 190:	43 9a       	sbi	0x08, 3	; 8
}
 192:	08 95       	ret

00000194 <setTimer>:

void setTimer(void) //This sets up a timer to handle the green button thing
{
	PRR &= ~(1<<PRTIM1);	// ensure power to Timer/Counter1
 194:	e4 e6       	ldi	r30, 0x64	; 100
 196:	f0 e0       	ldi	r31, 0x00	; 0
 198:	80 81       	ld	r24, Z
 19a:	87 7f       	andi	r24, 0xF7	; 247
 19c:	80 83       	st	Z, r24

	TCCR1A &= ~(1<<COM1A1);  // This prevents OC2A pin from doing anything
 19e:	e0 e8       	ldi	r30, 0x80	; 128
 1a0:	f0 e0       	ldi	r31, 0x00	; 0
 1a2:	80 81       	ld	r24, Z
 1a4:	8f 77       	andi	r24, 0x7F	; 127
 1a6:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<COM1A0);  //  to the pins on the chip. Otherwise, we might
 1a8:	80 81       	ld	r24, Z
 1aa:	8f 7b       	andi	r24, 0xBF	; 191
 1ac:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<COM1B1);  //  get signals coming out of some of the pins we might use
 1ae:	80 81       	ld	r24, Z
 1b0:	8f 7d       	andi	r24, 0xDF	; 223
 1b2:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<COM1B0);
 1b4:	80 81       	ld	r24, Z
 1b6:	8f 7e       	andi	r24, 0xEF	; 239
 1b8:	80 83       	st	Z, r24

	TCCR1A &= ~(1<<WGM11);  // These bits set up normal mode on the Waveform Generation
 1ba:	80 81       	ld	r24, Z
 1bc:	8d 7f       	andi	r24, 0xFD	; 253
 1be:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<WGM10);  // This means that the counter acts like a normal timer,
 1c0:	80 81       	ld	r24, Z
 1c2:	8e 7f       	andi	r24, 0xFE	; 254
 1c4:	80 83       	st	Z, r24
	TCCR1B &= ~(1<<WGM12);  // not some sort of fancy digital-analog converter or anything
 1c6:	e1 e8       	ldi	r30, 0x81	; 129
 1c8:	f0 e0       	ldi	r31, 0x00	; 0
 1ca:	80 81       	ld	r24, Z
 1cc:	87 7f       	andi	r24, 0xF7	; 247
 1ce:	80 83       	st	Z, r24
	TCCR1B &= ~(1<<WGM13);  // It counts up to 65536 and overflows to zero
 1d0:	80 81       	ld	r24, Z
 1d2:	8f 7e       	andi	r24, 0xEF	; 239
 1d4:	80 83       	st	Z, r24

	TCCR1B |= (1<<CS12);   // These set the clock to CPU (8MHz) / 1024 
 1d6:	80 81       	ld	r24, Z
 1d8:	84 60       	ori	r24, 0x04	; 4
 1da:	80 83       	st	Z, r24
	TCCR1B &= ~(1<<CS11);  // or roughly 8 kHz (7.8125 kHz)
 1dc:	80 81       	ld	r24, Z
 1de:	8d 7f       	andi	r24, 0xFD	; 253
 1e0:	80 83       	st	Z, r24
	TCCR1B |= (1<<CS10);   // When counting from zero to 0xFFFF, it takes about 8 seconds
 1e2:	80 81       	ld	r24, Z
 1e4:	81 60       	ori	r24, 0x01	; 1
 1e6:	80 83       	st	Z, r24

	// The counter's value is stored in TCNT1
}
 1e8:	08 95       	ret

000001ea <readFrets>:


//readF reads the frets for a single string, and returns an int acting as a boolean array
//  telling which frets are being touched by the string.
int readFrets(int guitarString, volatile uint8_t *port)
{
 1ea:	ff 92       	push	r15
 1ec:	0f 93       	push	r16
 1ee:	1f 93       	push	r17
 1f0:	cf 93       	push	r28
 1f2:	df 93       	push	r29
 1f4:	fb 01       	movw	r30, r22
  	*port &= ~(1<<guitarString);  // Set the string LOW
 1f6:	90 81       	ld	r25, Z
 1f8:	21 e0       	ldi	r18, 0x01	; 1
 1fa:	30 e0       	ldi	r19, 0x00	; 0
 1fc:	02 c0       	rjmp	.+4      	; 0x202 <readFrets+0x18>
 1fe:	22 0f       	add	r18, r18
 200:	33 1f       	adc	r19, r19
 202:	8a 95       	dec	r24
 204:	e2 f7       	brpl	.-8      	; 0x1fe <readFrets+0x14>
 206:	f2 2e       	mov	r15, r18
 208:	82 2f       	mov	r24, r18
 20a:	80 95       	com	r24
 20c:	89 23       	and	r24, r25
 20e:	80 83       	st	Z, r24
 210:	84 e1       	ldi	r24, 0x14	; 20
 212:	90 e0       	ldi	r25, 0x00	; 0
	// Macro to as many NOPs as we want
	inline void doXnops(int x)
	{
		while (x >= 0)
		{
			nop();
 214:	00 00       	nop
			x--;
 216:	01 97       	sbiw	r24, 0x01	; 1
	#define nop() asm volatile("nop")

	// Macro to as many NOPs as we want
	inline void doXnops(int x)
	{
		while (x >= 0)
 218:	2f ef       	ldi	r18, 0xFF	; 255
 21a:	8f 3f       	cpi	r24, 0xFF	; 255
 21c:	92 07       	cpc	r25, r18
 21e:	d1 f7       	brne	.-12     	; 0x214 <readFrets+0x2a>

	// Then we have to delay for a while, since right after the switch, the pin values
	// jump around a bit
	doXnops(20);	
	// Read the values on the frets
  	int i = fret_pin;               
 220:	83 b1       	in	r24, 0x03	; 3
	i = fret_pin;
 222:	83 b1       	in	r24, 0x03	; 3
	i = fret_pin;		// More delay funcitonality... without these delays, there is some bouncing
 224:	83 b1       	in	r24, 0x03	; 3
	i = fret_pin;		// on the pins, so the read screws up.
 226:	83 b1       	in	r24, 0x03	; 3
	// Next, since the fret pin is zero if the a fret is grounded, we do a mask to isolate each pin from 
	//  the port, which will return a zero if pressed and non-zero if unpressed. So we ! that to get a 1 if
	//  the string touches that fret and a zero if it doesn't touch, which we then load into our storage 
	//  integer.

 	stringState |= ( (!(i & (1<<green_pin))) << 1); //green fret
 228:	81 fd       	sbrc	r24, 1
 22a:	03 c0       	rjmp	.+6      	; 0x232 <readFrets+0x48>
 22c:	02 e0       	ldi	r16, 0x02	; 2
 22e:	10 e0       	ldi	r17, 0x00	; 0
 230:	02 c0       	rjmp	.+4      	; 0x236 <readFrets+0x4c>
 232:	00 e0       	ldi	r16, 0x00	; 0
 234:	10 e0       	ldi	r17, 0x00	; 0
 	stringState |= ( (!(i & (1<<red_pin))) << 2); //red fret
 236:	82 fd       	sbrc	r24, 2
 238:	03 c0       	rjmp	.+6      	; 0x240 <readFrets+0x56>
 23a:	c4 e0       	ldi	r28, 0x04	; 4
 23c:	d0 e0       	ldi	r29, 0x00	; 0
 23e:	02 c0       	rjmp	.+4      	; 0x244 <readFrets+0x5a>
 240:	c0 e0       	ldi	r28, 0x00	; 0
 242:	d0 e0       	ldi	r29, 0x00	; 0
 	stringState |= ( (!(i & (1<<yellow_pin))) << 3); //yellow fret
 244:	83 fd       	sbrc	r24, 3
 246:	03 c0       	rjmp	.+6      	; 0x24e <readFrets+0x64>
 248:	a8 e0       	ldi	r26, 0x08	; 8
 24a:	b0 e0       	ldi	r27, 0x00	; 0
 24c:	02 c0       	rjmp	.+4      	; 0x252 <readFrets+0x68>
 24e:	a0 e0       	ldi	r26, 0x00	; 0
 250:	b0 e0       	ldi	r27, 0x00	; 0
 	stringState |= ( (!(i & (1<<blue_pin))) << 4); //blue fret
 252:	84 fd       	sbrc	r24, 4
 254:	03 c0       	rjmp	.+6      	; 0x25c <readFrets+0x72>
 256:	60 e1       	ldi	r22, 0x10	; 16
 258:	70 e0       	ldi	r23, 0x00	; 0
 25a:	02 c0       	rjmp	.+4      	; 0x260 <readFrets+0x76>
 25c:	60 e0       	ldi	r22, 0x00	; 0
 25e:	70 e0       	ldi	r23, 0x00	; 0
 	stringState |= ( (!(i & (1<<orange_pin))) << 5); //orange fret
 260:	85 fd       	sbrc	r24, 5
 262:	03 c0       	rjmp	.+6      	; 0x26a <readFrets+0x80>
 264:	40 e2       	ldi	r20, 0x20	; 32
 266:	50 e0       	ldi	r21, 0x00	; 0
 268:	02 c0       	rjmp	.+4      	; 0x26e <readFrets+0x84>
 26a:	40 e0       	ldi	r20, 0x00	; 0
 26c:	50 e0       	ldi	r21, 0x00	; 0

	// Also, if we strummed a string, hold that in the 'zeroth' fret
	i = pick_pin;
 26e:	26 b1       	in	r18, 0x06	; 6
	//  the port, which will return a zero if pressed and non-zero if unpressed. So we ! that to get a 1 if
	//  the string touches that fret and a zero if it doesn't touch, which we then load into our storage 
	//  integer.

 	stringState |= ( (!(i & (1<<green_pin))) << 1); //green fret
 	stringState |= ( (!(i & (1<<red_pin))) << 2); //red fret
 270:	30 e0       	ldi	r19, 0x00	; 0
 272:	36 95       	lsr	r19
 274:	27 95       	ror	r18
 276:	36 95       	lsr	r19
 278:	27 95       	ror	r18
 27a:	20 95       	com	r18
 27c:	30 95       	com	r19
 27e:	21 70       	andi	r18, 0x01	; 1
 280:	30 70       	andi	r19, 0x00	; 0
 282:	20 2b       	or	r18, r16
 284:	31 2b       	or	r19, r17
 	stringState |= ( (!(i & (1<<yellow_pin))) << 3); //yellow fret
 286:	2c 2b       	or	r18, r28
 288:	3d 2b       	or	r19, r29
 	stringState |= ( (!(i & (1<<blue_pin))) << 4); //blue fret
 28a:	2a 2b       	or	r18, r26
 28c:	3b 2b       	or	r19, r27
 	stringState |= ( (!(i & (1<<orange_pin))) << 5); //orange fret
 28e:	26 2b       	or	r18, r22
 290:	37 2b       	or	r19, r23
	// Also, if we strummed a string, hold that in the 'zeroth' fret
	i = pick_pin;
 	stringState |= ( (!(i & (1<<strum_pin))) << 0); //pick touching the string

	//Turn the string back HIGH and return
	*port |= (1<<guitarString); 
 292:	80 81       	ld	r24, Z
 294:	8f 29       	or	r24, r15
 296:	80 83       	st	Z, r24
 298:	24 2b       	or	r18, r20
 29a:	35 2b       	or	r19, r21
	return stringState;
}
 29c:	c9 01       	movw	r24, r18
 29e:	df 91       	pop	r29
 2a0:	cf 91       	pop	r28
 2a2:	1f 91       	pop	r17
 2a4:	0f 91       	pop	r16
 2a6:	ff 90       	pop	r15
 2a8:	08 95       	ret

000002aa <figureOutNote>:
{
	stringState &= ~0b0001; // This clears out the strum data that we don't care about.
	
	// Now, we check each fret in the order from 5 to 1.  They're chromatic, so we just add 1
	// for each number
	if (stringState & 0b100000)
 2aa:	85 ff       	sbrs	r24, 5
 2ac:	03 c0       	rjmp	.+6      	; 0x2b4 <figureOutNote+0xa>
		return emptyStringNote + 5;
 2ae:	6b 5f       	subi	r22, 0xFB	; 251
 2b0:	7f 4f       	sbci	r23, 0xFF	; 255
 2b2:	13 c0       	rjmp	.+38     	; 0x2da <figureOutNote+0x30>

	if (stringState & 0b010000)
 2b4:	84 ff       	sbrs	r24, 4
 2b6:	03 c0       	rjmp	.+6      	; 0x2be <figureOutNote+0x14>
		return emptyStringNote + 4;
 2b8:	6c 5f       	subi	r22, 0xFC	; 252
 2ba:	7f 4f       	sbci	r23, 0xFF	; 255
 2bc:	0e c0       	rjmp	.+28     	; 0x2da <figureOutNote+0x30>

	if (stringState & 0b001000)
 2be:	83 ff       	sbrs	r24, 3
 2c0:	03 c0       	rjmp	.+6      	; 0x2c8 <figureOutNote+0x1e>
		return emptyStringNote + 3;
 2c2:	6d 5f       	subi	r22, 0xFD	; 253
 2c4:	7f 4f       	sbci	r23, 0xFF	; 255
 2c6:	09 c0       	rjmp	.+18     	; 0x2da <figureOutNote+0x30>

	if (stringState & 0b000100)
 2c8:	82 ff       	sbrs	r24, 2
 2ca:	03 c0       	rjmp	.+6      	; 0x2d2 <figureOutNote+0x28>
		return emptyStringNote + 2;
 2cc:	6e 5f       	subi	r22, 0xFE	; 254
 2ce:	7f 4f       	sbci	r23, 0xFF	; 255
 2d0:	04 c0       	rjmp	.+8      	; 0x2da <figureOutNote+0x30>

	if (stringState & 0b000010)
 2d2:	81 ff       	sbrs	r24, 1
 2d4:	02 c0       	rjmp	.+4      	; 0x2da <figureOutNote+0x30>
		return emptyStringNote + 1;
 2d6:	6f 5f       	subi	r22, 0xFF	; 255
 2d8:	7f 4f       	sbci	r23, 0xFF	; 255

	// If we're not pressing anything, just return the note value of the open string	
	return emptyStringNote;
}
 2da:	cb 01       	movw	r24, r22
 2dc:	08 95       	ret

000002de <main>:
	 -Under config mode, the loop reads in the values of the strings and frets, assigns that current
	  string-fret combination to correspond to a button press, then locks that combination in when 
	  'Plus' is pressed and moves on to changing the next button.  It also sets the button data structure
	  to display the current controller button being programmed, and then sends that data to the controller.
*/ 
{	
 2de:	2f 92       	push	r2
 2e0:	3f 92       	push	r3
 2e2:	4f 92       	push	r4
 2e4:	5f 92       	push	r5
 2e6:	6f 92       	push	r6
 2e8:	7f 92       	push	r7
 2ea:	8f 92       	push	r8
 2ec:	9f 92       	push	r9
 2ee:	af 92       	push	r10
 2f0:	bf 92       	push	r11
 2f2:	cf 92       	push	r12
 2f4:	df 92       	push	r13
 2f6:	ef 92       	push	r14
 2f8:	ff 92       	push	r15
 2fa:	0f 93       	push	r16
 2fc:	1f 93       	push	r17
 2fe:	df 93       	push	r29
 300:	cf 93       	push	r28
 302:	cd b7       	in	r28, 0x3d	; 61
 304:	de b7       	in	r29, 0x3e	; 62
 306:	c5 55       	subi	r28, 0x55	; 85
 308:	d0 40       	sbci	r29, 0x00	; 0
 30a:	0f b6       	in	r0, 0x3f	; 63
 30c:	f8 94       	cli
 30e:	de bf       	out	0x3e, r29	; 62
 310:	0f be       	out	0x3f, r0	; 63
 312:	cd bf       	out	0x3d, r28	; 61
	// First, set up the guitar stuff - These functions are stored in guitarInitFunctions.h/.c
	setPins();
 314:	0e 94 ad 00 	call	0x15a	; 0x15a <setPins>
	setTimer();	
 318:	0e 94 ca 00 	call	0x194	; 0x194 <setTimer>
 	
	// Now set up all the communication stuff - initialization routines
 	//  set specially in the interface functions - see ps3interface.h, wiiinterface.h, etc.
 	startMIDICommunication();
 31c:	0e 94 24 03 	call	0x648	; 0x648 <startMIDICommunication>
	
	dataForController data;
	clearData(&data); //This function is contained in configAndConstants.h

	//emptyFretNotes are the MIDI notes that the guitar's open strings are tuned to.
	int openStringNotes[NUMBER_OF_STRINGS] = {52, 57, 62, 67, 71, 76};
 320:	de 01       	movw	r26, r28
 322:	95 96       	adiw	r26, 0x25	; 37
 324:	e0 e0       	ldi	r30, 0x00	; 0
 326:	f1 e0       	ldi	r31, 0x01	; 1
 328:	8c e0       	ldi	r24, 0x0C	; 12
 32a:	01 90       	ld	r0, Z+
 32c:	0d 92       	st	X+, r0
 32e:	81 50       	subi	r24, 0x01	; 1
 330:	e1 f7       	brne	.-8      	; 0x32a <main+0x4c>
 332:	fe 01       	movw	r30, r28
 334:	ff 96       	adiw	r30, 0x3f	; 63

	noteInfo currentNotes[NUMBER_OF_STRINGS];

	int noteFlags[NUMBER_OF_STRINGS] = {0,0,0,0,0,0};

	for (int i = 0; i <= NUMBER_OF_STRINGS; i++)
 336:	ce 01       	movw	r24, r28
 338:	85 5a       	subi	r24, 0xA5	; 165
 33a:	9f 4f       	sbci	r25, 0xFF	; 255
		int16_t countdown;
	} noteInfo;

	inline void stopNote(noteInfo* note)
	{
		note->countdown = 0;
 33c:	11 82       	std	Z+1, r1	; 0x01
 33e:	10 82       	st	Z, r1
 340:	34 96       	adiw	r30, 0x04	; 4
 342:	e8 17       	cp	r30, r24
 344:	f9 07       	cpc	r31, r25
 346:	d1 f7       	brne	.-12     	; 0x33c <main+0x5e>
 	//  set specially in the interface functions - see ps3interface.h, wiiinterface.h, etc.
 	startMIDICommunication();
	//startPS3Communication();
    
	// Declaration of variables used in Main()
	int stringState[NUMBER_OF_STRINGS] = {0,0,0,0,0,0}; // This stores an int for each string,
 348:	8c e0       	ldi	r24, 0x0C	; 12
 34a:	9e 01       	movw	r18, r28
 34c:	2f 5f       	subi	r18, 0xFF	; 255
 34e:	3f 4f       	sbci	r19, 0xFF	; 255
 350:	d9 01       	movw	r26, r18
 352:	e8 2f       	mov	r30, r24
 354:	1d 92       	st	X+, r1
 356:	ea 95       	dec	r30
 358:	e9 f7       	brne	.-6      	; 0x354 <main+0x76>
										// with the 0th bit being if a string is being strummed
    int tempStringState[NUMBER_OF_STRINGS]; // Temporary place to record how the strings are
                                            // being pressed, for debouncing purposes


    int stringStateTimers[NUMBER_OF_STRINGS] = {0,0,0,0,0,0};
 35a:	de 01       	movw	r26, r28
 35c:	59 96       	adiw	r26, 0x19	; 25
 35e:	fd 01       	movw	r30, r26
 360:	98 2f       	mov	r25, r24
 362:	11 92       	st	Z+, r1
 364:	9a 95       	dec	r25
 366:	e9 f7       	brne	.-6      	; 0x362 <main+0x84>
	//emptyFretNotes are the MIDI notes that the guitar's open strings are tuned to.
	int openStringNotes[NUMBER_OF_STRINGS] = {52, 57, 62, 67, 71, 76};

	noteInfo currentNotes[NUMBER_OF_STRINGS];

	int noteFlags[NUMBER_OF_STRINGS] = {0,0,0,0,0,0};
 368:	ae 01       	movw	r20, r28
 36a:	4f 5c       	subi	r20, 0xCF	; 207
 36c:	5f 4f       	sbci	r21, 0xFF	; 255
 36e:	fa 01       	movw	r30, r20
 370:	11 92       	st	Z+, r1
 372:	8a 95       	dec	r24
 374:	e9 f7       	brne	.-6      	; 0x370 <main+0x92>
        tempStringState[0] = readFrets(first_string, &string_1_port);
		tempStringState[1] = readFrets(second_string, &string_2_port);
		tempStringState[2] = readFrets(third_string, &string_3_port);
		tempStringState[3] = readFrets(fourth_string, &string_4_port);
		tempStringState[4] = readFrets(fifth_string, &string_5_port);
		tempStringState[5] = readFrets(sixth_string, &string_6_port);
 376:	1d 01       	movw	r2, r26

// This function just reads our plus and minus buttons and sets the data struct accordingly
inline void readOtherButtons(dataForController* data)
{
	// read our plus and minus buttons
	int i = misc_pin; // check for plus and minus
 378:	fa 01       	movw	r30, r20
 37a:	66 96       	adiw	r28, 0x16	; 22
 37c:	4f af       	std	Y+63, r20	; 0x3f
 37e:	66 97       	sbiw	r28, 0x16	; 22
 380:	6f 2e       	mov	r6, r31
			if (stringNote.countdown > 0)
			{
				stringNote.countdown--;
				if (stringNote.countdown == 0)
					stringNote.velocity = 0;
				noteFlags[string] = 1; //set the changed note flag
 382:	31 e0       	ldi	r19, 0x01	; 1
 384:	43 2e       	mov	r4, r19
 386:	51 2c       	mov	r5, r1
 					 /* main event loop */
    while(1)
	{   
		// We first read all the strings for button hits and store them into
		//  our stringState array.  Strum processing is also handled here for now.
        tempStringState[0] = readFrets(first_string, &string_1_port);
 388:	87 e0       	ldi	r24, 0x07	; 7
 38a:	90 e0       	ldi	r25, 0x00	; 0
 38c:	6b e2       	ldi	r22, 0x2B	; 43
 38e:	70 e0       	ldi	r23, 0x00	; 0
 390:	0e 94 f5 00 	call	0x1ea	; 0x1ea <readFrets>
 394:	9e 87       	std	Y+14, r25	; 0x0e
 396:	8d 87       	std	Y+13, r24	; 0x0d
		tempStringState[1] = readFrets(second_string, &string_2_port);
 398:	86 e0       	ldi	r24, 0x06	; 6
 39a:	90 e0       	ldi	r25, 0x00	; 0
 39c:	6b e2       	ldi	r22, 0x2B	; 43
 39e:	70 e0       	ldi	r23, 0x00	; 0
 3a0:	0e 94 f5 00 	call	0x1ea	; 0x1ea <readFrets>
 3a4:	98 8b       	std	Y+16, r25	; 0x10
 3a6:	8f 87       	std	Y+15, r24	; 0x0f
		tempStringState[2] = readFrets(third_string, &string_3_port);
 3a8:	85 e0       	ldi	r24, 0x05	; 5
 3aa:	90 e0       	ldi	r25, 0x00	; 0
 3ac:	6b e2       	ldi	r22, 0x2B	; 43
 3ae:	70 e0       	ldi	r23, 0x00	; 0
 3b0:	0e 94 f5 00 	call	0x1ea	; 0x1ea <readFrets>
 3b4:	9a 8b       	std	Y+18, r25	; 0x12
 3b6:	89 8b       	std	Y+17, r24	; 0x11
		tempStringState[3] = readFrets(fourth_string, &string_4_port);
 3b8:	82 e0       	ldi	r24, 0x02	; 2
 3ba:	90 e0       	ldi	r25, 0x00	; 0
 3bc:	6b e2       	ldi	r22, 0x2B	; 43
 3be:	70 e0       	ldi	r23, 0x00	; 0
 3c0:	0e 94 f5 00 	call	0x1ea	; 0x1ea <readFrets>
 3c4:	9c 8b       	std	Y+20, r25	; 0x14
 3c6:	8b 8b       	std	Y+19, r24	; 0x13
		tempStringState[4] = readFrets(fifth_string, &string_5_port);
 3c8:	80 e0       	ldi	r24, 0x00	; 0
 3ca:	90 e0       	ldi	r25, 0x00	; 0
 3cc:	65 e2       	ldi	r22, 0x25	; 37
 3ce:	70 e0       	ldi	r23, 0x00	; 0
 3d0:	0e 94 f5 00 	call	0x1ea	; 0x1ea <readFrets>
 3d4:	9e 8b       	std	Y+22, r25	; 0x16
 3d6:	8d 8b       	std	Y+21, r24	; 0x15
		tempStringState[5] = readFrets(sixth_string, &string_6_port);
 3d8:	83 e0       	ldi	r24, 0x03	; 3
 3da:	90 e0       	ldi	r25, 0x00	; 0
 3dc:	68 e2       	ldi	r22, 0x28	; 40
 3de:	70 e0       	ldi	r23, 0x00	; 0
 3e0:	0e 94 f5 00 	call	0x1ea	; 0x1ea <readFrets>
 3e4:	98 8f       	std	Y+24, r25	; 0x18
 3e6:	8f 8b       	std	Y+23, r24	; 0x17
 3e8:	9e 01       	movw	r18, r28
 3ea:	23 5f       	subi	r18, 0xF3	; 243
 3ec:	3f 4f       	sbci	r19, 0xFF	; 255
 3ee:	be 01       	movw	r22, r28
 3f0:	6f 5f       	subi	r22, 0xFF	; 255
 3f2:	7f 4f       	sbci	r23, 0xFF	; 255
 3f4:	f1 01       	movw	r30, r2

        // Debounce the strings by making sure what is being fretted
        // remains for a certain number of cycles through the main loop
        for (int i = 0; i < NUMBER_OF_STRINGS; i++)
        {
            if (tempStringState[i] == stringState[i])
 3f6:	d9 01       	movw	r26, r18
 3f8:	4d 91       	ld	r20, X+
 3fa:	5c 91       	ld	r21, X
 3fc:	db 01       	movw	r26, r22
 3fe:	8d 91       	ld	r24, X+
 400:	9c 91       	ld	r25, X
 402:	48 17       	cp	r20, r24
 404:	59 07       	cpc	r21, r25
 406:	19 f4       	brne	.+6      	; 0x40e <main+0x130>
                stringStateTimers[i] = 0;
 408:	11 82       	std	Z+1, r1	; 0x01
 40a:	10 82       	st	Z, r1
 40c:	05 c0       	rjmp	.+10     	; 0x418 <main+0x13a>
            else
                stringStateTimers[i] += 1;
 40e:	80 81       	ld	r24, Z
 410:	91 81       	ldd	r25, Z+1	; 0x01
 412:	01 96       	adiw	r24, 0x01	; 1
 414:	91 83       	std	Z+1, r25	; 0x01
 416:	80 83       	st	Z, r24
            // If we've seen enough cycles of a new string state, update stringState 
            if (stringStateTimers[i] >= STRING_DEBOUNCE_DELAY)
 418:	80 81       	ld	r24, Z
 41a:	91 81       	ldd	r25, Z+1	; 0x01
 41c:	0a 97       	sbiw	r24, 0x0a	; 10
 41e:	2c f0       	brlt	.+10     	; 0x42a <main+0x14c>
            {
                stringState[i] = tempStringState[i];
 420:	db 01       	movw	r26, r22
 422:	4d 93       	st	X+, r20
 424:	5c 93       	st	X, r21
                stringStateTimers[i] = 0;
 426:	11 82       	std	Z+1, r1	; 0x01
 428:	10 82       	st	Z, r1
 42a:	2e 5f       	subi	r18, 0xFE	; 254
 42c:	3f 4f       	sbci	r19, 0xFF	; 255
 42e:	6e 5f       	subi	r22, 0xFE	; 254
 430:	7f 4f       	sbci	r23, 0xFF	; 255
 432:	32 96       	adiw	r30, 0x02	; 2
		tempStringState[4] = readFrets(fifth_string, &string_5_port);
		tempStringState[5] = readFrets(sixth_string, &string_6_port);

        // Debounce the strings by making sure what is being fretted
        // remains for a certain number of cycles through the main loop
        for (int i = 0; i < NUMBER_OF_STRINGS; i++)
 434:	22 15       	cp	r18, r2
 436:	33 05       	cpc	r19, r3
 438:	f1 f6       	brne	.-68     	; 0x3f6 <main+0x118>

// This function just reads our plus and minus buttons and sets the data struct accordingly
inline void readOtherButtons(dataForController* data)
{
	// read our plus and minus buttons
	int i = misc_pin; // check for plus and minus
 43a:	86 b1       	in	r24, 0x06	; 6
 43c:	66 96       	adiw	r28, 0x16	; 22
 43e:	8f ad       	ldd	r24, Y+63	; 0x3f
 440:	66 97       	sbiw	r28, 0x16	; 22
 442:	96 2d       	mov	r25, r6
 444:	6c 01       	movw	r12, r24
 446:	2d e3       	ldi	r18, 0x3D	; 61
 448:	e2 2e       	mov	r14, r18
 44a:	f1 2c       	mov	r15, r1
 44c:	ec 0e       	add	r14, r28
 44e:	fd 1e       	adc	r15, r29
 450:	aa 24       	eor	r10, r10
 452:	bb 24       	eor	r11, r11
		//  of notes we want to be playing, or not playing.

		for (int string = 0; string < NUMBER_OF_STRINGS; string++) // Each string can only be playing one note
		{
			//Clear the note flag
			noteFlags[string] = 0;
 454:	f6 01       	movw	r30, r12
 456:	11 82       	std	Z+1, r1	; 0x01
 458:	10 82       	st	Z, r1

			noteInfo stringNote = currentNotes[string];
 45a:	d7 01       	movw	r26, r14
 45c:	12 96       	adiw	r26, 0x02	; 2
 45e:	0d 91       	ld	r16, X+
 460:	1c 91       	ld	r17, X
 462:	13 97       	sbiw	r26, 0x03	; 3
 464:	11 96       	adiw	r26, 0x01	; 1
 466:	9c 90       	ld	r9, X
 468:	11 97       	sbiw	r26, 0x01	; 1
 46a:	8c 90       	ld	r8, X
			// First, we decrement the countdown of all notes, so each note lasts only so long
			// and turn off the note if the countdown is over
			if (stringNote.countdown > 0)
 46c:	10 16       	cp	r1, r16
 46e:	11 06       	cpc	r1, r17
 470:	3c f4       	brge	.+14     	; 0x480 <main+0x1a2>
			{
				stringNote.countdown--;
 472:	01 50       	subi	r16, 0x01	; 1
 474:	10 40       	sbci	r17, 0x00	; 0
				if (stringNote.countdown == 0)
 476:	09 f4       	brne	.+2      	; 0x47a <main+0x19c>
 478:	99 24       	eor	r9, r9
					stringNote.velocity = 0;
				noteFlags[string] = 1; //set the changed note flag
 47a:	f6 01       	movw	r30, r12
 47c:	51 82       	std	Z+1, r5	; 0x01
 47e:	40 82       	st	Z, r4
			}

			// Next, we cancel any note that isn't being fretted anymore
			if (stringNote.note != figureOutNote(stringState[string], openStringNotes[string]) )
 480:	e1 e0       	ldi	r30, 0x01	; 1
 482:	f0 e0       	ldi	r31, 0x00	; 0
 484:	ec 0f       	add	r30, r28
 486:	fd 1f       	adc	r31, r29
 488:	ea 0d       	add	r30, r10
 48a:	fb 1d       	adc	r31, r11
 48c:	70 80       	ld	r7, Z
 48e:	91 81       	ldd	r25, Z+1	; 0x01
 490:	e5 e2       	ldi	r30, 0x25	; 37
 492:	f0 e0       	ldi	r31, 0x00	; 0
 494:	ec 0f       	add	r30, r28
 496:	fd 1f       	adc	r31, r29
 498:	ea 0d       	add	r30, r10
 49a:	fb 1d       	adc	r31, r11
 49c:	60 81       	ld	r22, Z
 49e:	71 81       	ldd	r23, Z+1	; 0x01
 4a0:	87 2d       	mov	r24, r7
 4a2:	0e 94 55 01 	call	0x2aa	; 0x2aa <figureOutNote>
 4a6:	9c 01       	movw	r18, r24
 4a8:	88 2d       	mov	r24, r8
 4aa:	90 e0       	ldi	r25, 0x00	; 0
 4ac:	82 17       	cp	r24, r18
 4ae:	93 07       	cpc	r25, r19
 4b0:	39 f0       	breq	.+14     	; 0x4c0 <main+0x1e2>
			{
				stringNote.note = figureOutNote(stringState[string], openStringNotes[string]);
 4b2:	82 2e       	mov	r8, r18
				stringNote.velocity = 0;
				stringNote.countdown = 0;
				noteFlags[string] = 1; //set the changed note flag
 4b4:	d6 01       	movw	r26, r12
 4b6:	4d 92       	st	X+, r4
 4b8:	5c 92       	st	X, r5
 4ba:	99 24       	eor	r9, r9
 4bc:	00 e0       	ldi	r16, 0x00	; 0
 4be:	10 e0       	ldi	r17, 0x00	; 0
			}

			// Now, we trigger a note if it is strummed
			if (stringState[string] & 0b0001)  // This means that it's being strummed
 4c0:	70 fe       	sbrs	r7, 0
 4c2:	08 c0       	rjmp	.+16     	; 0x4d4 <main+0x1f6>
			{
				stringNote.note = figureOutNote(stringState[string], openStringNotes[string]);
 4c4:	82 2e       	mov	r8, r18
				stringNote.velocity = 0x45;
				stringNote.countdown = NOTE_COUNTDOWN;
				noteFlags[string] = 1; //set the changed note flag
 4c6:	f6 01       	movw	r30, r12
 4c8:	51 82       	std	Z+1, r5	; 0x01
 4ca:	40 82       	st	Z, r4
 4cc:	95 e4       	ldi	r25, 0x45	; 69
 4ce:	99 2e       	mov	r9, r25
 4d0:	00 ed       	ldi	r16, 0xD0	; 208
 4d2:	17 e0       	ldi	r17, 0x07	; 7
			}

			// Make sure that we write our current note back into the array
			currentNotes[string] = stringNote;
 4d4:	d7 01       	movw	r26, r14
 4d6:	8c 92       	st	X, r8
 4d8:	11 96       	adiw	r26, 0x01	; 1
 4da:	9c 92       	st	X, r9
 4dc:	11 97       	sbiw	r26, 0x01	; 1
 4de:	13 96       	adiw	r26, 0x03	; 3
 4e0:	1c 93       	st	X, r17
 4e2:	0e 93       	st	-X, r16
 4e4:	12 97       	sbiw	r26, 0x02	; 2
 4e6:	e2 e0       	ldi	r30, 0x02	; 2
 4e8:	f0 e0       	ldi	r31, 0x00	; 0
 4ea:	ce 0e       	add	r12, r30
 4ec:	df 1e       	adc	r13, r31
 4ee:	ae 0e       	add	r10, r30
 4f0:	bf 1e       	adc	r11, r31
 4f2:	84 e0       	ldi	r24, 0x04	; 4
 4f4:	90 e0       	ldi	r25, 0x00	; 0
 4f6:	e8 0e       	add	r14, r24
 4f8:	f9 1e       	adc	r15, r25
		readOtherButtons(&data);

		// Next, using our strumState array, we process that data to figure out what sort
		//  of notes we want to be playing, or not playing.

		for (int string = 0; string < NUMBER_OF_STRINGS; string++) // Each string can only be playing one note
 4fa:	9c e0       	ldi	r25, 0x0C	; 12
 4fc:	a9 16       	cp	r10, r25
 4fe:	b1 04       	cpc	r11, r1
 500:	09 f0       	breq	.+2      	; 0x504 <__stack+0x5>
 502:	a8 cf       	rjmp	.-176    	; 0x454 <main+0x176>

		// Now we send the note data to the computer

		for (int string = 0; string < 1; string++ )//NUMBER_OF_STRINGS; string++) // Each string can only be playing one note
		{
			if (noteFlags[string] == 1)
 504:	89 a9       	ldd	r24, Y+49	; 0x31
 506:	9a a9       	ldd	r25, Y+50	; 0x32
 508:	01 97       	sbiw	r24, 0x01	; 1
 50a:	39 f4       	brne	.+14     	; 0x51a <__stack+0x1b>
				test(currentNotes[string].note, currentNotes[string].velocity);//sendMIDINote(currentNotes[string].note, currentNotes[string].velocity, MIDI_CHANNEL);
 50c:	6e ad       	ldd	r22, Y+62	; 0x3e
 50e:	8d ad       	ldd	r24, Y+61	; 0x3d
 510:	90 e0       	ldi	r25, 0x00	; 0
 512:	70 e0       	ldi	r23, 0x00	; 0
 514:	0e 94 ce 02 	call	0x59c	; 0x59c <test>
 518:	01 c0       	rjmp	.+2      	; 0x51c <__stack+0x1d>
			else // keep the USB connection alive
				wdt_reset();
 51a:	a8 95       	wdr
				usbPoll();
 51c:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <usbPoll>
 520:	33 cf       	rjmp	.-410    	; 0x388 <main+0xaa>

00000522 <usbFunctionDescriptor>:


uchar usbFunctionDescriptor(usbRequest_t * rq)
{

	if (rq->wValue.bytes[1] == USBDESCR_DEVICE) {
 522:	fc 01       	movw	r30, r24
 524:	83 81       	ldd	r24, Z+3	; 0x03
 526:	81 30       	cpi	r24, 0x01	; 1
 528:	41 f4       	brne	.+16     	; 0x53a <usbFunctionDescriptor+0x18>
		usbMsgPtr = (uchar *) deviceDescrMIDI;
 52a:	88 e6       	ldi	r24, 0x68	; 104
 52c:	90 e0       	ldi	r25, 0x00	; 0
 52e:	90 93 2b 01 	sts	0x012B, r25
 532:	80 93 2a 01 	sts	0x012A, r24
 536:	82 e1       	ldi	r24, 0x12	; 18
 538:	08 95       	ret
		return sizeof(deviceDescrMIDI);
	} else {		/* must be config descriptor */
		usbMsgPtr = (uchar *) configDescrMIDI;
 53a:	8a e7       	ldi	r24, 0x7A	; 122
 53c:	90 e0       	ldi	r25, 0x00	; 0
 53e:	90 93 2b 01 	sts	0x012B, r25
 542:	80 93 2a 01 	sts	0x012A, r24
 546:	85 e6       	ldi	r24, 0x65	; 101
		return sizeof(configDescrMIDI);
	}
}
 548:	08 95       	ret

0000054a <usbFunctionSetup>:
/* ------------------------------------------------------------------------- */
/* ----------------------------- USB interface ----------------------------- */
/* ------------------------------------------------------------------------- */

uchar usbFunctionSetup(uchar data[8])
{
 54a:	fc 01       	movw	r30, r24
	usbRequest_t *rq = (void *) data;

	// DEBUG LED
	PORTC ^= 0x01;
 54c:	88 b1       	in	r24, 0x08	; 8
 54e:	91 e0       	ldi	r25, 0x01	; 1
 550:	89 27       	eor	r24, r25
 552:	88 b9       	out	0x08, r24	; 8

	if ((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS) {	/* class request type */
 554:	e0 81       	ld	r30, Z
 556:	8e 2f       	mov	r24, r30
 558:	80 76       	andi	r24, 0x60	; 96
 55a:	80 32       	cpi	r24, 0x20	; 32
 55c:	21 f4       	brne	.+8      	; 0x566 <usbFunctionSetup+0x1c>

		/*  Prepare bulk-in endpoint to respond to early termination   */
		if ((rq->bmRequestType & USBRQ_DIR_MASK) ==
 55e:	e7 fd       	sbrc	r30, 7
 560:	02 c0       	rjmp	.+4      	; 0x566 <usbFunctionSetup+0x1c>
		    USBRQ_DIR_HOST_TO_DEVICE)
			sendEmptyFrame = 1;
 562:	90 93 0e 01 	sts	0x010E, r25
	}

	return 0xff;
}
 566:	8f ef       	ldi	r24, 0xFF	; 255
 568:	08 95       	ret

0000056a <usbFunctionRead>:
/*---------------------------------------------------------------------------*/
/* usbFunctionRead                                                           */
/*---------------------------------------------------------------------------*/

uchar usbFunctionRead(uchar * data, uchar len)
{
 56a:	fc 01       	movw	r30, r24
	// DEBUG LED
	PORTC ^= 0x02;
 56c:	88 b1       	in	r24, 0x08	; 8
 56e:	92 e0       	ldi	r25, 0x02	; 2
 570:	89 27       	eor	r24, r25
 572:	88 b9       	out	0x08, r24	; 8

	data[0] = 0;
 574:	10 82       	st	Z, r1
	data[1] = 0;
 576:	11 82       	std	Z+1, r1	; 0x01
	data[2] = 0;
 578:	12 82       	std	Z+2, r1	; 0x02
	data[3] = 0;
 57a:	13 82       	std	Z+3, r1	; 0x03
	data[4] = 0;
 57c:	14 82       	std	Z+4, r1	; 0x04
	data[5] = 0;
 57e:	15 82       	std	Z+5, r1	; 0x05
	data[6] = 0;
 580:	16 82       	std	Z+6, r1	; 0x06

	return 7;
}
 582:	87 e0       	ldi	r24, 0x07	; 7
 584:	08 95       	ret

00000586 <usbFunctionWrite>:
/*---------------------------------------------------------------------------*/

uchar usbFunctionWrite(uchar * data, uchar len)
{
	// DEBUG LED
	PORTC ^= 0x04;
 586:	88 b1       	in	r24, 0x08	; 8
 588:	94 e0       	ldi	r25, 0x04	; 4
 58a:	89 27       	eor	r24, r25
 58c:	88 b9       	out	0x08, r24	; 8
	return 1;
}
 58e:	81 e0       	ldi	r24, 0x01	; 1
 590:	08 95       	ret

00000592 <usbFunctionWriteOut>:
/*---------------------------------------------------------------------------*/

void usbFunctionWriteOut(uchar * data, uchar len)
{
	// DEBUG LED
	PORTC ^= 0x20;
 592:	88 b1       	in	r24, 0x08	; 8
 594:	90 e2       	ldi	r25, 0x20	; 32
 596:	89 27       	eor	r24, r25
 598:	88 b9       	out	0x08, r24	; 8
}
 59a:	08 95       	ret

0000059c <test>:
// silenceAllMIDINotes sends a signal to turn off all notes
void silenceAllMIDINotes(void);


int test(int note, int velocity)
{
 59c:	0f 93       	push	r16
 59e:	1f 93       	push	r17
 5a0:	df 93       	push	r29
 5a2:	cf 93       	push	r28
 5a4:	cd b7       	in	r28, 0x3d	; 61
 5a6:	de b7       	in	r29, 0x3e	; 62
 5a8:	28 97       	sbiw	r28, 0x08	; 8
 5aa:	0f b6       	in	r0, 0x3f	; 63
 5ac:	f8 94       	cli
 5ae:	de bf       	out	0x3e, r29	; 62
 5b0:	0f be       	out	0x3f, r0	; 63
 5b2:	cd bf       	out	0x3d, r28	; 61
 5b4:	18 2f       	mov	r17, r24
 5b6:	06 2f       	mov	r16, r22
	uchar iii;




	sendEmptyFrame = 0;
 5b8:	10 92 0e 01 	sts	0x010E, r1
	
	// only ADC channel 6 and channel 7 are used
	channel = 6;
	uint16_t LEDToggle = 0;
	int playNote = 1;
	DDRC |= 0b10000;
 5bc:	3c 9a       	sbi	0x07, 4	; 7
	PORTC |= 0b10000;
 5be:	44 9a       	sbi	0x08, 4	; 8
	//for (;;) {		/* main event loop */
		wdt_reset();
 5c0:	a8 95       	wdr
		usbPoll();
 5c2:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <usbPoll>
		
		if (usbInterruptIsReady()) {
 5c6:	80 91 1b 01 	lds	r24, 0x011B
 5ca:	84 ff       	sbrs	r24, 4
 5cc:	0f c0       	rjmp	.+30     	; 0x5ec <test+0x50>
            // DEBUG LED
            PORTC ^= 0b10000;
 5ce:	88 b1       	in	r24, 0x08	; 8
 5d0:	90 e1       	ldi	r25, 0x10	; 16
 5d2:	89 27       	eor	r24, r25
 5d4:	88 b9       	out	0x08, r24	; 8
            // http://www.usb.org/developers/devclass_docs/midi10.pdf
            // 4. USB MIDI Event Packets
            iii = 0;
           
            if (playNote) {	/* press */
                midiMsg[iii++] = 0x09;
 5d6:	89 e0       	ldi	r24, 0x09	; 9
 5d8:	89 83       	std	Y+1, r24	; 0x01
                midiMsg[iii++] = 0x90;
 5da:	80 e9       	ldi	r24, 0x90	; 144
 5dc:	8a 83       	std	Y+2, r24	; 0x02
                midiMsg[iii++] = note;
 5de:	1b 83       	std	Y+3, r17	; 0x03
                midiMsg[iii++] = velocity;
 5e0:	0c 83       	std	Y+4, r16	; 0x04
                midiMsg[iii++] = 0x08;
                midiMsg[iii++] = 0x80;
                midiMsg[iii++] = note;
                midiMsg[iii++] = 0x00;
            }
            usbSetInterrupt(midiMsg, iii);
 5e2:	ce 01       	movw	r24, r28
 5e4:	01 96       	adiw	r24, 0x01	; 1
 5e6:	64 e0       	ldi	r22, 0x04	; 4
 5e8:	0e 94 45 03 	call	0x68a	; 0x68a <usbSetInterrupt>
   		}		// usbInterruptIsReady()
//	}
	return 0;
}
 5ec:	80 e0       	ldi	r24, 0x00	; 0
 5ee:	90 e0       	ldi	r25, 0x00	; 0
 5f0:	28 96       	adiw	r28, 0x08	; 8
 5f2:	0f b6       	in	r0, 0x3f	; 63
 5f4:	f8 94       	cli
 5f6:	de bf       	out	0x3e, r29	; 62
 5f8:	0f be       	out	0x3f, r0	; 63
 5fa:	cd bf       	out	0x3d, r28	; 61
 5fc:	cf 91       	pop	r28
 5fe:	df 91       	pop	r29
 600:	1f 91       	pop	r17
 602:	0f 91       	pop	r16
 604:	08 95       	ret

00000606 <sendMIDINote>:
	sei();
}

// sendMIDINote outputs a single note via the USB MIDI interface
void sendMIDINote(int note, int velocity, int channel)
{
 606:	0f 93       	push	r16
 608:	1f 93       	push	r17
 60a:	df 93       	push	r29
 60c:	cf 93       	push	r28
 60e:	0f 92       	push	r0
 610:	cd b7       	in	r28, 0x3d	; 61
 612:	de b7       	in	r29, 0x3e	; 62
 614:	18 2f       	mov	r17, r24
 616:	06 2f       	mov	r16, r22
	wdt_reset(); // Keep the watchdog timer from resetting the MCU
 618:	a8 95       	wdr
	usbPoll();   // and keep the USB connection alive
 61a:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <usbPoll>

	// Do some sanity checking on our channel - you only get to have
	// up to 16 as your channel value
	channel &= 0b00001111;
	uchar midiMsg[1];
	if (usbInterruptIsReady()) {
 61e:	80 91 1b 01 	lds	r24, 0x011B
 622:	84 ff       	sbrs	r24, 4
 624:	0b c0       	rjmp	.+22     	; 0x63c <sendMIDINote+0x36>
        // changes in key status.
        // up to two midi events in one midi msg.
        // For description of USB MIDI msg see:
        // http://www.usb.org/developers/devclass_docs/midi10.pdf
        // 4. USB MIDI Event Packets
		midiMsg[0] = 0x09;
 626:	89 e0       	ldi	r24, 0x09	; 9
 628:	89 83       	std	Y+1, r24	; 0x01
   		midiMsg[1] = 0x90;
 62a:	80 e9       	ldi	r24, 0x90	; 144
 62c:	8a 83       	std	Y+2, r24	; 0x02
    	midiMsg[2] = note; // Random note - G
 62e:	1b 83       	std	Y+3, r17	; 0x03
    	midiMsg[3] = velocity; // Middle Velocity
 630:	0c 83       	std	Y+4, r16	; 0x04
        usbSetInterrupt(midiMsg, 8); //And send it on it's way!
 632:	ce 01       	movw	r24, r28
 634:	01 96       	adiw	r24, 0x01	; 1
 636:	68 e0       	ldi	r22, 0x08	; 8
 638:	0e 94 45 03 	call	0x68a	; 0x68a <usbSetInterrupt>
	}		// usbInterruptIsReady()

}
 63c:	0f 90       	pop	r0
 63e:	cf 91       	pop	r28
 640:	df 91       	pop	r29
 642:	1f 91       	pop	r17
 644:	0f 91       	pop	r16
 646:	08 95       	ret

00000648 <startMIDICommunication>:
}

// setupMIDI sets up the MIDI interface
void startMIDICommunication(void)
{
	wdt_enable(WDTO_1S);
 648:	2e e0       	ldi	r18, 0x0E	; 14
 64a:	88 e1       	ldi	r24, 0x18	; 24
 64c:	90 e0       	ldi	r25, 0x00	; 0
 64e:	0f b6       	in	r0, 0x3f	; 63
 650:	f8 94       	cli
 652:	a8 95       	wdr
 654:	80 93 60 00 	sts	0x0060, r24
 658:	0f be       	out	0x3f, r0	; 63
 65a:	20 93 60 00 	sts	0x0060, r18
static void hardwareInit(void)
{
	uchar i, j;

	/* activate pull-ups except on USB lines */
	USB_CFG_IOPORT =
 65e:	87 ee       	ldi	r24, 0xE7	; 231
 660:	8b b9       	out	0x0b, r24	; 11
	/* all pins input except USB (-> USB reset) */
#ifdef USB_CFG_PULLUP_IOPORT	/* use usbDeviceConnect()/usbDeviceDisconnect() if available */
	USBDDR = 0;		/* we do RESET by deactivating pullup */
	usbDeviceDisconnect();
#else
	USBDDR = (1 << USB_CFG_DMINUS_BIT) | (1 << USB_CFG_DPLUS_BIT);
 662:	88 e1       	ldi	r24, 0x18	; 24
 664:	8a b9       	out	0x0a, r24	; 10
		while (--i);	/* delay >10ms for USB reset */
	}
#ifdef USB_CFG_PULLUP_IOPORT
	usbDeviceConnect();
#else
	USBDDR = 0;		/*  remove USB reset condition */
 666:	1a b8       	out	0x0a, r1	; 10
void startMIDICommunication(void)
{
	wdt_enable(WDTO_1S);
	hardwareInit();
	odDebugInit();
	usbInit();
 668:	0e 94 38 03 	call	0x670	; 0x670 <usbInit>
	sei();
 66c:	78 94       	sei
}
 66e:	08 95       	ret

00000670 <usbInit>:
/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbInit(void)
{
#if USB_INTR_CFG_SET != 0
    USB_INTR_CFG |= USB_INTR_CFG_SET;
 670:	e9 e6       	ldi	r30, 0x69	; 105
 672:	f0 e0       	ldi	r31, 0x00	; 0
 674:	80 81       	ld	r24, Z
 676:	8c 60       	ori	r24, 0x0C	; 12
 678:	80 83       	st	Z, r24
#endif
#if USB_INTR_CFG_CLR != 0
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 67a:	e9 9a       	sbi	0x1d, 1	; 29
/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 67c:	8b e4       	ldi	r24, 0x4B	; 75
 67e:	80 93 1c 01 	sts	0x011C, r24
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
    usbResetDataToggling();
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    usbTxLen1 = USBPID_NAK;
 682:	8a e5       	ldi	r24, 0x5A	; 90
 684:	80 93 1b 01 	sts	0x011B, r24
#if USB_CFG_HAVE_INTRIN_ENDPOINT3
    usbTxLen3 = USBPID_NAK;
#endif
#endif
}
 688:	08 95       	ret

0000068a <usbSetInterrupt>:
    txStatus->len = len + 4;    /* len must be given including sync byte */
    DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
}

USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
{
 68a:	1f 93       	push	r17
 68c:	dc 01       	movw	r26, r24
 68e:	16 2f       	mov	r17, r22
{
uchar   *p;
char    i;

#if USB_CFG_IMPLEMENT_HALT
    if(usbTxLen1 == USBPID_STALL)
 690:	80 91 1b 01 	lds	r24, 0x011B
 694:	8e 31       	cpi	r24, 0x1E	; 30
 696:	e9 f0       	breq	.+58     	; 0x6d2 <usbSetInterrupt+0x48>
        return;
#endif
    if(txStatus->len & 0x10){   /* packet buffer was empty */
 698:	80 91 1b 01 	lds	r24, 0x011B
 69c:	84 ff       	sbrs	r24, 4
 69e:	07 c0       	rjmp	.+14     	; 0x6ae <usbSetInterrupt+0x24>
        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 6a0:	80 91 1c 01 	lds	r24, 0x011C
 6a4:	98 e8       	ldi	r25, 0x88	; 136
 6a6:	89 27       	eor	r24, r25
 6a8:	80 93 1c 01 	sts	0x011C, r24
 6ac:	03 c0       	rjmp	.+6      	; 0x6b4 <usbSetInterrupt+0x2a>
    }else{
        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 6ae:	8a e5       	ldi	r24, 0x5A	; 90
 6b0:	80 93 1b 01 	sts	0x011B, r24
 6b4:	91 2f       	mov	r25, r17
 6b6:	ed e1       	ldi	r30, 0x1D	; 29
 6b8:	f1 e0       	ldi	r31, 0x01	; 1
    }
    p = txStatus->buffer + 1;
    i = len;
    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
        *p++ = *data++;
 6ba:	8d 91       	ld	r24, X+
 6bc:	81 93       	st	Z+, r24
    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 6be:	91 50       	subi	r25, 0x01	; 1
 6c0:	e1 f7       	brne	.-8      	; 0x6ba <usbSetInterrupt+0x30>
    usbCrc16Append(&txStatus->buffer[1], len);
 6c2:	8d e1       	ldi	r24, 0x1D	; 29
 6c4:	91 e0       	ldi	r25, 0x01	; 1
 6c6:	61 2f       	mov	r22, r17
 6c8:	0e 94 c5 04 	call	0x98a	; 0x98a <usbCrc16Append>
    txStatus->len = len + 4;    /* len must be given including sync byte */
 6cc:	1c 5f       	subi	r17, 0xFC	; 252
 6ce:	10 93 1b 01 	sts	0x011B, r17
}

USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
{
    usbGenericSetInterrupt(data, len, &usbTxStatus1);
}
 6d2:	1f 91       	pop	r17
 6d4:	08 95       	ret

000006d6 <usbPoll>:
}

/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbPoll(void)
{
 6d6:	1f 93       	push	r17
 6d8:	cf 93       	push	r28
 6da:	df 93       	push	r29
schar   len;
uchar   i;

    len = usbRxLen - 3;
 6dc:	60 91 2c 01 	lds	r22, 0x012C
 6e0:	63 50       	subi	r22, 0x03	; 3
    if(len >= 0){
 6e2:	67 fd       	sbrc	r22, 7
 6e4:	ce c0       	rjmp	.+412    	; 0x882 <usbPoll+0x1ac>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
 6e6:	80 91 29 01 	lds	r24, 0x0129
 6ea:	cc e0       	ldi	r28, 0x0C	; 12
 6ec:	d0 e0       	ldi	r29, 0x00	; 0
 6ee:	c8 1b       	sub	r28, r24
 6f0:	d1 09       	sbc	r29, r1
 6f2:	c0 5d       	subi	r28, 0xD0	; 208
 6f4:	de 4f       	sbci	r29, 0xFE	; 254
 * 0...0x0f for OUT on endpoint X
 */
    DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
    USB_RX_USER_HOOK(data, len)
#if USB_CFG_IMPLEMENT_FN_WRITEOUT
    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
 6f6:	80 91 28 01 	lds	r24, 0x0128
 6fa:	80 31       	cpi	r24, 0x10	; 16
 6fc:	20 f4       	brcc	.+8      	; 0x706 <usbPoll+0x30>
        usbFunctionWriteOut(data, len);
 6fe:	ce 01       	movw	r24, r28
 700:	0e 94 c9 02 	call	0x592	; 0x592 <usbFunctionWriteOut>
 704:	bc c0       	rjmp	.+376    	; 0x87e <usbPoll+0x1a8>
        return;
    }
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
 706:	8d 32       	cpi	r24, 0x2D	; 45
 708:	09 f0       	breq	.+2      	; 0x70c <usbPoll+0x36>
 70a:	a8 c0       	rjmp	.+336    	; 0x85c <usbPoll+0x186>
        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 70c:	68 30       	cpi	r22, 0x08	; 8
 70e:	09 f0       	breq	.+2      	; 0x712 <usbPoll+0x3c>
 710:	b6 c0       	rjmp	.+364    	; 0x87e <usbPoll+0x1a8>
            return;
        usbMsgLen_t replyLen;
        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 712:	83 ec       	ldi	r24, 0xC3	; 195
 714:	80 93 10 01 	sts	0x0110, r24
        usbTxLen = USBPID_NAK;              /* abort pending transmit */
 718:	8a e5       	ldi	r24, 0x5A	; 90
 71a:	80 93 0c 01 	sts	0x010C, r24
        usbMsgFlags = 0;
 71e:	10 92 0f 01 	sts	0x010F, r1
        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 722:	98 81       	ld	r25, Y
        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 724:	89 2f       	mov	r24, r25
 726:	80 76       	andi	r24, 0x60	; 96
 728:	29 f0       	breq	.+10     	; 0x734 <usbPoll+0x5e>
            replyLen = usbFunctionSetup(data);
 72a:	ce 01       	movw	r24, r28
 72c:	0e 94 a5 02 	call	0x54a	; 0x54a <usbFunctionSetup>
 730:	28 2f       	mov	r18, r24
 732:	81 c0       	rjmp	.+258    	; 0x836 <usbPoll+0x160>
 * standard requests instead of class and custom requests.
 */
static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
{
uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffer */
uchar   value = rq->wValue.bytes[0];
 734:	2a 81       	ldd	r18, Y+2	; 0x02
#if USB_CFG_IMPLEMENT_HALT
uchar   index = rq->wIndex.bytes[0];
 736:	3c 81       	ldd	r19, Y+4	; 0x04
#endif

    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 738:	10 92 19 01 	sts	0x0119, r1
    SWITCH_START(rq->bRequest)
 73c:	89 81       	ldd	r24, Y+1	; 0x01
    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 73e:	88 23       	and	r24, r24
 740:	81 f4       	brne	.+32     	; 0x762 <usbPoll+0x8c>
        uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to enforce byte size */
        if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
#if USB_CFG_IMPLEMENT_HALT
        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
 742:	9f 71       	andi	r25, 0x1F	; 31
 744:	92 30       	cpi	r25, 0x02	; 2
 746:	49 f4       	brne	.+18     	; 0x75a <usbPoll+0x84>
 748:	31 38       	cpi	r19, 0x81	; 129
 74a:	39 f4       	brne	.+14     	; 0x75a <usbPoll+0x84>
            dataPtr[0] = usbTxLen1 == USBPID_STALL;
 74c:	80 91 1b 01 	lds	r24, 0x011B
 750:	8e 31       	cpi	r24, 0x1E	; 30
 752:	19 f4       	brne	.+6      	; 0x75a <usbPoll+0x84>
 754:	81 e0       	ldi	r24, 0x01	; 1
 756:	80 93 19 01 	sts	0x0119, r24
#endif
        dataPtr[1] = 0;
 75a:	10 92 1a 01 	sts	0x011A, r1
 75e:	22 e0       	ldi	r18, 0x02	; 2
 760:	63 c0       	rjmp	.+198    	; 0x828 <usbPoll+0x152>
        len = 2;
#if USB_CFG_IMPLEMENT_HALT
    SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
 762:	81 30       	cpi	r24, 0x01	; 1
 764:	11 f0       	breq	.+4      	; 0x76a <usbPoll+0x94>
 766:	83 30       	cpi	r24, 0x03	; 3
 768:	89 f4       	brne	.+34     	; 0x78c <usbPoll+0xb6>
        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
 76a:	22 23       	and	r18, r18
 76c:	09 f0       	breq	.+2      	; 0x770 <usbPoll+0x9a>
 76e:	5b c0       	rjmp	.+182    	; 0x826 <usbPoll+0x150>
 770:	31 38       	cpi	r19, 0x81	; 129
 772:	09 f0       	breq	.+2      	; 0x776 <usbPoll+0xa0>
 774:	58 c0       	rjmp	.+176    	; 0x826 <usbPoll+0x150>
            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
 776:	81 30       	cpi	r24, 0x01	; 1
 778:	11 f0       	breq	.+4      	; 0x77e <usbPoll+0xa8>
 77a:	8e e1       	ldi	r24, 0x1E	; 30
 77c:	01 c0       	rjmp	.+2      	; 0x780 <usbPoll+0xaa>
 77e:	8a e5       	ldi	r24, 0x5A	; 90
 780:	80 93 1b 01 	sts	0x011B, r24
/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 784:	8b e4       	ldi	r24, 0x4B	; 75
 786:	80 93 1c 01 	sts	0x011C, r24
 78a:	4d c0       	rjmp	.+154    	; 0x826 <usbPoll+0x150>
        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
            usbResetDataToggling();
        }
#endif
    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 78c:	85 30       	cpi	r24, 0x05	; 5
 78e:	19 f4       	brne	.+6      	; 0x796 <usbPoll+0xc0>
        usbNewDeviceAddr = value;
 790:	20 93 2d 01 	sts	0x012D, r18
 794:	48 c0       	rjmp	.+144    	; 0x826 <usbPoll+0x150>
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 796:	86 30       	cpi	r24, 0x06	; 6
 798:	79 f5       	brne	.+94     	; 0x7f8 <usbPoll+0x122>
static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
{
usbMsgLen_t len = 0;
uchar       flags = USB_FLG_MSGPTR_IS_ROM;

    SWITCH_START(rq->wValue.bytes[1])
 79a:	8b 81       	ldd	r24, Y+3	; 0x03
    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 79c:	81 30       	cpi	r24, 0x01	; 1
 79e:	11 f0       	breq	.+4      	; 0x7a4 <usbPoll+0xce>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
    SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 7a0:	82 30       	cpi	r24, 0x02	; 2
 7a2:	29 f4       	brne	.+10     	; 0x7ae <usbPoll+0xd8>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 7a4:	ce 01       	movw	r24, r28
 7a6:	0e 94 91 02 	call	0x522	; 0x522 <usbFunctionDescriptor>
 7aa:	28 2f       	mov	r18, r24
 7ac:	21 c0       	rjmp	.+66     	; 0x7f0 <usbPoll+0x11a>
    SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 7ae:	83 30       	cpi	r24, 0x03	; 3
 7b0:	f1 f4       	brne	.+60     	; 0x7ee <usbPoll+0x118>
        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
            flags = 0;
        len = usbFunctionDescriptor(rq);
#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
        SWITCH_START(rq->wValue.bytes[0])
        SWITCH_CASE(0)
 7b2:	22 23       	and	r18, r18
 7b4:	41 f4       	brne	.+16     	; 0x7c6 <usbPoll+0xf0>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 7b6:	8f ed       	ldi	r24, 0xDF	; 223
 7b8:	90 e0       	ldi	r25, 0x00	; 0
 7ba:	90 93 2b 01 	sts	0x012B, r25
 7be:	80 93 2a 01 	sts	0x012A, r24
 7c2:	24 e0       	ldi	r18, 0x04	; 4
 7c4:	15 c0       	rjmp	.+42     	; 0x7f0 <usbPoll+0x11a>
        SWITCH_CASE(1)
 7c6:	21 30       	cpi	r18, 0x01	; 1
 7c8:	41 f4       	brne	.+16     	; 0x7da <usbPoll+0x104>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 7ca:	83 ee       	ldi	r24, 0xE3	; 227
 7cc:	90 e0       	ldi	r25, 0x00	; 0
 7ce:	90 93 2b 01 	sts	0x012B, r25
 7d2:	80 93 2a 01 	sts	0x012A, r24
 7d6:	22 e2       	ldi	r18, 0x22	; 34
 7d8:	0b c0       	rjmp	.+22     	; 0x7f0 <usbPoll+0x11a>
        SWITCH_CASE(2)
 7da:	22 30       	cpi	r18, 0x02	; 2
 7dc:	41 f4       	brne	.+16     	; 0x7ee <usbPoll+0x118>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 7de:	85 e0       	ldi	r24, 0x05	; 5
 7e0:	91 e0       	ldi	r25, 0x01	; 1
 7e2:	90 93 2b 01 	sts	0x012B, r25
 7e6:	80 93 2a 01 	sts	0x012A, r24
 7ea:	26 e1       	ldi	r18, 0x16	; 22
 7ec:	01 c0       	rjmp	.+2      	; 0x7f0 <usbPoll+0x11a>
 7ee:	20 e0       	ldi	r18, 0x00	; 0
    SWITCH_DEFAULT
        if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
            len = usbFunctionDescriptor(rq);
        }
    SWITCH_END
    usbMsgFlags = flags;
 7f0:	80 e4       	ldi	r24, 0x40	; 64
 7f2:	80 93 0f 01 	sts	0x010F, r24
 7f6:	1f c0       	rjmp	.+62     	; 0x836 <usbPoll+0x160>
        usbNewDeviceAddr = value;
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
        len = usbDriverDescriptor(rq);
        goto skipMsgPtrAssignment;
    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 7f8:	88 30       	cpi	r24, 0x08	; 8
 7fa:	21 f4       	brne	.+8      	; 0x804 <usbPoll+0x12e>
 7fc:	21 e0       	ldi	r18, 0x01	; 1
 7fe:	8f e2       	ldi	r24, 0x2F	; 47
 800:	91 e0       	ldi	r25, 0x01	; 1
 802:	14 c0       	rjmp	.+40     	; 0x82c <usbPoll+0x156>
        dataPtr = &usbConfiguration;  /* send current configuration value */
        len = 1;
    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 804:	89 30       	cpi	r24, 0x09	; 9
 806:	19 f4       	brne	.+6      	; 0x80e <usbPoll+0x138>
        usbConfiguration = value;
 808:	20 93 2f 01 	sts	0x012F, r18
 80c:	09 c0       	rjmp	.+18     	; 0x820 <usbPoll+0x14a>
        usbResetStall();
    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 80e:	8a 30       	cpi	r24, 0x0A	; 10
 810:	11 f4       	brne	.+4      	; 0x816 <usbPoll+0x140>
 812:	21 e0       	ldi	r18, 0x01	; 1
 814:	09 c0       	rjmp	.+18     	; 0x828 <usbPoll+0x152>
        len = 1;
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 816:	8b 30       	cpi	r24, 0x0B	; 11
 818:	31 f4       	brne	.+12     	; 0x826 <usbPoll+0x150>
/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 81a:	8b e4       	ldi	r24, 0x4B	; 75
 81c:	80 93 1c 01 	sts	0x011C, r24
}

static inline void  usbResetStall(void)
{
#if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
        usbTxLen1 = USBPID_NAK;
 820:	8a e5       	ldi	r24, 0x5A	; 90
 822:	80 93 1b 01 	sts	0x011B, r24
 826:	20 e0       	ldi	r18, 0x00	; 0
 828:	89 e1       	ldi	r24, 0x19	; 25
 82a:	91 e0       	ldi	r25, 0x01	; 1
        usbResetStall();
#endif
    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
        /* Should we add an optional hook here? */
    SWITCH_END
    usbMsgPtr = dataPtr;
 82c:	90 93 2b 01 	sts	0x012B, r25
 830:	80 93 2a 01 	sts	0x012A, r24
 834:	09 c0       	rjmp	.+18     	; 0x848 <usbPoll+0x172>
            replyLen = usbFunctionSetup(data);
        }else{
            replyLen = usbDriverSetup(rq);
        }
#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
        if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
 836:	2f 3f       	cpi	r18, 0xFF	; 255
 838:	39 f4       	brne	.+14     	; 0x848 <usbPoll+0x172>
            /* do some conditioning on replyLen, but on IN transfers only */
            if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
 83a:	88 81       	ld	r24, Y
 83c:	87 fd       	sbrc	r24, 7
                if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
                    replyLen = rq->wLength.bytes[0];
 83e:	2e 81       	ldd	r18, Y+6	; 0x06
                }else{
                    replyLen = rq->wLength.word;
                }
            }
            usbMsgFlags = USB_FLG_USE_USER_RW;
 840:	80 e8       	ldi	r24, 0x80	; 128
 842:	80 93 0f 01 	sts	0x010F, r24
 846:	06 c0       	rjmp	.+12     	; 0x854 <usbPoll+0x17e>
        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */
#endif
        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */
 848:	8f 81       	ldd	r24, Y+7	; 0x07
 84a:	88 23       	and	r24, r24
 84c:	19 f4       	brne	.+6      	; 0x854 <usbPoll+0x17e>
 84e:	8e 81       	ldd	r24, Y+6	; 0x06
 850:	82 17       	cp	r24, r18
 852:	08 f0       	brcs	.+2      	; 0x856 <usbPoll+0x180>
 854:	82 2f       	mov	r24, r18
                replyLen = rq->wLength.bytes[0];
        }else{
            if(replyLen > rq->wLength.word)     /* limit length to max */
                replyLen = rq->wLength.word;
        }
        usbMsgLen = replyLen;
 856:	80 93 0d 01 	sts	0x010D, r24
 85a:	11 c0       	rjmp	.+34     	; 0x87e <usbPoll+0x1a8>
    }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
#if USB_CFG_IMPLEMENT_FN_WRITE
        if(usbMsgFlags & USB_FLG_USE_USER_RW){
 85c:	80 91 0f 01 	lds	r24, 0x010F
 860:	87 ff       	sbrs	r24, 7
 862:	0d c0       	rjmp	.+26     	; 0x87e <usbPoll+0x1a8>
            uchar rval = usbFunctionWrite(data, len);
 864:	ce 01       	movw	r24, r28
 866:	0e 94 c3 02 	call	0x586	; 0x586 <usbFunctionWrite>
            if(rval == 0xff){   /* an error occurred */
 86a:	8f 3f       	cpi	r24, 0xFF	; 255
 86c:	21 f4       	brne	.+8      	; 0x876 <usbPoll+0x1a0>
                usbTxLen = USBPID_STALL;
 86e:	8e e1       	ldi	r24, 0x1E	; 30
 870:	80 93 0c 01 	sts	0x010C, r24
 874:	04 c0       	rjmp	.+8      	; 0x87e <usbPoll+0x1a8>
            }else if(rval != 0){    /* This was the final package */
 876:	88 23       	and	r24, r24
 878:	11 f0       	breq	.+4      	; 0x87e <usbPoll+0x1a8>
                usbMsgLen = 0;  /* answer with a zero-sized data packet */
 87a:	10 92 0d 01 	sts	0x010D, r1
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
#if USB_CFG_HAVE_FLOWCONTROL
        if(usbRxLen > 0)    /* only mark as available if not inactivated */
            usbRxLen = 0;
#else
        usbRxLen = 0;       /* mark rx buffer as available */
 87e:	10 92 2c 01 	sts	0x012C, r1
#endif
    }
    if(usbTxLen & 0x10){    /* transmit system idle */
 882:	80 91 0c 01 	lds	r24, 0x010C
 886:	84 ff       	sbrs	r24, 4
 888:	5a c0       	rjmp	.+180    	; 0x93e <usbPoll+0x268>
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 88a:	80 91 0d 01 	lds	r24, 0x010D
 88e:	8f 3f       	cpi	r24, 0xFF	; 255
 890:	09 f4       	brne	.+2      	; 0x894 <usbPoll+0x1be>
 892:	55 c0       	rjmp	.+170    	; 0x93e <usbPoll+0x268>
 894:	18 2f       	mov	r17, r24
 896:	89 30       	cpi	r24, 0x09	; 9
 898:	08 f0       	brcs	.+2      	; 0x89c <usbPoll+0x1c6>
 89a:	18 e0       	ldi	r17, 0x08	; 8
uchar       len;

    wantLen = usbMsgLen;
    if(wantLen > 8)
        wantLen = 8;
    usbMsgLen -= wantLen;
 89c:	81 1b       	sub	r24, r17
 89e:	80 93 0d 01 	sts	0x010D, r24
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 8a2:	80 91 10 01 	lds	r24, 0x0110
 8a6:	98 e8       	ldi	r25, 0x88	; 136
 8a8:	89 27       	eor	r24, r25
 8aa:	80 93 10 01 	sts	0x0110, r24
/* This function is similar to usbFunctionRead(), but it's also called for
 * data handled automatically by the driver (e.g. descriptor reads).
 */
static uchar usbDeviceRead(uchar *data, uchar len)
{
    if(len > 0){    /* don't bother app with 0 sized reads */
 8ae:	11 23       	and	r17, r17
 8b0:	99 f1       	breq	.+102    	; 0x918 <usbPoll+0x242>
#if USB_CFG_IMPLEMENT_FN_READ
        if(usbMsgFlags & USB_FLG_USE_USER_RW){
 8b2:	80 91 0f 01 	lds	r24, 0x010F
 8b6:	87 ff       	sbrs	r24, 7
 8b8:	09 c0       	rjmp	.+18     	; 0x8cc <usbPoll+0x1f6>
            len = usbFunctionRead(data, len);
 8ba:	81 e1       	ldi	r24, 0x11	; 17
 8bc:	91 e0       	ldi	r25, 0x01	; 1
 8be:	61 2f       	mov	r22, r17
 8c0:	0e 94 b5 02 	call	0x56a	; 0x56a <usbFunctionRead>
 8c4:	18 2f       	mov	r17, r24
    if(wantLen > 8)
        wantLen = 8;
    usbMsgLen -= wantLen;
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    len = usbDeviceRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
 8c6:	89 30       	cpi	r24, 0x09	; 9
 8c8:	a0 f5       	brcc	.+104    	; 0x932 <usbPoll+0x25c>
 8ca:	26 c0       	rjmp	.+76     	; 0x918 <usbPoll+0x242>
        if(usbMsgFlags & USB_FLG_USE_USER_RW){
            len = usbFunctionRead(data, len);
        }else
#endif
        {
            uchar i = len, *r = usbMsgPtr;
 8cc:	20 91 2a 01 	lds	r18, 0x012A
 8d0:	30 91 2b 01 	lds	r19, 0x012B
            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 8d4:	86 ff       	sbrs	r24, 6
 8d6:	0d c0       	rjmp	.+26     	; 0x8f2 <usbPoll+0x21c>
 8d8:	a1 e1       	ldi	r26, 0x11	; 17
 8da:	b1 e0       	ldi	r27, 0x01	; 1
 8dc:	80 e0       	ldi	r24, 0x00	; 0
 8de:	90 e0       	ldi	r25, 0x00	; 0
                do{
                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */
 8e0:	f9 01       	movw	r30, r18
 8e2:	e8 0f       	add	r30, r24
 8e4:	f9 1f       	adc	r31, r25
 8e6:	e4 91       	lpm	r30, Z+
                    *data++ = c;
 8e8:	ed 93       	st	X+, r30
 8ea:	01 96       	adiw	r24, 0x01	; 1
                    r++;
                }while(--i);
 8ec:	18 17       	cp	r17, r24
 8ee:	c1 f7       	brne	.-16     	; 0x8e0 <usbPoll+0x20a>
 8f0:	08 c0       	rjmp	.+16     	; 0x902 <usbPoll+0x22c>
 8f2:	91 2f       	mov	r25, r17
 8f4:	d9 01       	movw	r26, r18
 8f6:	e1 e1       	ldi	r30, 0x11	; 17
 8f8:	f1 e0       	ldi	r31, 0x01	; 1
            }else{  /* RAM data */
                do{
                    *data++ = *r++;
 8fa:	8d 91       	ld	r24, X+
 8fc:	81 93       	st	Z+, r24
                }while(--i);
 8fe:	91 50       	subi	r25, 0x01	; 1
 900:	e1 f7       	brne	.-8      	; 0x8fa <usbPoll+0x224>
 902:	11 50       	subi	r17, 0x01	; 1
 904:	81 2f       	mov	r24, r17
 906:	90 e0       	ldi	r25, 0x00	; 0
 908:	1f 5f       	subi	r17, 0xFF	; 255
 90a:	01 96       	adiw	r24, 0x01	; 1
 90c:	82 0f       	add	r24, r18
 90e:	93 1f       	adc	r25, r19
            }
            usbMsgPtr = r;
 910:	90 93 2b 01 	sts	0x012B, r25
 914:	80 93 2a 01 	sts	0x012A, r24
        wantLen = 8;
    usbMsgLen -= wantLen;
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    len = usbDeviceRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
        usbCrc16Append(&usbTxBuf[1], len);
 918:	81 e1       	ldi	r24, 0x11	; 17
 91a:	91 e0       	ldi	r25, 0x01	; 1
 91c:	61 2f       	mov	r22, r17
 91e:	0e 94 c5 04 	call	0x98a	; 0x98a <usbCrc16Append>
        len += 4;           /* length including sync byte */
 922:	61 2f       	mov	r22, r17
 924:	6c 5f       	subi	r22, 0xFC	; 252
        if(len < 12)        /* a partial package identifies end of message */
 926:	6c 30       	cpi	r22, 0x0C	; 12
 928:	41 f0       	breq	.+16     	; 0x93a <usbPoll+0x264>
            usbMsgLen = USB_NO_MSG;
 92a:	8f ef       	ldi	r24, 0xFF	; 255
 92c:	80 93 0d 01 	sts	0x010D, r24
 930:	04 c0       	rjmp	.+8      	; 0x93a <usbPoll+0x264>
    }else{
        len = USBPID_STALL;   /* stall the endpoint */
        usbMsgLen = USB_NO_MSG;
 932:	8f ef       	ldi	r24, 0xFF	; 255
 934:	80 93 0d 01 	sts	0x010D, r24
 938:	6e e1       	ldi	r22, 0x1E	; 30
    }
    usbTxLen = len;
 93a:	60 93 0c 01 	sts	0x010C, r22
 93e:	94 e1       	ldi	r25, 0x14	; 20
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 20; i > 0; i--){
        uchar usbLineStatus = USBIN & USBMASK;
 940:	89 b1       	in	r24, 0x09	; 9
        if(usbLineStatus != 0)  /* SE0 has ended */
 942:	88 71       	andi	r24, 0x18	; 24
 944:	49 f4       	brne	.+18     	; 0x958 <usbPoll+0x282>
    if(usbTxLen & 0x10){    /* transmit system idle */
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 20; i > 0; i--){
 946:	91 50       	subi	r25, 0x01	; 1
 948:	d9 f7       	brne	.-10     	; 0x940 <usbPoll+0x26a>
        uchar usbLineStatus = USBIN & USBMASK;
        if(usbLineStatus != 0)  /* SE0 has ended */
            goto isNotReset;
    }
    /* RESET condition, called multiple times during reset */
    usbNewDeviceAddr = 0;
 94a:	10 92 2d 01 	sts	0x012D, r1
    usbDeviceAddr = 0;
 94e:	10 92 27 01 	sts	0x0127, r1
}

static inline void  usbResetStall(void)
{
#if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
        usbTxLen1 = USBPID_NAK;
 952:	8a e5       	ldi	r24, 0x5A	; 90
 954:	80 93 1b 01 	sts	0x011B, r24
    usbDeviceAddr = 0;
    usbResetStall();
    DBG1(0xff, 0, 0);
isNotReset:
    usbHandleResetHook(i);
}
 958:	df 91       	pop	r29
 95a:	cf 91       	pop	r28
 95c:	1f 91       	pop	r17
 95e:	08 95       	ret

00000960 <usbCrc16>:
 960:	a8 2f       	mov	r26, r24
 962:	b9 2f       	mov	r27, r25
 964:	80 e0       	ldi	r24, 0x00	; 0
 966:	90 e0       	ldi	r25, 0x00	; 0
 968:	41 e0       	ldi	r20, 0x01	; 1
 96a:	50 ea       	ldi	r21, 0xA0	; 160
 96c:	60 95       	com	r22

0000096e <crcByteLoop>:
 96e:	6f 5f       	subi	r22, 0xFF	; 255
 970:	58 f4       	brcc	.+22     	; 0x988 <crcReady>
 972:	2d 91       	ld	r18, X+
 974:	38 ef       	ldi	r19, 0xF8	; 248
 976:	82 27       	eor	r24, r18

00000978 <crcBitLoop>:
 978:	97 95       	ror	r25
 97a:	87 95       	ror	r24
 97c:	10 f0       	brcs	.+4      	; 0x982 <crcNoXor>
 97e:	84 27       	eor	r24, r20
 980:	95 27       	eor	r25, r21

00000982 <crcNoXor>:
 982:	3f 5f       	subi	r19, 0xFF	; 255
 984:	c8 f3       	brcs	.-14     	; 0x978 <crcBitLoop>
 986:	f3 cf       	rjmp	.-26     	; 0x96e <crcByteLoop>

00000988 <crcReady>:
 988:	08 95       	ret

0000098a <usbCrc16Append>:
 98a:	ea df       	rcall	.-44     	; 0x960 <usbCrc16>
 98c:	8d 93       	st	X+, r24
 98e:	9d 93       	st	X+, r25
 990:	08 95       	ret

00000992 <__vector_2>:
 992:	cf 93       	push	r28
 994:	cf b7       	in	r28, 0x3f	; 63
 996:	cf 93       	push	r28

00000998 <waitForJ>:
 998:	c3 95       	inc	r28
 99a:	4c 9b       	sbis	0x09, 4	; 9
 99c:	e9 f7       	brne	.-6      	; 0x998 <waitForJ>

0000099e <waitForK>:
 99e:	4c 9b       	sbis	0x09, 4	; 9
 9a0:	09 c0       	rjmp	.+18     	; 0x9b4 <foundK>
 9a2:	4c 9b       	sbis	0x09, 4	; 9
 9a4:	07 c0       	rjmp	.+14     	; 0x9b4 <foundK>
 9a6:	4c 9b       	sbis	0x09, 4	; 9
 9a8:	05 c0       	rjmp	.+10     	; 0x9b4 <foundK>
 9aa:	4c 9b       	sbis	0x09, 4	; 9
 9ac:	03 c0       	rjmp	.+6      	; 0x9b4 <foundK>
 9ae:	4c 9b       	sbis	0x09, 4	; 9
 9b0:	01 c0       	rjmp	.+2      	; 0x9b4 <foundK>
 9b2:	a6 c0       	rjmp	.+332    	; 0xb00 <sofError>

000009b4 <foundK>:
 9b4:	df 93       	push	r29
 9b6:	c0 91 29 01 	lds	r28, 0x0129
 9ba:	dd 27       	eor	r29, r29
 9bc:	c0 5d       	subi	r28, 0xD0	; 208
 9be:	de 4f       	sbci	r29, 0xFE	; 254
 9c0:	4c 9b       	sbis	0x09, 4	; 9
 9c2:	02 c0       	rjmp	.+4      	; 0x9c8 <haveTwoBitsK>
 9c4:	df 91       	pop	r29
 9c6:	eb cf       	rjmp	.-42     	; 0x99e <waitForK>

000009c8 <haveTwoBitsK>:
 9c8:	2f 93       	push	r18
 9ca:	0f 93       	push	r16
 9cc:	1f 93       	push	r17
 9ce:	09 b1       	in	r16, 0x09	; 9
 9d0:	2f ef       	ldi	r18, 0xFF	; 255
 9d2:	04 fb       	bst	r16, 4
 9d4:	20 f9       	bld	r18, 0
 9d6:	4f 93       	push	r20
 9d8:	3f 93       	push	r19
 9da:	19 b1       	in	r17, 0x09	; 9
 9dc:	4f ef       	ldi	r20, 0xFF	; 255
 9de:	01 27       	eor	r16, r17
 9e0:	04 fb       	bst	r16, 4
 9e2:	21 f9       	bld	r18, 1
 9e4:	3b e0       	ldi	r19, 0x0B	; 11
 9e6:	31 c0       	rjmp	.+98     	; 0xa4a <rxbit2>

000009e8 <unstuff0>:
 9e8:	4e 7f       	andi	r20, 0xFE	; 254
 9ea:	01 2f       	mov	r16, r17
 9ec:	19 b1       	in	r17, 0x09	; 9
 9ee:	21 60       	ori	r18, 0x01	; 1
 9f0:	28 c0       	rjmp	.+80     	; 0xa42 <didUnstuff0>

000009f2 <unstuff1>:
 9f2:	10 2f       	mov	r17, r16
 9f4:	4d 7f       	andi	r20, 0xFD	; 253
 9f6:	22 60       	ori	r18, 0x02	; 2
 9f8:	00 00       	nop
 9fa:	09 b1       	in	r16, 0x09	; 9
 9fc:	29 c0       	rjmp	.+82     	; 0xa50 <didUnstuff1>

000009fe <unstuff2>:
 9fe:	4b 7f       	andi	r20, 0xFB	; 251
 a00:	24 60       	ori	r18, 0x04	; 4
 a02:	01 2f       	mov	r16, r17
 a04:	00 00       	nop
 a06:	19 b1       	in	r17, 0x09	; 9
 a08:	2b c0       	rjmp	.+86     	; 0xa60 <didUnstuff2>

00000a0a <unstuff3>:
 a0a:	19 b1       	in	r17, 0x09	; 9
 a0c:	47 7f       	andi	r20, 0xF7	; 247
 a0e:	28 60       	ori	r18, 0x08	; 8
 a10:	2a c0       	rjmp	.+84     	; 0xa66 <didUnstuff3>

00000a12 <unstuff4>:
 a12:	4f 7e       	andi	r20, 0xEF	; 239
 a14:	09 b1       	in	r16, 0x09	; 9
 a16:	20 61       	ori	r18, 0x10	; 16
 a18:	2c c0       	rjmp	.+88     	; 0xa72 <didUnstuff4>

00000a1a <unstuff5>:
 a1a:	4f 7d       	andi	r20, 0xDF	; 223
 a1c:	19 b1       	in	r17, 0x09	; 9
 a1e:	20 62       	ori	r18, 0x20	; 32
 a20:	2f c0       	rjmp	.+94     	; 0xa80 <didUnstuff5>

00000a22 <unstuff6>:
 a22:	4f 7b       	andi	r20, 0xBF	; 191
 a24:	09 b1       	in	r16, 0x09	; 9
 a26:	20 64       	ori	r18, 0x40	; 64
 a28:	32 c0       	rjmp	.+100    	; 0xa8e <didUnstuff6>

00000a2a <rxLoop>:
 a2a:	42 27       	eor	r20, r18
 a2c:	09 b1       	in	r16, 0x09	; 9
 a2e:	49 93       	st	Y+, r20
 a30:	4f ef       	ldi	r20, 0xFF	; 255
 a32:	00 00       	nop
 a34:	10 27       	eor	r17, r16
 a36:	14 fb       	bst	r17, 4
 a38:	20 f9       	bld	r18, 0
 a3a:	19 b1       	in	r17, 0x09	; 9
 a3c:	18 71       	andi	r17, 0x18	; 24
 a3e:	c9 f1       	breq	.+114    	; 0xab2 <se0>
 a40:	29 7f       	andi	r18, 0xF9	; 249

00000a42 <didUnstuff0>:
 a42:	91 f2       	breq	.-92     	; 0x9e8 <unstuff0>
 a44:	01 27       	eor	r16, r17
 a46:	04 fb       	bst	r16, 4
 a48:	21 f9       	bld	r18, 1

00000a4a <rxbit2>:
 a4a:	09 b1       	in	r16, 0x09	; 9
 a4c:	23 7f       	andi	r18, 0xF3	; 243
 a4e:	89 f2       	breq	.-94     	; 0x9f2 <unstuff1>

00000a50 <didUnstuff1>:
 a50:	31 50       	subi	r19, 0x01	; 1
 a52:	58 f1       	brcs	.+86     	; 0xaaa <overflow>
 a54:	10 27       	eor	r17, r16
 a56:	14 fb       	bst	r17, 4
 a58:	22 f9       	bld	r18, 2
 a5a:	19 b1       	in	r17, 0x09	; 9
 a5c:	27 7e       	andi	r18, 0xE7	; 231
 a5e:	79 f2       	breq	.-98     	; 0x9fe <unstuff2>

00000a60 <didUnstuff2>:
 a60:	01 27       	eor	r16, r17
 a62:	04 fb       	bst	r16, 4
 a64:	23 f9       	bld	r18, 3

00000a66 <didUnstuff3>:
 a66:	2f 7c       	andi	r18, 0xCF	; 207
 a68:	81 f2       	breq	.-96     	; 0xa0a <unstuff3>
 a6a:	09 b1       	in	r16, 0x09	; 9
 a6c:	10 27       	eor	r17, r16
 a6e:	14 fb       	bst	r17, 4
 a70:	24 f9       	bld	r18, 4

00000a72 <didUnstuff4>:
 a72:	2f 79       	andi	r18, 0x9F	; 159
 a74:	71 f2       	breq	.-100    	; 0xa12 <unstuff4>
 a76:	00 c0       	rjmp	.+0      	; 0xa78 <didUnstuff4+0x6>
 a78:	19 b1       	in	r17, 0x09	; 9
 a7a:	01 27       	eor	r16, r17
 a7c:	04 fb       	bst	r16, 4
 a7e:	25 f9       	bld	r18, 5

00000a80 <didUnstuff5>:
 a80:	2f 73       	andi	r18, 0x3F	; 63
 a82:	59 f2       	breq	.-106    	; 0xa1a <unstuff5>
 a84:	00 c0       	rjmp	.+0      	; 0xa86 <didUnstuff5+0x6>
 a86:	09 b1       	in	r16, 0x09	; 9
 a88:	10 27       	eor	r17, r16
 a8a:	14 fb       	bst	r17, 4
 a8c:	26 f9       	bld	r18, 6

00000a8e <didUnstuff6>:
 a8e:	22 30       	cpi	r18, 0x02	; 2
 a90:	40 f2       	brcs	.-112    	; 0xa22 <unstuff6>
 a92:	00 c0       	rjmp	.+0      	; 0xa94 <didUnstuff6+0x6>
 a94:	19 b1       	in	r17, 0x09	; 9
 a96:	01 27       	eor	r16, r17
 a98:	04 fb       	bst	r16, 4
 a9a:	27 f9       	bld	r18, 7

00000a9c <didUnstuff7>:
 a9c:	24 30       	cpi	r18, 0x04	; 4
 a9e:	28 f6       	brcc	.-118    	; 0xa2a <rxLoop>

00000aa0 <unstuff7>:
 aa0:	4f 77       	andi	r20, 0x7F	; 127
 aa2:	20 68       	ori	r18, 0x80	; 128
 aa4:	19 b1       	in	r17, 0x09	; 9
 aa6:	00 00       	nop
 aa8:	f9 cf       	rjmp	.-14     	; 0xa9c <didUnstuff7>

00000aaa <overflow>:
 aaa:	12 e0       	ldi	r17, 0x02	; 2
 aac:	1c bb       	out	0x1c, r17	; 28

00000aae <ignorePacket>:
 aae:	00 27       	eor	r16, r16
 ab0:	1c c0       	rjmp	.+56     	; 0xaea <storeTokenAndReturn>

00000ab2 <se0>:
 ab2:	3b 50       	subi	r19, 0x0B	; 11
 ab4:	31 95       	neg	r19
 ab6:	c3 1b       	sub	r28, r19
 ab8:	d0 40       	sbci	r29, 0x00	; 0
 aba:	12 e0       	ldi	r17, 0x02	; 2
 abc:	1c bb       	out	0x1c, r17	; 28
 abe:	08 81       	ld	r16, Y
 ac0:	03 3c       	cpi	r16, 0xC3	; 195
 ac2:	11 f1       	breq	.+68     	; 0xb08 <handleData>
 ac4:	0b 34       	cpi	r16, 0x4B	; 75
 ac6:	01 f1       	breq	.+64     	; 0xb08 <handleData>
 ac8:	20 91 27 01 	lds	r18, 0x0127
 acc:	19 81       	ldd	r17, Y+1	; 0x01
 ace:	11 0f       	add	r17, r17
 ad0:	12 13       	cpse	r17, r18
 ad2:	ed cf       	rjmp	.-38     	; 0xaae <ignorePacket>
 ad4:	4a 81       	ldd	r20, Y+2	; 0x02
 ad6:	44 1f       	adc	r20, r20
 ad8:	09 36       	cpi	r16, 0x69	; 105
 ada:	59 f1       	breq	.+86     	; 0xb32 <handleIn>
 adc:	0d 32       	cpi	r16, 0x2D	; 45
 ade:	11 f0       	breq	.+4      	; 0xae4 <handleSetupOrOut>
 ae0:	01 3e       	cpi	r16, 0xE1	; 225
 ae2:	29 f7       	brne	.-54     	; 0xaae <ignorePacket>

00000ae4 <handleSetupOrOut>:
 ae4:	4f 70       	andi	r20, 0x0F	; 15
 ae6:	09 f0       	breq	.+2      	; 0xaea <storeTokenAndReturn>
 ae8:	04 2f       	mov	r16, r20

00000aea <storeTokenAndReturn>:
 aea:	00 93 2e 01 	sts	0x012E, r16

00000aee <doReturn>:
 aee:	3f 91       	pop	r19
 af0:	4f 91       	pop	r20
 af2:	1f 91       	pop	r17
 af4:	0f 91       	pop	r16
 af6:	2f 91       	pop	r18
 af8:	df 91       	pop	r29
 afa:	cc b3       	in	r28, 0x1c	; 28
 afc:	c1 fd       	sbrc	r28, 1
 afe:	4c cf       	rjmp	.-360    	; 0x998 <waitForJ>

00000b00 <sofError>:
 b00:	cf 91       	pop	r28
 b02:	cf bf       	out	0x3f, r28	; 63
 b04:	cf 91       	pop	r28
 b06:	18 95       	reti

00000b08 <handleData>:
 b08:	20 91 2e 01 	lds	r18, 0x012E
 b0c:	22 23       	and	r18, r18
 b0e:	79 f3       	breq	.-34     	; 0xaee <doReturn>
 b10:	10 91 2c 01 	lds	r17, 0x012C
 b14:	11 23       	and	r17, r17
 b16:	69 f5       	brne	.+90     	; 0xb72 <sendNakAndReti>
 b18:	34 30       	cpi	r19, 0x04	; 4
 b1a:	6a f1       	brmi	.+90     	; 0xb76 <sendAckAndReti>
 b1c:	30 93 2c 01 	sts	0x012C, r19
 b20:	20 93 28 01 	sts	0x0128, r18
 b24:	10 91 29 01 	lds	r17, 0x0129
 b28:	3b e0       	ldi	r19, 0x0B	; 11
 b2a:	31 1b       	sub	r19, r17
 b2c:	30 93 29 01 	sts	0x0129, r19
 b30:	22 c0       	rjmp	.+68     	; 0xb76 <sendAckAndReti>

00000b32 <handleIn>:
 b32:	00 91 2c 01 	lds	r16, 0x012C
 b36:	01 30       	cpi	r16, 0x01	; 1
 b38:	e4 f4       	brge	.+56     	; 0xb72 <sendNakAndReti>
 b3a:	0a e5       	ldi	r16, 0x5A	; 90
 b3c:	4f 70       	andi	r20, 0x0F	; 15
 b3e:	49 f4       	brne	.+18     	; 0xb52 <handleIn1>
 b40:	30 91 0c 01 	lds	r19, 0x010C
 b44:	34 fd       	sbrc	r19, 4
 b46:	19 c0       	rjmp	.+50     	; 0xb7a <sendCntAndReti>
 b48:	00 93 0c 01 	sts	0x010C, r16
 b4c:	c0 e1       	ldi	r28, 0x10	; 16
 b4e:	d1 e0       	ldi	r29, 0x01	; 1
 b50:	18 c0       	rjmp	.+48     	; 0xb82 <usbSendAndReti>

00000b52 <handleIn1>:
 b52:	30 91 1b 01 	lds	r19, 0x011B
 b56:	34 fd       	sbrc	r19, 4
 b58:	10 c0       	rjmp	.+32     	; 0xb7a <sendCntAndReti>
 b5a:	00 93 1b 01 	sts	0x011B, r16
 b5e:	cc e1       	ldi	r28, 0x1C	; 28
 b60:	d1 e0       	ldi	r29, 0x01	; 1
 b62:	0f c0       	rjmp	.+30     	; 0xb82 <usbSendAndReti>

00000b64 <stuffN1Delay>:
 b64:	27 95       	ror	r18
 b66:	a8 f4       	brcc	.+42     	; 0xb92 <doExorN1>
 b68:	51 50       	subi	r21, 0x01	; 1
 b6a:	a9 f4       	brne	.+42     	; 0xb96 <commonN1>
 b6c:	22 0f       	add	r18, r18
 b6e:	00 00       	nop
 b70:	f9 cf       	rjmp	.-14     	; 0xb64 <stuffN1Delay>

00000b72 <sendNakAndReti>:
 b72:	4a e5       	ldi	r20, 0x5A	; 90
 b74:	03 c0       	rjmp	.+6      	; 0xb7c <usbSendX3>

00000b76 <sendAckAndReti>:
 b76:	42 ed       	ldi	r20, 0xD2	; 210
 b78:	01 c0       	rjmp	.+2      	; 0xb7c <usbSendX3>

00000b7a <sendCntAndReti>:
 b7a:	43 2f       	mov	r20, r19

00000b7c <usbSendX3>:
 b7c:	c4 e1       	ldi	r28, 0x14	; 20
 b7e:	d0 e0       	ldi	r29, 0x00	; 0
 b80:	32 e0       	ldi	r19, 0x02	; 2

00000b82 <usbSendAndReti>:
 b82:	1a b1       	in	r17, 0x0a	; 10
 b84:	18 61       	ori	r17, 0x18	; 24
 b86:	5c 9a       	sbi	0x0b, 4	; 11
 b88:	1a b9       	out	0x0a, r17	; 10
 b8a:	0b b1       	in	r16, 0x0b	; 11
 b8c:	20 e4       	ldi	r18, 0x40	; 64
 b8e:	18 e1       	ldi	r17, 0x18	; 24
 b90:	5f 93       	push	r21

00000b92 <doExorN1>:
 b92:	01 27       	eor	r16, r17
 b94:	56 e0       	ldi	r21, 0x06	; 6

00000b96 <commonN1>:
 b96:	0b b9       	out	0x0b, r16	; 11
 b98:	27 95       	ror	r18
 b9a:	20 f4       	brcc	.+8      	; 0xba4 <doExorN2>
 b9c:	51 50       	subi	r21, 0x01	; 1
 b9e:	21 f4       	brne	.+8      	; 0xba8 <commonN2>
 ba0:	22 0f       	add	r18, r18
 ba2:	f9 cf       	rjmp	.-14     	; 0xb96 <commonN1>

00000ba4 <doExorN2>:
 ba4:	01 27       	eor	r16, r17
 ba6:	56 e0       	ldi	r21, 0x06	; 6

00000ba8 <commonN2>:
 ba8:	00 00       	nop
 baa:	3b 5a       	subi	r19, 0xAB	; 171
 bac:	0b b9       	out	0x0b, r16	; 11
 bae:	d0 f2       	brcs	.-76     	; 0xb64 <stuffN1Delay>

00000bb0 <stuff6Delay>:
 bb0:	27 95       	ror	r18
 bb2:	28 f4       	brcc	.+10     	; 0xbbe <doExor6>
 bb4:	51 50       	subi	r21, 0x01	; 1
 bb6:	29 f4       	brne	.+10     	; 0xbc2 <common6>
 bb8:	22 0f       	add	r18, r18
 bba:	00 00       	nop
 bbc:	f9 cf       	rjmp	.-14     	; 0xbb0 <stuff6Delay>

00000bbe <doExor6>:
 bbe:	01 27       	eor	r16, r17
 bc0:	56 e0       	ldi	r21, 0x06	; 6

00000bc2 <common6>:
 bc2:	27 95       	ror	r18
 bc4:	0b b9       	out	0x0b, r16	; 11
 bc6:	20 f4       	brcc	.+8      	; 0xbd0 <doExor7>
 bc8:	51 50       	subi	r21, 0x01	; 1
 bca:	21 f4       	brne	.+8      	; 0xbd4 <common7>
 bcc:	22 0f       	add	r18, r18
 bce:	f9 cf       	rjmp	.-14     	; 0xbc2 <common6>

00000bd0 <doExor7>:
 bd0:	01 27       	eor	r16, r17
 bd2:	56 e0       	ldi	r21, 0x06	; 6

00000bd4 <common7>:
 bd4:	29 91       	ld	r18, Y+
 bd6:	33 23       	and	r19, r19
 bd8:	0b b9       	out	0x0b, r16	; 11
 bda:	21 f6       	brne	.-120    	; 0xb64 <stuffN1Delay>
 bdc:	07 7e       	andi	r16, 0xE7	; 231
 bde:	10 91 2d 01 	lds	r17, 0x012D
 be2:	11 0f       	add	r17, r17
 be4:	c6 51       	subi	r28, 0x16	; 22
 be6:	d0 40       	sbci	r29, 0x00	; 0
 be8:	0b b9       	out	0x0b, r16	; 11
 bea:	11 f0       	breq	.+4      	; 0xbf0 <skipAddrAssign>
 bec:	10 93 27 01 	sts	0x0127, r17

00000bf0 <skipAddrAssign>:
 bf0:	12 e0       	ldi	r17, 0x02	; 2
 bf2:	1c bb       	out	0x1c, r17	; 28
 bf4:	00 61       	ori	r16, 0x10	; 16
 bf6:	1a b1       	in	r17, 0x0a	; 10
 bf8:	17 7e       	andi	r17, 0xE7	; 231
 bfa:	40 2f       	mov	r20, r16
 bfc:	47 7e       	andi	r20, 0xE7	; 231
 bfe:	5f 91       	pop	r21
 c00:	00 c0       	rjmp	.+0      	; 0xc02 <skipAddrAssign+0x12>
 c02:	00 c0       	rjmp	.+0      	; 0xc04 <skipAddrAssign+0x14>
 c04:	0b b9       	out	0x0b, r16	; 11
 c06:	1a b9       	out	0x0a, r17	; 10
 c08:	4b b9       	out	0x0b, r20	; 11
 c0a:	71 cf       	rjmp	.-286    	; 0xaee <doReturn>

00000c0c <_exit>:
 c0c:	f8 94       	cli

00000c0e <__stop_program>:
 c0e:	ff cf       	rjmp	.-2      	; 0xc0e <__stop_program>
