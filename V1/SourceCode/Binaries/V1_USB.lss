
V1_USB.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  00001bc0  00001c74  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001bc0  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000004b  00800102  00800102  00001c76  2**0
                  ALLOC
  3 .eeprom       00000172  00810000  00810000  00001c76  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 000000a0  00000000  00000000  00001de8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000035f  00000000  00000000  00001e88  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001a37  00000000  00000000  000021e7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008eb  00000000  00000000  00003c1e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001606  00000000  00000000  00004509  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000180  00000000  00000000  00005b10  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000815  00000000  00000000  00005c90  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000ae9  00000000  00000000  000064a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000100  00000000  00000000  00006f8e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 91 00 	jmp	0x122	; 0x122 <__ctors_end>
       4:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
       8:	0c 94 43 0c 	jmp	0x1886	; 0x1886 <__vector_2>
       c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      10:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      14:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      18:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      1c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      20:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      24:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      28:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      2c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      30:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      34:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      38:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      3c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      40:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      44:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      48:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      4c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      50:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      54:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      58:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      5c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      60:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      64:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>

00000068 <usbDescriptorHidReport>:
      68:	05 01 09 05 a1 01 15 00 25 01 35 00 45 01 75 01     ........%.5.E.u.
      78:	95 0d 05 09 19 01 29 0d 81 02 95 03 81 01 05 01     ......).........
      88:	25 07 46 3b 01 75 04 95 01 65 14 09 39 81 42 65     %.F;.u...e..9.Be
      98:	00 95 01 81 01 26 ff 00 46 ff 00 09 30 09 31 09     .....&..F...0.1.
      a8:	32 09 35 75 08 95 04 81 02 c0                       2.5u......

000000b2 <usbDescriptorString0>:
      b2:	04 03 09 04                                         ....

000000b6 <usbDescriptorStringVendor>:
      b6:	1c 03 4f 00 70 00 65 00 6e 00 43 00 68 00 6f 00     ..O.p.e.n.C.h.o.
      c6:	72 00 64 00 2e 00 6f 00 72 00 67 00                 r.d...o.r.g.

000000d2 <usbDescriptorStringDevice>:
      d2:	14 03 56 00 31 00 20 00 47 00 75 00 69 00 74 00     ..V.1. .G.u.i.t.
      e2:	61 00 72 00                                         a.r.

000000e6 <usbDescriptorDevice>:
      e6:	12 01 10 01 00 00 00 08 ba 12 00 02 00 01 01 02     ................
      f6:	00 01                                               ..

000000f8 <usbDescriptorConfiguration>:
      f8:	09 02 29 00 01 01 00 80 32 09 04 00 00 02 03 00     ..).....2.......
     108:	00 00 09 21 01 01 00 01 22 4a 00 07 05 81 03 08     ...!...."J......
     118:	00 32 07 05 83 03 08 00 32 00                       .2......2.

00000122 <__ctors_end>:
     122:	11 24       	eor	r1, r1
     124:	1f be       	out	0x3f, r1	; 63
     126:	cf ef       	ldi	r28, 0xFF	; 255
     128:	d4 e0       	ldi	r29, 0x04	; 4
     12a:	de bf       	out	0x3e, r29	; 62
     12c:	cd bf       	out	0x3d, r28	; 61

0000012e <__do_copy_data>:
     12e:	11 e0       	ldi	r17, 0x01	; 1
     130:	a0 e0       	ldi	r26, 0x00	; 0
     132:	b1 e0       	ldi	r27, 0x01	; 1
     134:	e0 ec       	ldi	r30, 0xC0	; 192
     136:	fb e1       	ldi	r31, 0x1B	; 27
     138:	02 c0       	rjmp	.+4      	; 0x13e <.do_copy_data_start>

0000013a <.do_copy_data_loop>:
     13a:	05 90       	lpm	r0, Z+
     13c:	0d 92       	st	X+, r0

0000013e <.do_copy_data_start>:
     13e:	a2 30       	cpi	r26, 0x02	; 2
     140:	b1 07       	cpc	r27, r17
     142:	d9 f7       	brne	.-10     	; 0x13a <.do_copy_data_loop>

00000144 <__do_clear_bss>:
     144:	11 e0       	ldi	r17, 0x01	; 1
     146:	a2 e0       	ldi	r26, 0x02	; 2
     148:	b1 e0       	ldi	r27, 0x01	; 1
     14a:	01 c0       	rjmp	.+2      	; 0x14e <.do_clear_bss_start>

0000014c <.do_clear_bss_loop>:
     14c:	1d 92       	st	X+, r1

0000014e <.do_clear_bss_start>:
     14e:	ad 34       	cpi	r26, 0x4D	; 77
     150:	b1 07       	cpc	r27, r17
     152:	e1 f7       	brne	.-8      	; 0x14c <.do_clear_bss_loop>
     154:	0e 94 20 01 	call	0x240	; 0x240 <main>
     158:	0c 94 de 0d 	jmp	0x1bbc	; 0x1bbc <_exit>

0000015c <__bad_interrupt>:
     15c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000160 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
     160:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     162:	f9 99       	sbic	0x1f, 1	; 31
     164:	fe cf       	rjmp	.-4      	; 0x162 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     166:	32 bd       	out	0x22, r19	; 34
     168:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     16a:	f8 9a       	sbi	0x1f, 0	; 31
     16c:	80 b5       	in	r24, 0x20	; 32
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
     16e:	08 95       	ret

00000170 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
     170:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     172:	f9 99       	sbic	0x1f, 1	; 31
     174:	fe cf       	rjmp	.-4      	; 0x172 <eeprom_write_byte+0x2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     176:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     178:	32 bd       	out	0x22, r19	; 34
     17a:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
     17c:	60 bd       	out	0x20, r22	; 32

    __asm__ __volatile__ (
     17e:	0f b6       	in	r0, 0x3f	; 63
     180:	f8 94       	cli
     182:	fa 9a       	sbi	0x1f, 2	; 31
     184:	f9 9a       	sbi	0x1f, 1	; 31
     186:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
     188:	08 95       	ret

0000018a <readFrets>:
};

//readF reads the frets for a single string, and returns an int acting as a boolean array
//  telling which frets are being touched by the string.
int readFrets(int guitarString)
{
     18a:	1f 93       	push	r17
     18c:	cf 93       	push	r28
     18e:	df 93       	push	r29
  	string_port &= ~(1<<guitarString);  // Set the string LOW
     190:	9b b1       	in	r25, 0x0b	; 11
     192:	21 e0       	ldi	r18, 0x01	; 1
     194:	30 e0       	ldi	r19, 0x00	; 0
     196:	02 c0       	rjmp	.+4      	; 0x19c <readFrets+0x12>
     198:	22 0f       	add	r18, r18
     19a:	33 1f       	adc	r19, r19
     19c:	8a 95       	dec	r24
     19e:	e2 f7       	brpl	.-8      	; 0x198 <readFrets+0xe>
     1a0:	12 2f       	mov	r17, r18
     1a2:	82 2f       	mov	r24, r18
     1a4:	80 95       	com	r24
     1a6:	89 23       	and	r24, r25
     1a8:	8b b9       	out	0x0b, r24	; 11
     1aa:	84 e1       	ldi	r24, 0x14	; 20
     1ac:	90 e0       	ldi	r25, 0x00	; 0
	// Macro to as many NOPs as we want
	inline void doXnops(int x)
	{
		while (x >= 0)
		{
			nop();
     1ae:	00 00       	nop
			x--;
     1b0:	01 97       	sbiw	r24, 0x01	; 1
	#define nop() asm volatile("nop")

	// Macro to as many NOPs as we want
	inline void doXnops(int x)
	{
		while (x >= 0)
     1b2:	2f ef       	ldi	r18, 0xFF	; 255
     1b4:	8f 3f       	cpi	r24, 0xFF	; 255
     1b6:	92 07       	cpc	r25, r18
     1b8:	d1 f7       	brne	.-12     	; 0x1ae <readFrets+0x24>

	// Then we have to delay for a while, since right after the switch, the pin values
	// jump around a bit
	doXnops(20);	
	// Read the values on the frets
  	int i = fret_pin;               
     1ba:	83 b1       	in	r24, 0x03	; 3
	i = fret_pin;
     1bc:	83 b1       	in	r24, 0x03	; 3
	i = fret_pin;		// More delay funcitonality... without these delays, there is some bouncing
     1be:	83 b1       	in	r24, 0x03	; 3
	i = fret_pin;		// on the pins, so the read screws up.
     1c0:	83 b1       	in	r24, 0x03	; 3
	// Next, since the fret pin is zero if the a fret is grounded, we do a mask to isolate each pin from 
	//  the port, which will return a zero if pressed and non-zero if unpressed. So we ! that to get a 1 if
	//  the string touches that fret and a zero if it doesn't touch, which we then load into our storage 
	//  integer.

 	stringState |= ( (!(i & (1<<green_pin))) << 1); //green fret
     1c2:	81 fd       	sbrc	r24, 1
     1c4:	03 c0       	rjmp	.+6      	; 0x1cc <readFrets+0x42>
     1c6:	c2 e0       	ldi	r28, 0x02	; 2
     1c8:	d0 e0       	ldi	r29, 0x00	; 0
     1ca:	02 c0       	rjmp	.+4      	; 0x1d0 <readFrets+0x46>
     1cc:	c0 e0       	ldi	r28, 0x00	; 0
     1ce:	d0 e0       	ldi	r29, 0x00	; 0
 	stringState |= ( (!(i & (1<<red_pin))) << 2); //red fret
     1d0:	82 fd       	sbrc	r24, 2
     1d2:	03 c0       	rjmp	.+6      	; 0x1da <readFrets+0x50>
     1d4:	a4 e0       	ldi	r26, 0x04	; 4
     1d6:	b0 e0       	ldi	r27, 0x00	; 0
     1d8:	02 c0       	rjmp	.+4      	; 0x1de <readFrets+0x54>
     1da:	a0 e0       	ldi	r26, 0x00	; 0
     1dc:	b0 e0       	ldi	r27, 0x00	; 0
 	stringState |= ( (!(i & (1<<yellow_pin))) << 3); //yellow fret
     1de:	83 fd       	sbrc	r24, 3
     1e0:	03 c0       	rjmp	.+6      	; 0x1e8 <readFrets+0x5e>
     1e2:	e8 e0       	ldi	r30, 0x08	; 8
     1e4:	f0 e0       	ldi	r31, 0x00	; 0
     1e6:	02 c0       	rjmp	.+4      	; 0x1ec <readFrets+0x62>
     1e8:	e0 e0       	ldi	r30, 0x00	; 0
     1ea:	f0 e0       	ldi	r31, 0x00	; 0
 	stringState |= ( (!(i & (1<<blue_pin))) << 4); //blue fret
     1ec:	84 fd       	sbrc	r24, 4
     1ee:	03 c0       	rjmp	.+6      	; 0x1f6 <readFrets+0x6c>
     1f0:	60 e1       	ldi	r22, 0x10	; 16
     1f2:	70 e0       	ldi	r23, 0x00	; 0
     1f4:	02 c0       	rjmp	.+4      	; 0x1fa <readFrets+0x70>
     1f6:	60 e0       	ldi	r22, 0x00	; 0
     1f8:	70 e0       	ldi	r23, 0x00	; 0
 	stringState |= ( (!(i & (1<<orange_pin))) << 5); //orange fret
     1fa:	85 fd       	sbrc	r24, 5
     1fc:	03 c0       	rjmp	.+6      	; 0x204 <readFrets+0x7a>
     1fe:	40 e2       	ldi	r20, 0x20	; 32
     200:	50 e0       	ldi	r21, 0x00	; 0
     202:	02 c0       	rjmp	.+4      	; 0x208 <readFrets+0x7e>
     204:	40 e0       	ldi	r20, 0x00	; 0
     206:	50 e0       	ldi	r21, 0x00	; 0

	// Also, if we strummed a string, hold that in the 'zeroth' fret
	i = pick_pin;
     208:	26 b1       	in	r18, 0x06	; 6
	//  the port, which will return a zero if pressed and non-zero if unpressed. So we ! that to get a 1 if
	//  the string touches that fret and a zero if it doesn't touch, which we then load into our storage 
	//  integer.

 	stringState |= ( (!(i & (1<<green_pin))) << 1); //green fret
 	stringState |= ( (!(i & (1<<red_pin))) << 2); //red fret
     20a:	30 e0       	ldi	r19, 0x00	; 0
     20c:	36 95       	lsr	r19
     20e:	27 95       	ror	r18
     210:	36 95       	lsr	r19
     212:	27 95       	ror	r18
     214:	20 95       	com	r18
     216:	30 95       	com	r19
     218:	21 70       	andi	r18, 0x01	; 1
     21a:	30 70       	andi	r19, 0x00	; 0
     21c:	2c 2b       	or	r18, r28
     21e:	3d 2b       	or	r19, r29
 	stringState |= ( (!(i & (1<<yellow_pin))) << 3); //yellow fret
     220:	2a 2b       	or	r18, r26
     222:	3b 2b       	or	r19, r27
 	stringState |= ( (!(i & (1<<blue_pin))) << 4); //blue fret
     224:	2e 2b       	or	r18, r30
     226:	3f 2b       	or	r19, r31
 	stringState |= ( (!(i & (1<<orange_pin))) << 5); //orange fret
     228:	26 2b       	or	r18, r22
     22a:	37 2b       	or	r19, r23
	// Also, if we strummed a string, hold that in the 'zeroth' fret
	i = pick_pin;
 	stringState |= ( (!(i & (1<<strum_pin))) << 0); //pick touching the string

	//Turn the string back HIGH and return
	string_port |= (1<<guitarString); 
     22c:	8b b1       	in	r24, 0x0b	; 11
     22e:	18 2b       	or	r17, r24
     230:	1b b9       	out	0x0b, r17	; 11
     232:	24 2b       	or	r18, r20
     234:	35 2b       	or	r19, r21
	return stringState;
}
     236:	c9 01       	movw	r24, r18
     238:	df 91       	pop	r29
     23a:	cf 91       	pop	r28
     23c:	1f 91       	pop	r17
     23e:	08 95       	ret

00000240 <main>:
	 -Under config mode, the loop reads in the values of the strings and frets, assigns that current
	  string-fret combination to correspond to a button press, then locks that combination in when 
	  'Plus' is pressed and moves on to changing the next button.  It also sets the button data structure
	  to display the current controller button being programmed, and then sends that data to the controller.
*/ 
{
     240:	2f 92       	push	r2
     242:	3f 92       	push	r3
     244:	4f 92       	push	r4
     246:	5f 92       	push	r5
     248:	6f 92       	push	r6
     24a:	7f 92       	push	r7
     24c:	8f 92       	push	r8
     24e:	9f 92       	push	r9
     250:	af 92       	push	r10
     252:	bf 92       	push	r11
     254:	cf 92       	push	r12
     256:	df 92       	push	r13
     258:	ef 92       	push	r14
     25a:	ff 92       	push	r15
     25c:	0f 93       	push	r16
     25e:	1f 93       	push	r17
     260:	df 93       	push	r29
     262:	cf 93       	push	r28
     264:	cd b7       	in	r28, 0x3d	; 61
     266:	de b7       	in	r29, 0x3e	; 62
     268:	c5 52       	subi	r28, 0x25	; 37
     26a:	d1 40       	sbci	r29, 0x01	; 1
     26c:	0f b6       	in	r0, 0x3f	; 63
     26e:	f8 94       	cli
     270:	de bf       	out	0x3e, r29	; 62
     272:	0f be       	out	0x3f, r0	; 63
     274:	cd bf       	out	0x3d, r28	; 61
  // Now set up all the communication stuff - initialization routines
  //  set specially in the interface functions - see ps3interface.h, wiiinterface.h, etc.
  startCommunication();
     276:	0e 94 ac 0a 	call	0x1558	; 0x1558 <startCommunication>

	//Debug stuff - the following goes before the while loop in main()
	int timer;
    DDRB |= 1;
     27a:	20 9a       	sbi	0x04, 0	; 4
  // set PORTB for output
  
  uint8_t string[1];
  uint8_t x = 10;
     27c:	8a e0       	ldi	r24, 0x0A	; 10
     27e:	8a 83       	std	Y+2, r24	; 0x02
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
     280:	ce 01       	movw	r24, r28
     282:	01 96       	adiw	r24, 0x01	; 1
     284:	68 e6       	ldi	r22, 0x68	; 104
     286:	71 e0       	ldi	r23, 0x01	; 1
     288:	41 e0       	ldi	r20, 0x01	; 1
     28a:	50 e0       	ldi	r21, 0x00	; 0
     28c:	20 eb       	ldi	r18, 0xB0	; 176
     28e:	30 e0       	ldi	r19, 0x00	; 0
     290:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <__eerd_block>

  eeprom_read_block( (void*)&string, (void*)&nonvolitileString, 1);
  if (string[0] == 50)
     294:	89 81       	ldd	r24, Y+1	; 0x01
     296:	be 01       	movw	r22, r28
     298:	6e 5f       	subi	r22, 0xFE	; 254
     29a:	7f 4f       	sbci	r23, 0xFF	; 255
     29c:	82 33       	cpi	r24, 0x32	; 50
     29e:	11 f4       	brne	.+4      	; 0x2a4 <main+0x64>
  {
  	  x = 250;
     2a0:	8a ef       	ldi	r24, 0xFA	; 250
     2a2:	01 c0       	rjmp	.+2      	; 0x2a6 <main+0x66>
  	  eeprom_write_block( (void*)&x, (void*)&nonvolitileString, 1);
  }
  else
  {
  	  x = 50;
     2a4:	82 e3       	ldi	r24, 0x32	; 50
     2a6:	8a 83       	std	Y+2, r24	; 0x02
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
     2a8:	88 e6       	ldi	r24, 0x68	; 104
     2aa:	91 e0       	ldi	r25, 0x01	; 1
     2ac:	41 e0       	ldi	r20, 0x01	; 1
     2ae:	50 e0       	ldi	r21, 0x00	; 0
     2b0:	28 eb       	ldi	r18, 0xB8	; 184
     2b2:	30 e0       	ldi	r19, 0x00	; 0
     2b4:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <__eewr_block>
  	  eeprom_write_block( (void*)&x, (void*)&nonvolitileString, 1);
  }
  timer = x;

	// First, set up the guitar stuff - These functions are stored in guitarInitFunctions.h/.c
	setPins();
     2b8:	0e 94 70 04 	call	0x8e0	; 0x8e0 <setPins>
	setTimer();	
     2bc:	0e 94 8d 04 	call	0x91a	; 0x91a <setTimer>

    // Declaration of variables used in Main()
	int greenTimers[NUMBER_OF_STRINGS] = {0,0,0,0,0,0}; //These give timing to properly read green buttons on each string.
     2c0:	8c e0       	ldi	r24, 0x0C	; 12
     2c2:	fe 01       	movw	r30, r28
     2c4:	72 96       	adiw	r30, 0x12	; 18
     2c6:	df 01       	movw	r26, r30
     2c8:	98 2f       	mov	r25, r24
     2ca:	1d 92       	st	X+, r1
     2cc:	9a 95       	dec	r25
     2ce:	e9 f7       	brne	.-6      	; 0x2ca <main+0x8a>
	int triedGreen[NUMBER_OF_STRINGS] = {0,0,0,0,0,0};  // Also used for the green button timing thing
     2d0:	fe 01       	movw	r30, r28
     2d2:	7e 96       	adiw	r30, 0x1e	; 30
     2d4:	df 01       	movw	r26, r30
     2d6:	98 2f       	mov	r25, r24
     2d8:	1d 92       	st	X+, r1
     2da:	9a 95       	dec	r25
     2dc:	e9 f7       	brne	.-6      	; 0x2d8 <main+0x98>
	int stringState[6] = {0,0,0,0,0,0}; // This stores an int for each string,
     2de:	fe 01       	movw	r30, r28
     2e0:	ba 96       	adiw	r30, 0x2a	; 42
     2e2:	df 01       	movw	r26, r30
     2e4:	1d 92       	st	X+, r1
     2e6:	8a 95       	dec	r24
     2e8:	e9 f7       	brne	.-6      	; 0x2e4 <main+0xa4>
																	 // controller compares the string presses
																	 // to in order to judge if a button is being
																	 // pressed. It's the size of all the chord combinations,
																	 // but in Note Mode, only the first 5 blocks get looked at. 
	char configMode = 0; // Start in normal mode
	int buttonToAssign = 0; // declare some variables
     2ea:	1e 82       	std	Y+6, r1	; 0x06
     2ec:	1d 82       	std	Y+5, r1	; 0x05
	char plusLock = 0;
     2ee:	1b 82       	std	Y+3, r1	; 0x03
	char previousPlusOn = 0; // This is used as a lock so we don't program all the buttons at once
     2f0:	1c 82       	std	Y+4, r1	; 0x04
	int debounceTimer = 0; // This is used as a global timer for debouncing buttons
     2f2:	18 86       	std	Y+8, r1	; 0x08
     2f4:	1f 82       	std	Y+7, r1	; 0x07
		char minusOn;
	} dataForController;

	inline void clearData(dataForController* data)
	{
		data->orangeOn = 0;
     2f6:	1d 86       	std	Y+13, r1	; 0x0d
		data->blueOn   = 0;
     2f8:	1c 86       	std	Y+12, r1	; 0x0c
		data->yellowOn = 0;
     2fa:	1b 86       	std	Y+11, r1	; 0x0b
		data->redOn    = 0;
     2fc:	1a 86       	std	Y+10, r1	; 0x0a
		data->greenOn  = 0;
     2fe:	19 86       	std	Y+9, r1	; 0x09
		data->upOn     = 0;
     300:	1e 86       	std	Y+14, r1	; 0x0e
		data->downOn   = 0;
     302:	1f 86       	std	Y+15, r1	; 0x0f
		data->plusOn   = 0;
     304:	18 8a       	std	Y+16, r1	; 0x10
		data->minusOn  = 0;
     306:	19 8a       	std	Y+17, r1	; 0x11
	
	dataForController data;
	clearData(&data); //This function is contained in V1Typedefs.h

	//Debug Stuff - it's complementary code is in ps3interface.h and .c
	DDRC &= ~(1<<5); //Turn 5 on Port C to inputs
     308:	3d 98       	cbi	0x07, 5	; 7
	PORTC |= (1<<5); //Turn off the internal pullup resistor on pin 5
     30a:	45 9a       	sbi	0x08, 5	; 8
     30c:	66 24       	eor	r6, r6
     30e:	77 24       	eor	r7, r7
	// array as something big enough for all 21 chord mode combinations, but we
	// only write the first 5 patterns when we write these ones to EEPROM
	int buttonStringPatterns[NUM_CHORDS_BUTTONS][NUMBER_OF_STRINGS];

    buttonStringPatterns[0][0] = 0b0000000; // [0][0] through [0][5] - green button
    buttonStringPatterns[0][0] = 0x0000000; // [0][0] through [0][5] - green button
     310:	ee ea       	ldi	r30, 0xAE	; 174
     312:	8e 2e       	mov	r8, r30
     314:	91 2c       	mov	r9, r1
     316:	8c 0e       	add	r8, r28
     318:	9d 1e       	adc	r9, r29
	buttonStringPatterns[2][0] = 0;	buttonStringPatterns[2][1] = 0;
	buttonStringPatterns[2][2] = 0;	buttonStringPatterns[2][3] = 0;
	buttonStringPatterns[2][4] = 0;	buttonStringPatterns[2][5] = 0;
	buttonStringPatterns[3][0] = 0;	buttonStringPatterns[3][1] = 0;
	buttonStringPatterns[3][2] = 0;	buttonStringPatterns[3][3] = 0;
	buttonStringPatterns[3][4] = 0;	buttonStringPatterns[3][5] = 0;
     31a:	74 e6       	ldi	r23, 0x64	; 100
     31c:	27 2e       	mov	r2, r23
     31e:	31 2c       	mov	r3, r1
     320:	2c 0e       	add	r2, r28
     322:	3d 1e       	adc	r3, r29
    while(1){  
	              /* main event loop */
		
		// We first read all the strings for button hits and store them into
		//  our stringState array.  Strum processing is also handled here for now.
        stringState[0] = readFrets(first_string);
     324:	87 e0       	ldi	r24, 0x07	; 7
     326:	90 e0       	ldi	r25, 0x00	; 0
     328:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     32c:	9b a7       	std	Y+43, r25	; 0x2b
     32e:	8a a7       	std	Y+42, r24	; 0x2a
		stringState[1] = readFrets(second_string);
     330:	86 e0       	ldi	r24, 0x06	; 6
     332:	90 e0       	ldi	r25, 0x00	; 0
     334:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     338:	9d a7       	std	Y+45, r25	; 0x2d
     33a:	8c a7       	std	Y+44, r24	; 0x2c
		stringState[2] = readFrets(third_string);
     33c:	85 e0       	ldi	r24, 0x05	; 5
     33e:	90 e0       	ldi	r25, 0x00	; 0
     340:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     344:	9f a7       	std	Y+47, r25	; 0x2f
     346:	8e a7       	std	Y+46, r24	; 0x2e
		stringState[3] = readFrets(fourth_string);
     348:	82 e0       	ldi	r24, 0x02	; 2
     34a:	90 e0       	ldi	r25, 0x00	; 0
     34c:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     350:	99 ab       	std	Y+49, r25	; 0x31
     352:	88 ab       	std	Y+48, r24	; 0x30
		stringState[4] = readFrets(fifth_string);
     354:	81 e0       	ldi	r24, 0x01	; 1
     356:	90 e0       	ldi	r25, 0x00	; 0
     358:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     35c:	9b ab       	std	Y+51, r25	; 0x33
     35e:	8a ab       	std	Y+50, r24	; 0x32
		stringState[5] = readFrets(sixth_string);
     360:	80 e0       	ldi	r24, 0x00	; 0
     362:	90 e0       	ldi	r25, 0x00	; 0
     364:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     368:	9c 01       	movw	r18, r24
     36a:	9d ab       	std	Y+53, r25	; 0x35
     36c:	8c ab       	std	Y+52, r24	; 0x34
		char minusOn;
	} dataForController;

	inline void clearData(dataForController* data)
	{
		data->orangeOn = 0;
     36e:	1d 86       	std	Y+13, r1	; 0x0d
		data->blueOn   = 0;
     370:	1c 86       	std	Y+12, r1	; 0x0c
		data->yellowOn = 0;
     372:	1b 86       	std	Y+11, r1	; 0x0b
		data->redOn    = 0;
     374:	1a 86       	std	Y+10, r1	; 0x0a
		data->greenOn  = 0;
     376:	19 86       	std	Y+9, r1	; 0x09
		data->upOn     = 0;
     378:	1e 86       	std	Y+14, r1	; 0x0e
		data->downOn   = 0;
     37a:	1f 86       	std	Y+15, r1	; 0x0f
		data->plusOn   = 0;
     37c:	18 8a       	std	Y+16, r1	; 0x10
		data->minusOn  = 0;
     37e:	19 8a       	std	Y+17, r1	; 0x11
		return 0;
}

inline int testForResetButtonPatterns(int stringState[])
{
	if ((stringState[0] == 0b00000010) &&
     380:	8a a5       	ldd	r24, Y+42	; 0x2a
     382:	9b a5       	ldd	r25, Y+43	; 0x2b
     384:	02 97       	sbiw	r24, 0x02	; 2
     386:	09 f0       	breq	.+2      	; 0x38a <main+0x14a>
     388:	e7 c0       	rjmp	.+462    	; 0x558 <__stack+0x59>
     38a:	8c a5       	ldd	r24, Y+44	; 0x2c
     38c:	9d a5       	ldd	r25, Y+45	; 0x2d
     38e:	0c 97       	sbiw	r24, 0x0c	; 12
     390:	09 f0       	breq	.+2      	; 0x394 <main+0x154>
     392:	e2 c0       	rjmp	.+452    	; 0x558 <__stack+0x59>
     394:	8e a5       	ldd	r24, Y+46	; 0x2e
     396:	9f a5       	ldd	r25, Y+47	; 0x2f
     398:	02 97       	sbiw	r24, 0x02	; 2
     39a:	09 f0       	breq	.+2      	; 0x39e <main+0x15e>
     39c:	dd c0       	rjmp	.+442    	; 0x558 <__stack+0x59>
     39e:	88 a9       	ldd	r24, Y+48	; 0x30
     3a0:	99 a9       	ldd	r25, Y+49	; 0x31
     3a2:	0c 97       	sbiw	r24, 0x0c	; 12
     3a4:	09 f0       	breq	.+2      	; 0x3a8 <main+0x168>
     3a6:	d8 c0       	rjmp	.+432    	; 0x558 <__stack+0x59>
     3a8:	4a a9       	ldd	r20, Y+50	; 0x32
     3aa:	5b a9       	ldd	r21, Y+51	; 0x33
     3ac:	42 30       	cpi	r20, 0x02	; 2
     3ae:	51 05       	cpc	r21, r1
     3b0:	09 f0       	breq	.+2      	; 0x3b4 <main+0x174>
     3b2:	d2 c0       	rjmp	.+420    	; 0x558 <__stack+0x59>
     3b4:	2c 30       	cpi	r18, 0x0C	; 12
     3b6:	31 05       	cpc	r19, r1
     3b8:	09 f0       	breq	.+2      	; 0x3bc <main+0x17c>
     3ba:	ce c0       	rjmp	.+412    	; 0x558 <__stack+0x59>
     3bc:	f4 01       	movw	r30, r8
     3be:	11 82       	std	Z+1, r1	; 0x01
     3c0:	10 82       	st	Z, r1
	buttonStringPatterns[0][1] = 0b0001100; 
     3c2:	33 83       	std	Z+3, r19	; 0x03
     3c4:	22 83       	std	Z+2, r18	; 0x02
	buttonStringPatterns[0][2] = 0b0000000;	
     3c6:	15 82       	std	Z+5, r1	; 0x05
     3c8:	14 82       	std	Z+4, r1	; 0x04
	buttonStringPatterns[0][3] = 0b0000110;
     3ca:	06 e0       	ldi	r16, 0x06	; 6
     3cc:	10 e0       	ldi	r17, 0x00	; 0
     3ce:	17 83       	std	Z+7, r17	; 0x07
     3d0:	06 83       	std	Z+6, r16	; 0x06
	buttonStringPatterns[0][4] = 0b0000000;
     3d2:	11 86       	std	Z+9, r1	; 0x09
     3d4:	10 86       	std	Z+8, r1	; 0x08
	buttonStringPatterns[0][5] = 0b0000010;
     3d6:	53 87       	std	Z+11, r21	; 0x0b
     3d8:	42 87       	std	Z+10, r20	; 0x0a

	buttonStringPatterns[1][0] = 0b0000010; // [1][0] through [1][5] - red button
     3da:	55 87       	std	Z+13, r21	; 0x0d
     3dc:	44 87       	std	Z+12, r20	; 0x0c
	buttonStringPatterns[1][1] = 0b0000000; 
     3de:	17 86       	std	Z+15, r1	; 0x0f
     3e0:	16 86       	std	Z+14, r1	; 0x0e
	buttonStringPatterns[1][2] = 0b0000001;
     3e2:	81 e0       	ldi	r24, 0x01	; 1
     3e4:	90 e0       	ldi	r25, 0x00	; 0
     3e6:	91 8b       	std	Z+17, r25	; 0x11
     3e8:	80 8b       	std	Z+16, r24	; 0x10
	buttonStringPatterns[1][3] = 0b0000000;
     3ea:	13 8a       	std	Z+19, r1	; 0x13
     3ec:	12 8a       	std	Z+18, r1	; 0x12
	buttonStringPatterns[1][4] = 0b0000001;
     3ee:	95 8b       	std	Z+21, r25	; 0x15
     3f0:	84 8b       	std	Z+20, r24	; 0x14
	buttonStringPatterns[1][5] = 0b0001100;
     3f2:	37 8b       	std	Z+23, r19	; 0x17
     3f4:	26 8b       	std	Z+22, r18	; 0x16

	buttonStringPatterns[2][0] = 0b0001100; // [2][0] through [2][5] - yellow button
     3f6:	31 8f       	std	Z+25, r19	; 0x19
     3f8:	20 8f       	std	Z+24, r18	; 0x18
	buttonStringPatterns[2][1] = 0b0000000; // This is an A chord.
     3fa:	13 8e       	std	Z+27, r1	; 0x1b
     3fc:	12 8e       	std	Z+26, r1	; 0x1a
	buttonStringPatterns[2][2] = 0b0000110;
     3fe:	15 8f       	std	Z+29, r17	; 0x1d
     400:	04 8f       	std	Z+28, r16	; 0x1c
	buttonStringPatterns[2][3] = 0b0000000;
     402:	17 8e       	std	Z+31, r1	; 0x1f
     404:	16 8e       	std	Z+30, r1	; 0x1e
	buttonStringPatterns[2][4] = 0b0000010;
     406:	51 a3       	std	Z+33, r21	; 0x21
     408:	40 a3       	std	Z+32, r20	; 0x20
	buttonStringPatterns[2][5] = 0b0000000;
     40a:	13 a2       	std	Z+35, r1	; 0x23
     40c:	12 a2       	std	Z+34, r1	; 0x22
							  
	buttonStringPatterns[3][0] = 0b0000000; // [3][0] through [3][5] - blue button
     40e:	15 a2       	std	Z+37, r1	; 0x25
     410:	14 a2       	std	Z+36, r1	; 0x24
	buttonStringPatterns[3][1] = 0b0000001; 
     412:	97 a3       	std	Z+39, r25	; 0x27
     414:	86 a3       	std	Z+38, r24	; 0x26
	buttonStringPatterns[3][2] = 0b0001100;
     416:	31 a7       	std	Z+41, r19	; 0x29
     418:	20 a7       	std	Z+40, r18	; 0x28
	buttonStringPatterns[3][3] = 0b0000000;
     41a:	13 a6       	std	Z+43, r1	; 0x2b
     41c:	12 a6       	std	Z+42, r1	; 0x2a
	buttonStringPatterns[3][4] = 0b0001100;
     41e:	35 a7       	std	Z+45, r19	; 0x2d
     420:	24 a7       	std	Z+44, r18	; 0x2c
	buttonStringPatterns[3][5] = 0b0000000;
     422:	17 a6       	std	Z+47, r1	; 0x2f
     424:	16 a6       	std	Z+46, r1	; 0x2e

	buttonStringPatterns[4][0] = 0b0000000; // [4][0] through [4][5] - orange button
     426:	11 aa       	std	Z+49, r1	; 0x31
     428:	10 aa       	std	Z+48, r1	; 0x30
	buttonStringPatterns[4][1] = 0b0000110; 
     42a:	13 ab       	std	Z+51, r17	; 0x33
     42c:	02 ab       	std	Z+50, r16	; 0x32
	buttonStringPatterns[4][2] = 0b0000000;
     42e:	15 aa       	std	Z+53, r1	; 0x35
     430:	14 aa       	std	Z+52, r1	; 0x34
	buttonStringPatterns[4][3] = 0b0000001;
     432:	97 ab       	std	Z+55, r25	; 0x37
     434:	86 ab       	std	Z+54, r24	; 0x36
	buttonStringPatterns[4][4] = 0b0000000;
     436:	11 ae       	std	Z+57, r1	; 0x39
     438:	10 ae       	std	Z+56, r1	; 0x38
	buttonStringPatterns[4][5] = 0b0000001;
     43a:	93 af       	std	Z+59, r25	; 0x3b
     43c:	82 af       	std	Z+58, r24	; 0x3a
     43e:	80 e0       	ldi	r24, 0x00	; 0
     440:	90 e0       	ldi	r25, 0x00	; 0
     442:	b4 01       	movw	r22, r8
     444:	4c e3       	ldi	r20, 0x3C	; 60
     446:	50 e0       	ldi	r21, 0x00	; 0
     448:	28 eb       	ldi	r18, 0xB8	; 184
     44a:	30 e0       	ldi	r19, 0x00	; 0
     44c:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <__eewr_block>

	eeprom_write_block( (void*)&buttonStringPatterns, notesAddress, EEPROM_NOTES_BLOCK_SIZE);


	// Now write the default chord mapping
	buttonStringPatterns[0][0] = 0b0001110; // [0][0] through [0][5] - green button
     450:	8e e0       	ldi	r24, 0x0E	; 14
     452:	90 e0       	ldi	r25, 0x00	; 0
     454:	d4 01       	movw	r26, r8
     456:	11 96       	adiw	r26, 0x01	; 1
     458:	9c 93       	st	X, r25
     45a:	8e 93       	st	-X, r24
	buttonStringPatterns[0][1] = 0b0001110; // This is a G Chord
     45c:	13 96       	adiw	r26, 0x03	; 3
     45e:	9c 93       	st	X, r25
     460:	8e 93       	st	-X, r24
     462:	12 97       	sbiw	r26, 0x02	; 2
	buttonStringPatterns[0][2] = 0b0000000;	
     464:	15 96       	adiw	r26, 0x05	; 5
     466:	1c 92       	st	X, r1
     468:	1e 92       	st	-X, r1
     46a:	14 97       	sbiw	r26, 0x04	; 4
	buttonStringPatterns[0][3] = 0b0000000;
     46c:	17 96       	adiw	r26, 0x07	; 7
     46e:	1c 92       	st	X, r1
     470:	1e 92       	st	-X, r1
     472:	16 97       	sbiw	r26, 0x06	; 6
	buttonStringPatterns[0][4] = 0b0000000;
     474:	19 96       	adiw	r26, 0x09	; 9
     476:	1c 92       	st	X, r1
     478:	1e 92       	st	-X, r1
     47a:	18 97       	sbiw	r26, 0x08	; 8
	buttonStringPatterns[0][5] = 0b0001110;
     47c:	1b 96       	adiw	r26, 0x0b	; 11
     47e:	9c 93       	st	X, r25
     480:	8e 93       	st	-X, r24
     482:	1a 97       	sbiw	r26, 0x0a	; 10

	buttonStringPatterns[1][0] = 0b0000000; // [1][0] through [1][5] - red button
     484:	1d 96       	adiw	r26, 0x0d	; 13
     486:	1c 92       	st	X, r1
     488:	1e 92       	st	-X, r1
     48a:	1c 97       	sbiw	r26, 0x0c	; 12
	buttonStringPatterns[1][1] = 0b0001110; // This is a C chord
     48c:	1f 96       	adiw	r26, 0x0f	; 15
     48e:	9c 93       	st	X, r25
     490:	8e 93       	st	-X, r24
     492:	1e 97       	sbiw	r26, 0x0e	; 14
	buttonStringPatterns[1][2] = 0b0001110;
     494:	51 96       	adiw	r26, 0x11	; 17
     496:	9c 93       	st	X, r25
     498:	8e 93       	st	-X, r24
     49a:	50 97       	sbiw	r26, 0x10	; 16
	buttonStringPatterns[1][3] = 0b0000000;
     49c:	53 96       	adiw	r26, 0x13	; 19
     49e:	1c 92       	st	X, r1
     4a0:	1e 92       	st	-X, r1
     4a2:	52 97       	sbiw	r26, 0x12	; 18
	buttonStringPatterns[1][4] = 0b0001110;
     4a4:	55 96       	adiw	r26, 0x15	; 21
     4a6:	9c 93       	st	X, r25
     4a8:	8e 93       	st	-X, r24
     4aa:	54 97       	sbiw	r26, 0x14	; 20
	buttonStringPatterns[1][5] = 0b0000000;
     4ac:	57 96       	adiw	r26, 0x17	; 23
     4ae:	1c 92       	st	X, r1
     4b0:	1e 92       	st	-X, r1
     4b2:	56 97       	sbiw	r26, 0x16	; 22

	buttonStringPatterns[2][0] = 0b0000000; // [2][0] through [2][5] - yellow button
     4b4:	59 96       	adiw	r26, 0x19	; 25
     4b6:	1c 92       	st	X, r1
     4b8:	1e 92       	st	-X, r1
     4ba:	58 97       	sbiw	r26, 0x18	; 24
	buttonStringPatterns[2][1] = 0b0000110; // This is an E chord.
     4bc:	5b 96       	adiw	r26, 0x1b	; 27
     4be:	1c 93       	st	X, r17
     4c0:	0e 93       	st	-X, r16
     4c2:	5a 97       	sbiw	r26, 0x1a	; 26
	buttonStringPatterns[2][2] = 0b0000110;
     4c4:	5d 96       	adiw	r26, 0x1d	; 29
     4c6:	1c 93       	st	X, r17
     4c8:	0e 93       	st	-X, r16
     4ca:	5c 97       	sbiw	r26, 0x1c	; 28
	buttonStringPatterns[2][3] = 0b0000110;
     4cc:	5f 96       	adiw	r26, 0x1f	; 31
     4ce:	1c 93       	st	X, r17
     4d0:	0e 93       	st	-X, r16
     4d2:	5e 97       	sbiw	r26, 0x1e	; 30
	buttonStringPatterns[2][4] = 0b0000000;
     4d4:	91 96       	adiw	r26, 0x21	; 33
     4d6:	1c 92       	st	X, r1
     4d8:	1e 92       	st	-X, r1
     4da:	90 97       	sbiw	r26, 0x20	; 32
	buttonStringPatterns[2][5] = 0b0000000;
     4dc:	93 96       	adiw	r26, 0x23	; 35
     4de:	1c 92       	st	X, r1
     4e0:	1e 92       	st	-X, r1
     4e2:	92 97       	sbiw	r26, 0x22	; 34
									  
	buttonStringPatterns[3][0] = 0b0000000; // [3][0] through [3][5] - blue button
     4e4:	95 96       	adiw	r26, 0x25	; 37
     4e6:	1c 92       	st	X, r1
     4e8:	1e 92       	st	-X, r1
     4ea:	94 97       	sbiw	r26, 0x24	; 36
	buttonStringPatterns[3][1] = 0b0000000; // This an A chord
     4ec:	97 96       	adiw	r26, 0x27	; 39
     4ee:	1c 92       	st	X, r1
     4f0:	1e 92       	st	-X, r1
     4f2:	96 97       	sbiw	r26, 0x26	; 38
	buttonStringPatterns[3][2] = 0b0000110;
     4f4:	99 96       	adiw	r26, 0x29	; 41
     4f6:	1c 93       	st	X, r17
     4f8:	0e 93       	st	-X, r16
     4fa:	98 97       	sbiw	r26, 0x28	; 40
	buttonStringPatterns[3][3] = 0b0000110;
     4fc:	9b 96       	adiw	r26, 0x2b	; 43
     4fe:	1c 93       	st	X, r17
     500:	0e 93       	st	-X, r16
     502:	9a 97       	sbiw	r26, 0x2a	; 42
	buttonStringPatterns[3][4] = 0b0000110;
     504:	9d 96       	adiw	r26, 0x2d	; 45
     506:	1c 93       	st	X, r17
     508:	0e 93       	st	-X, r16
     50a:	9c 97       	sbiw	r26, 0x2c	; 44
	buttonStringPatterns[3][5] = 0b0000000;
     50c:	9f 96       	adiw	r26, 0x2f	; 47
     50e:	1c 92       	st	X, r1
     510:	1e 92       	st	-X, r1
     512:	9e 97       	sbiw	r26, 0x2e	; 46

	buttonStringPatterns[4][0] = 0b0000000; // [4][0] through [4][5] - blue button
     514:	d1 96       	adiw	r26, 0x31	; 49
     516:	1c 92       	st	X, r1
     518:	1e 92       	st	-X, r1
     51a:	d0 97       	sbiw	r26, 0x30	; 48
	buttonStringPatterns[4][1] = 0b0000000;	// This is a D chord 
     51c:	d3 96       	adiw	r26, 0x33	; 51
     51e:	1c 92       	st	X, r1
     520:	1e 92       	st	-X, r1
     522:	d2 97       	sbiw	r26, 0x32	; 50
	buttonStringPatterns[4][2] = 0b0000000;
     524:	d5 96       	adiw	r26, 0x35	; 53
     526:	1c 92       	st	X, r1
     528:	1e 92       	st	-X, r1
     52a:	d4 97       	sbiw	r26, 0x34	; 52
	buttonStringPatterns[4][3] = 0b0001110;
     52c:	d7 96       	adiw	r26, 0x37	; 55
     52e:	9c 93       	st	X, r25
     530:	8e 93       	st	-X, r24
     532:	d6 97       	sbiw	r26, 0x36	; 54
	buttonStringPatterns[4][4] = 0b0001110;
     534:	d9 96       	adiw	r26, 0x39	; 57
     536:	9c 93       	st	X, r25
     538:	8e 93       	st	-X, r24
     53a:	d8 97       	sbiw	r26, 0x38	; 56
	buttonStringPatterns[4][5] = 0b0001110;
     53c:	db 96       	adiw	r26, 0x3b	; 59
     53e:	9c 93       	st	X, r25
     540:	8e 93       	st	-X, r24
     542:	da 97       	sbiw	r26, 0x3a	; 58
     544:	88 e7       	ldi	r24, 0x78	; 120
     546:	90 e0       	ldi	r25, 0x00	; 0
     548:	b4 01       	movw	r22, r8
     54a:	48 e7       	ldi	r20, 0x78	; 120
     54c:	50 e0       	ldi	r21, 0x00	; 0
     54e:	28 eb       	ldi	r18, 0xB8	; 184
     550:	30 e0       	ldi	r19, 0x00	; 0
     552:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <__eewr_block>
     556:	77 24       	eor	r7, r7

// This function just reads our plus and minus buttons and sets the data struct accordingly
inline void readOtherButtons(dataForController* data)
{
	// read our plus and minus buttons
	int i = misc_pin; // check for plus and minus
     558:	86 b1       	in	r24, 0x06	; 6
     55a:	90 e0       	ldi	r25, 0x00	; 0
	data->plusOn = !(i & (1<<plus_pin)); //Plus and minus are held high normally, but pressing it drops it low
     55c:	41 e0       	ldi	r20, 0x01	; 1
     55e:	50 e0       	ldi	r21, 0x00	; 0
     560:	9c 01       	movw	r18, r24
     562:	24 27       	eor	r18, r20
     564:	35 27       	eor	r19, r21
     566:	21 70       	andi	r18, 0x01	; 1
     568:	28 8b       	std	Y+16, r18	; 0x10
	data->minusOn = !(i & (1<<minus_pin));
     56a:	96 95       	lsr	r25
     56c:	87 95       	ror	r24
     56e:	84 27       	eor	r24, r20
     570:	95 27       	eor	r25, r21
     572:	81 70       	andi	r24, 0x01	; 1
     574:	89 8b       	std	Y+17, r24	; 0x11
		return 0;
}

inline int testForMinusChord(int stringState[])
{
	if ((stringState[0] == 0b00011110) &&
     576:	2a a5       	ldd	r18, Y+42	; 0x2a
     578:	3b a5       	ldd	r19, Y+43	; 0x2b
     57a:	2e 31       	cpi	r18, 0x1E	; 30
     57c:	31 05       	cpc	r19, r1
     57e:	b1 f4       	brne	.+44     	; 0x5ac <__stack+0xad>
     580:	8c a5       	ldd	r24, Y+44	; 0x2c
     582:	9d a5       	ldd	r25, Y+45	; 0x2d
     584:	4e 97       	sbiw	r24, 0x1e	; 30
     586:	91 f4       	brne	.+36     	; 0x5ac <__stack+0xad>
     588:	8e a5       	ldd	r24, Y+46	; 0x2e
     58a:	9f a5       	ldd	r25, Y+47	; 0x2f
     58c:	4e 97       	sbiw	r24, 0x1e	; 30
     58e:	71 f4       	brne	.+28     	; 0x5ac <__stack+0xad>
     590:	88 a9       	ldd	r24, Y+48	; 0x30
     592:	99 a9       	ldd	r25, Y+49	; 0x31
     594:	4e 97       	sbiw	r24, 0x1e	; 30
     596:	51 f4       	brne	.+20     	; 0x5ac <__stack+0xad>
     598:	8a a9       	ldd	r24, Y+50	; 0x32
     59a:	9b a9       	ldd	r25, Y+51	; 0x33
     59c:	4e 97       	sbiw	r24, 0x1e	; 30
     59e:	31 f4       	brne	.+12     	; 0x5ac <__stack+0xad>
     5a0:	8c a9       	ldd	r24, Y+52	; 0x34
     5a2:	9d a9       	ldd	r25, Y+53	; 0x35
     5a4:	4e 97       	sbiw	r24, 0x1e	; 30
     5a6:	11 f4       	brne	.+4      	; 0x5ac <__stack+0xad>
		// Now read our other buttons, like plus and minus
		readOtherButtons(&data);

		//Test if Minus is being played by the chord instead of the button
		if(testForMinusChord(stringState))
			data.minusOn = 1;
     5a8:	81 e0       	ldi	r24, 0x01	; 1
     5aa:	89 8b       	std	Y+17, r24	; 0x11
		
		if ((controllerMode == NOTES) || (controllerMode == CHORDS))
     5ac:	b2 e0       	ldi	r27, 0x02	; 2
     5ae:	7b 16       	cp	r7, r27
     5b0:	21 f0       	breq	.+8      	; 0x5ba <__stack+0xbb>
     5b2:	e4 e0       	ldi	r30, 0x04	; 4
     5b4:	7e 16       	cp	r7, r30
     5b6:	09 f0       	breq	.+2      	; 0x5ba <__stack+0xbb>
     5b8:	ee c0       	rjmp	.+476    	; 0x796 <__stack+0x297>
		{
			// Check to see if we're trying to enter Config Mode; disabled if we're playing with frets
			if (configMode == 0)
     5ba:	66 20       	and	r6, r6
     5bc:	09 f0       	breq	.+2      	; 0x5c0 <__stack+0xc1>
     5be:	94 c0       	rjmp	.+296    	; 0x6e8 <__stack+0x1e9>

// This function tests to see if you're pressing the top 4 strings on the orange fret,
//  thereby activating config mode. Works with both chords and scales.
inline char testForConfigMode(int stringState[])
{
	if ((stringState[0] == 0b00000000) &&
     5c0:	21 15       	cp	r18, r1
     5c2:	31 05       	cpc	r19, r1
     5c4:	09 f0       	breq	.+2      	; 0x5c8 <__stack+0xc9>
     5c6:	8d c0       	rjmp	.+282    	; 0x6e2 <__stack+0x1e3>
     5c8:	8c a5       	ldd	r24, Y+44	; 0x2c
     5ca:	9d a5       	ldd	r25, Y+45	; 0x2d
     5cc:	89 2b       	or	r24, r25
     5ce:	09 f0       	breq	.+2      	; 0x5d2 <__stack+0xd3>
     5d0:	88 c0       	rjmp	.+272    	; 0x6e2 <__stack+0x1e3>
     5d2:	8e a5       	ldd	r24, Y+46	; 0x2e
     5d4:	9f a5       	ldd	r25, Y+47	; 0x2f
     5d6:	89 2b       	or	r24, r25
     5d8:	09 f0       	breq	.+2      	; 0x5dc <__stack+0xdd>
     5da:	83 c0       	rjmp	.+262    	; 0x6e2 <__stack+0x1e3>
     5dc:	88 a9       	ldd	r24, Y+48	; 0x30
     5de:	99 a9       	ldd	r25, Y+49	; 0x31
     5e0:	48 97       	sbiw	r24, 0x18	; 24
     5e2:	09 f0       	breq	.+2      	; 0x5e6 <__stack+0xe7>
     5e4:	7e c0       	rjmp	.+252    	; 0x6e2 <__stack+0x1e3>
     5e6:	8a a9       	ldd	r24, Y+50	; 0x32
     5e8:	9b a9       	ldd	r25, Y+51	; 0x33
     5ea:	48 97       	sbiw	r24, 0x18	; 24
     5ec:	09 f0       	breq	.+2      	; 0x5f0 <__stack+0xf1>
     5ee:	79 c0       	rjmp	.+242    	; 0x6e2 <__stack+0x1e3>
     5f0:	8c a9       	ldd	r24, Y+52	; 0x34
     5f2:	9d a9       	ldd	r25, Y+53	; 0x35
     5f4:	48 97       	sbiw	r24, 0x18	; 24
     5f6:	09 f0       	breq	.+2      	; 0x5fa <__stack+0xfb>
     5f8:	74 c0       	rjmp	.+232    	; 0x6e2 <__stack+0x1e3>
			{
				configMode = testForConfigMode(stringState);
				
				// If we're playing with notes, when we enter config mode, we need to clear the 
				//  button string patterns once so we can rebuild them.
				if (configMode == 1 && controllerMode == NOTES)
     5fa:	f2 e0       	ldi	r31, 0x02	; 2
     5fc:	7f 16       	cp	r7, r31
     5fe:	09 f0       	breq	.+2      	; 0x602 <__stack+0x103>
     600:	6e c0       	rjmp	.+220    	; 0x6de <__stack+0x1df>
	return stringState;
}

inline void clearButtonStringPatterns(int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
	buttonStringPatterns[0][0] = 0;	buttonStringPatterns[0][1] = 0;
     602:	1f aa       	std	Y+55, r1	; 0x37
     604:	1e aa       	std	Y+54, r1	; 0x36
     606:	19 ae       	std	Y+57, r1	; 0x39
     608:	18 ae       	std	Y+56, r1	; 0x38
	buttonStringPatterns[0][2] = 0;	buttonStringPatterns[0][3] = 0;
     60a:	1b ae       	std	Y+59, r1	; 0x3b
     60c:	1a ae       	std	Y+58, r1	; 0x3a
     60e:	1d ae       	std	Y+61, r1	; 0x3d
     610:	1c ae       	std	Y+60, r1	; 0x3c
	buttonStringPatterns[0][4] = 0;	buttonStringPatterns[0][5] = 0;
     612:	1f ae       	std	Y+63, r1	; 0x3f
     614:	1e ae       	std	Y+62, r1	; 0x3e
     616:	22 96       	adiw	r28, 0x02	; 2
     618:	1f ae       	std	Y+63, r1	; 0x3f
     61a:	1e ae       	std	Y+62, r1	; 0x3e
     61c:	22 97       	sbiw	r28, 0x02	; 2
	buttonStringPatterns[1][0] = 0;	buttonStringPatterns[1][1] = 0;
     61e:	24 96       	adiw	r28, 0x04	; 4
     620:	1f ae       	std	Y+63, r1	; 0x3f
     622:	1e ae       	std	Y+62, r1	; 0x3e
     624:	24 97       	sbiw	r28, 0x04	; 4
     626:	26 96       	adiw	r28, 0x06	; 6
     628:	1f ae       	std	Y+63, r1	; 0x3f
     62a:	1e ae       	std	Y+62, r1	; 0x3e
     62c:	26 97       	sbiw	r28, 0x06	; 6
	buttonStringPatterns[1][2] = 0;	buttonStringPatterns[1][3] = 0;
     62e:	28 96       	adiw	r28, 0x08	; 8
     630:	1f ae       	std	Y+63, r1	; 0x3f
     632:	1e ae       	std	Y+62, r1	; 0x3e
     634:	28 97       	sbiw	r28, 0x08	; 8
     636:	2a 96       	adiw	r28, 0x0a	; 10
     638:	1f ae       	std	Y+63, r1	; 0x3f
     63a:	1e ae       	std	Y+62, r1	; 0x3e
     63c:	2a 97       	sbiw	r28, 0x0a	; 10
	buttonStringPatterns[1][4] = 0;	buttonStringPatterns[1][5] = 0;
     63e:	2c 96       	adiw	r28, 0x0c	; 12
     640:	1f ae       	std	Y+63, r1	; 0x3f
     642:	1e ae       	std	Y+62, r1	; 0x3e
     644:	2c 97       	sbiw	r28, 0x0c	; 12
     646:	2e 96       	adiw	r28, 0x0e	; 14
     648:	1f ae       	std	Y+63, r1	; 0x3f
     64a:	1e ae       	std	Y+62, r1	; 0x3e
     64c:	2e 97       	sbiw	r28, 0x0e	; 14
	buttonStringPatterns[2][0] = 0;	buttonStringPatterns[2][1] = 0;
     64e:	60 96       	adiw	r28, 0x10	; 16
     650:	1f ae       	std	Y+63, r1	; 0x3f
     652:	1e ae       	std	Y+62, r1	; 0x3e
     654:	60 97       	sbiw	r28, 0x10	; 16
     656:	62 96       	adiw	r28, 0x12	; 18
     658:	1f ae       	std	Y+63, r1	; 0x3f
     65a:	1e ae       	std	Y+62, r1	; 0x3e
     65c:	62 97       	sbiw	r28, 0x12	; 18
	buttonStringPatterns[2][2] = 0;	buttonStringPatterns[2][3] = 0;
     65e:	64 96       	adiw	r28, 0x14	; 20
     660:	1f ae       	std	Y+63, r1	; 0x3f
     662:	1e ae       	std	Y+62, r1	; 0x3e
     664:	64 97       	sbiw	r28, 0x14	; 20
     666:	66 96       	adiw	r28, 0x16	; 22
     668:	1f ae       	std	Y+63, r1	; 0x3f
     66a:	1e ae       	std	Y+62, r1	; 0x3e
     66c:	66 97       	sbiw	r28, 0x16	; 22
	buttonStringPatterns[2][4] = 0;	buttonStringPatterns[2][5] = 0;
     66e:	68 96       	adiw	r28, 0x18	; 24
     670:	1f ae       	std	Y+63, r1	; 0x3f
     672:	1e ae       	std	Y+62, r1	; 0x3e
     674:	68 97       	sbiw	r28, 0x18	; 24
     676:	6a 96       	adiw	r28, 0x1a	; 26
     678:	1f ae       	std	Y+63, r1	; 0x3f
     67a:	1e ae       	std	Y+62, r1	; 0x3e
     67c:	6a 97       	sbiw	r28, 0x1a	; 26
	buttonStringPatterns[3][0] = 0;	buttonStringPatterns[3][1] = 0;
     67e:	6c 96       	adiw	r28, 0x1c	; 28
     680:	1f ae       	std	Y+63, r1	; 0x3f
     682:	1e ae       	std	Y+62, r1	; 0x3e
     684:	6c 97       	sbiw	r28, 0x1c	; 28
     686:	6e 96       	adiw	r28, 0x1e	; 30
     688:	1f ae       	std	Y+63, r1	; 0x3f
     68a:	1e ae       	std	Y+62, r1	; 0x3e
     68c:	6e 97       	sbiw	r28, 0x1e	; 30
	buttonStringPatterns[3][2] = 0;	buttonStringPatterns[3][3] = 0;
     68e:	a0 96       	adiw	r28, 0x20	; 32
     690:	1f ae       	std	Y+63, r1	; 0x3f
     692:	1e ae       	std	Y+62, r1	; 0x3e
     694:	a0 97       	sbiw	r28, 0x20	; 32
     696:	a2 96       	adiw	r28, 0x22	; 34
     698:	1f ae       	std	Y+63, r1	; 0x3f
     69a:	1e ae       	std	Y+62, r1	; 0x3e
     69c:	a2 97       	sbiw	r28, 0x22	; 34
	buttonStringPatterns[3][4] = 0;	buttonStringPatterns[3][5] = 0;
     69e:	a4 96       	adiw	r28, 0x24	; 36
     6a0:	1f ae       	std	Y+63, r1	; 0x3f
     6a2:	1e ae       	std	Y+62, r1	; 0x3e
     6a4:	a4 97       	sbiw	r28, 0x24	; 36
     6a6:	d1 01       	movw	r26, r2
     6a8:	1d 92       	st	X+, r1
     6aa:	1c 92       	st	X, r1
	buttonStringPatterns[4][0] = 0;	buttonStringPatterns[4][1] = 0;
     6ac:	a8 96       	adiw	r28, 0x28	; 40
     6ae:	1f ae       	std	Y+63, r1	; 0x3f
     6b0:	1e ae       	std	Y+62, r1	; 0x3e
     6b2:	a8 97       	sbiw	r28, 0x28	; 40
     6b4:	aa 96       	adiw	r28, 0x2a	; 42
     6b6:	1f ae       	std	Y+63, r1	; 0x3f
     6b8:	1e ae       	std	Y+62, r1	; 0x3e
     6ba:	aa 97       	sbiw	r28, 0x2a	; 42
	buttonStringPatterns[4][2] = 0;	buttonStringPatterns[4][3] = 0;
     6bc:	ac 96       	adiw	r28, 0x2c	; 44
     6be:	1f ae       	std	Y+63, r1	; 0x3f
     6c0:	1e ae       	std	Y+62, r1	; 0x3e
     6c2:	ac 97       	sbiw	r28, 0x2c	; 44
     6c4:	ae 96       	adiw	r28, 0x2e	; 46
     6c6:	1f ae       	std	Y+63, r1	; 0x3f
     6c8:	1e ae       	std	Y+62, r1	; 0x3e
     6ca:	ae 97       	sbiw	r28, 0x2e	; 46
	buttonStringPatterns[4][4] = 0;	buttonStringPatterns[4][5] = 0;
     6cc:	e0 96       	adiw	r28, 0x30	; 48
     6ce:	1f ae       	std	Y+63, r1	; 0x3f
     6d0:	1e ae       	std	Y+62, r1	; 0x3e
     6d2:	e0 97       	sbiw	r28, 0x30	; 48
     6d4:	fe 01       	movw	r30, r28
     6d6:	e0 59       	subi	r30, 0x90	; 144
     6d8:	ff 4f       	sbci	r31, 0xFF	; 255
     6da:	11 82       	std	Z+1, r1	; 0x01
     6dc:	10 82       	st	Z, r1
     6de:	66 24       	eor	r6, r6
     6e0:	63 94       	inc	r6
				//  button string patterns once so we can rebuild them.
				if (configMode == 1 && controllerMode == NOTES)
				{
					clearButtonStringPatterns(buttonStringPatterns);
				}
				buttonToAssign = 0; // This variable keeps track of which button we're assigning
     6e2:	1e 82       	std	Y+6, r1	; 0x06
     6e4:	1d 82       	std	Y+5, r1	; 0x05
				plusLock = 0; // This is a tool to let us test that in the prior cycle, plus was or wasn't on
     6e6:	1b 82       	std	Y+3, r1	; 0x03
			}

			// Config Mode operation
			if (configMode == 1) 
     6e8:	b1 e0       	ldi	r27, 0x01	; 1
     6ea:	6b 16       	cp	r6, r27
     6ec:	09 f0       	breq	.+2      	; 0x6f0 <__stack+0x1f1>
     6ee:	53 c0       	rjmp	.+166    	; 0x796 <__stack+0x297>
}

//This function tests to see if we're pressing the correct string combination to end config mode
inline char testForEndConfigMode(int stringState[])
{
	if ((stringState[0] == 0b00000000) &&
     6f0:	23 2b       	or	r18, r19
     6f2:	09 f0       	breq	.+2      	; 0x6f6 <__stack+0x1f7>
     6f4:	d0 c0       	rjmp	.+416    	; 0x896 <__stack+0x397>
     6f6:	8c a5       	ldd	r24, Y+44	; 0x2c
     6f8:	9d a5       	ldd	r25, Y+45	; 0x2d
     6fa:	89 2b       	or	r24, r25
     6fc:	09 f0       	breq	.+2      	; 0x700 <__stack+0x201>
     6fe:	cb c0       	rjmp	.+406    	; 0x896 <__stack+0x397>
     700:	8e a5       	ldd	r24, Y+46	; 0x2e
     702:	9f a5       	ldd	r25, Y+47	; 0x2f
     704:	48 97       	sbiw	r24, 0x18	; 24
     706:	09 f0       	breq	.+2      	; 0x70a <__stack+0x20b>
     708:	c6 c0       	rjmp	.+396    	; 0x896 <__stack+0x397>
     70a:	88 a9       	ldd	r24, Y+48	; 0x30
     70c:	99 a9       	ldd	r25, Y+49	; 0x31
     70e:	48 97       	sbiw	r24, 0x18	; 24
     710:	09 f0       	breq	.+2      	; 0x714 <__stack+0x215>
     712:	c1 c0       	rjmp	.+386    	; 0x896 <__stack+0x397>
     714:	8a a9       	ldd	r24, Y+50	; 0x32
     716:	9b a9       	ldd	r25, Y+51	; 0x33
     718:	48 97       	sbiw	r24, 0x18	; 24
     71a:	09 f0       	breq	.+2      	; 0x71e <__stack+0x21f>
     71c:	bc c0       	rjmp	.+376    	; 0x896 <__stack+0x397>
     71e:	8c a9       	ldd	r24, Y+52	; 0x34
     720:	9d a9       	ldd	r25, Y+53	; 0x35
     722:	89 2b       	or	r24, r25
     724:	09 f0       	breq	.+2      	; 0x728 <__stack+0x229>
     726:	b7 c0       	rjmp	.+366    	; 0x896 <__stack+0x397>
				if (testForEndConfigMode(stringState))
					{
						// Now save this new button mapping to the EEPROM 
						// Since we're already passing in buttonsStringPatterns
						// as a pointer, we don't use the '&' operator
						if (controllerMode == NOTES)
     728:	e2 e0       	ldi	r30, 0x02	; 2
     72a:	7e 16       	cp	r7, r30
     72c:	41 f4       	brne	.+16     	; 0x73e <__stack+0x23f>
     72e:	80 e0       	ldi	r24, 0x00	; 0
     730:	90 e0       	ldi	r25, 0x00	; 0
     732:	be 01       	movw	r22, r28
     734:	6a 5c       	subi	r22, 0xCA	; 202
     736:	7f 4f       	sbci	r23, 0xFF	; 255
     738:	4c e3       	ldi	r20, 0x3C	; 60
     73a:	50 e0       	ldi	r21, 0x00	; 0
     73c:	27 c0       	rjmp	.+78     	; 0x78c <__stack+0x28d>
							eeprom_write_block( (void*)buttonStringPatterns, (void*)&notesModeButtonPatterns, EEPROM_NOTES_BLOCK_SIZE);
						else if (controllerMode == CHORDS)
     73e:	f4 e0       	ldi	r31, 0x04	; 4
     740:	7f 16       	cp	r7, r31
     742:	61 f5       	brne	.+88     	; 0x79c <__stack+0x29d>
     744:	88 e7       	ldi	r24, 0x78	; 120
     746:	90 e0       	ldi	r25, 0x00	; 0
     748:	be 01       	movw	r22, r28
     74a:	6a 5c       	subi	r22, 0xCA	; 202
     74c:	7f 4f       	sbci	r23, 0xFF	; 255
     74e:	1c c0       	rjmp	.+56     	; 0x788 <__stack+0x289>
					//  The function itself can be found in processStringState.h/.c
					configSetButtonData(&data, &buttonToAssign, buttonStringPatterns, stringState, controllerMode,
											&plusLock, &previousPlusOn, &debounceTimer);

					// If we've assigned allcolors in Notes mode, cycle back to programming Green 
					if (controllerMode == NOTES && buttonToAssign >= NUM_NOTES_BUTTONS && plusLock == 0 )
     750:	8d 81       	ldd	r24, Y+5	; 0x05
     752:	9e 81       	ldd	r25, Y+6	; 0x06
     754:	05 97       	sbiw	r24, 0x05	; 5
     756:	0c f4       	brge	.+2      	; 0x75a <__stack+0x25b>
     758:	92 c0       	rjmp	.+292    	; 0x87e <__stack+0x37f>
     75a:	8b 81       	ldd	r24, Y+3	; 0x03
     75c:	88 23       	and	r24, r24
     75e:	09 f0       	breq	.+2      	; 0x762 <__stack+0x263>
     760:	8e c0       	rjmp	.+284    	; 0x87e <__stack+0x37f>
					{
						buttonToAssign = 0;
     762:	1e 82       	std	Y+6, r1	; 0x06
     764:	1d 82       	std	Y+5, r1	; 0x05
     766:	8b c0       	rjmp	.+278    	; 0x87e <__stack+0x37f>
					}
					
					// Or if we've programmed all 10 notes in Chord mode, exit programming mode
					if (controllerMode == CHORDS && buttonToAssign >= NUM_CHORDS_BUTTONS && plusLock == 0 )
     768:	84 e0       	ldi	r24, 0x04	; 4
     76a:	78 16       	cp	r7, r24
     76c:	09 f0       	breq	.+2      	; 0x770 <__stack+0x271>
     76e:	87 c0       	rjmp	.+270    	; 0x87e <__stack+0x37f>
     770:	8d 81       	ldd	r24, Y+5	; 0x05
     772:	9e 81       	ldd	r25, Y+6	; 0x06
     774:	0a 97       	sbiw	r24, 0x0a	; 10
     776:	0c f4       	brge	.+2      	; 0x77a <__stack+0x27b>
     778:	82 c0       	rjmp	.+260    	; 0x87e <__stack+0x37f>
     77a:	8b 81       	ldd	r24, Y+3	; 0x03
     77c:	88 23       	and	r24, r24
     77e:	09 f0       	breq	.+2      	; 0x782 <__stack+0x283>
     780:	7e c0       	rjmp	.+252    	; 0x87e <__stack+0x37f>
     782:	88 e7       	ldi	r24, 0x78	; 120
     784:	90 e0       	ldi	r25, 0x00	; 0
     786:	b2 01       	movw	r22, r4
     788:	48 e7       	ldi	r20, 0x78	; 120
     78a:	50 e0       	ldi	r21, 0x00	; 0
     78c:	28 eb       	ldi	r18, 0xB8	; 184
     78e:	30 e0       	ldi	r19, 0x00	; 0
     790:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <__eewr_block>
     794:	03 c0       	rjmp	.+6      	; 0x79c <__stack+0x29d>
					}
		}	}	}	 // End of Config Mode code

		
		// Normal operation
		if (configMode == 0)
     796:	66 20       	and	r6, r6
     798:	09 f0       	breq	.+2      	; 0x79c <__stack+0x29d>
     79a:	71 c0       	rjmp	.+226    	; 0x87e <__stack+0x37f>
}

inline int testForSwitchModes(int stringState[])
{
	// Test for the right keypress to start the mode
	if ((stringState[0] == 0b00000000) &&
     79c:	8a a5       	ldd	r24, Y+42	; 0x2a
     79e:	9b a5       	ldd	r25, Y+43	; 0x2b
     7a0:	89 2b       	or	r24, r25
     7a2:	09 f0       	breq	.+2      	; 0x7a6 <__stack+0x2a7>
     7a4:	51 c0       	rjmp	.+162    	; 0x848 <__stack+0x349>
     7a6:	8c a5       	ldd	r24, Y+44	; 0x2c
     7a8:	9d a5       	ldd	r25, Y+45	; 0x2d
     7aa:	88 31       	cpi	r24, 0x18	; 24
     7ac:	91 05       	cpc	r25, r1
     7ae:	b1 f4       	brne	.+44     	; 0x7dc <__stack+0x2dd>
     7b0:	8e a5       	ldd	r24, Y+46	; 0x2e
     7b2:	9f a5       	ldd	r25, Y+47	; 0x2f
     7b4:	48 97       	sbiw	r24, 0x18	; 24
     7b6:	09 f0       	breq	.+2      	; 0x7ba <__stack+0x2bb>
     7b8:	47 c0       	rjmp	.+142    	; 0x848 <__stack+0x349>
     7ba:	88 a9       	ldd	r24, Y+48	; 0x30
     7bc:	99 a9       	ldd	r25, Y+49	; 0x31
     7be:	48 97       	sbiw	r24, 0x18	; 24
     7c0:	09 f0       	breq	.+2      	; 0x7c4 <__stack+0x2c5>
     7c2:	42 c0       	rjmp	.+132    	; 0x848 <__stack+0x349>
     7c4:	8a a9       	ldd	r24, Y+50	; 0x32
     7c6:	9b a9       	ldd	r25, Y+51	; 0x33
     7c8:	89 2b       	or	r24, r25
     7ca:	f1 f5       	brne	.+124    	; 0x848 <__stack+0x349>
     7cc:	8c a9       	ldd	r24, Y+52	; 0x34
     7ce:	9d a9       	ldd	r25, Y+53	; 0x35
     7d0:	89 2b       	or	r24, r25
     7d2:	d1 f5       	brne	.+116    	; 0x848 <__stack+0x349>
static inline void switchPlayModes(int stringState[], int buttonStringPatterns[][6], char* controllerMode)
{
	// Test for the right keypress to start the mode
	if (testForSwitchModes(stringState))
	{
		if (*controllerMode % 2 == 0) // This means that the mode is a full mode
     7d4:	70 fc       	sbrc	r7, 0
     7d6:	38 c0       	rjmp	.+112    	; 0x848 <__stack+0x349>
			{++*controllerMode;}  //This puts it into a transitional mode
     7d8:	73 94       	inc	r7
     7da:	36 c0       	rjmp	.+108    	; 0x848 <__stack+0x349>
		return 0;
}

inline int testForNoStringsPressed(int stringState[])
{
	if ((stringState[0] == 0b00000000) &&
     7dc:	89 2b       	or	r24, r25
     7de:	a1 f5       	brne	.+104    	; 0x848 <__stack+0x349>
     7e0:	8e a5       	ldd	r24, Y+46	; 0x2e
     7e2:	9f a5       	ldd	r25, Y+47	; 0x2f
     7e4:	89 2b       	or	r24, r25
     7e6:	81 f5       	brne	.+96     	; 0x848 <__stack+0x349>
     7e8:	88 a9       	ldd	r24, Y+48	; 0x30
     7ea:	99 a9       	ldd	r25, Y+49	; 0x31
     7ec:	89 2b       	or	r24, r25
     7ee:	61 f5       	brne	.+88     	; 0x848 <__stack+0x349>
     7f0:	8a a9       	ldd	r24, Y+50	; 0x32
     7f2:	9b a9       	ldd	r25, Y+51	; 0x33
     7f4:	89 2b       	or	r24, r25
     7f6:	41 f5       	brne	.+80     	; 0x848 <__stack+0x349>
     7f8:	8c a9       	ldd	r24, Y+52	; 0x34
     7fa:	9d a9       	ldd	r25, Y+53	; 0x35
     7fc:	89 2b       	or	r24, r25
     7fe:	21 f5       	brne	.+72     	; 0x848 <__stack+0x349>
	}
	// And if we're not pressing that anymore, switch from the transitional mode to the regular mode,
	//  resetting the button patterns as necessary
	else if(testForNoStringsPressed(stringState)) 
	{
		if (*controllerMode == CHORDS_TO_FRETS) // since these modes are just numbers, we need to wrap around
     800:	95 e0       	ldi	r25, 0x05	; 5
     802:	79 16       	cp	r7, r25
     804:	11 f4       	brne	.+4      	; 0x80a <__stack+0x30b>
     806:	77 24       	eor	r7, r7
     808:	1f c0       	rjmp	.+62     	; 0x848 <__stack+0x349>
			{*controllerMode = FRETS;}

		// Now, reset the buttonStringPattern array to be appropriate for the mode
		// For this, we'll read it from the EEPROM memory.
		else if (*controllerMode  == FRETS_TO_NOTES)
     80a:	a1 e0       	ldi	r26, 0x01	; 1
     80c:	7a 16       	cp	r7, r26
     80e:	69 f4       	brne	.+26     	; 0x82a <__stack+0x32b>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
     810:	ce 01       	movw	r24, r28
     812:	c6 96       	adiw	r24, 0x36	; 54
     814:	60 e0       	ldi	r22, 0x00	; 0
     816:	70 e0       	ldi	r23, 0x00	; 0
     818:	4c e3       	ldi	r20, 0x3C	; 60
     81a:	50 e0       	ldi	r21, 0x00	; 0
     81c:	20 eb       	ldi	r18, 0xB0	; 176
     81e:	30 e0       	ldi	r19, 0x00	; 0
     820:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <__eerd_block>
     824:	52 e0       	ldi	r21, 0x02	; 2
     826:	75 2e       	mov	r7, r21
     828:	0f c0       	rjmp	.+30     	; 0x848 <__stack+0x349>
		{
			// Notice, we're already passing in buttonStringPatterns as an address, so the EEPROM read looks a bit strange
			eeprom_read_block( (void*)buttonStringPatterns, (void*)&notesModeButtonPatterns, EEPROM_NOTES_BLOCK_SIZE);
			*controllerMode = NOTES;
		}
		else if (*controllerMode  == NOTES_TO_CHORDS)
     82a:	b3 e0       	ldi	r27, 0x03	; 3
     82c:	7b 16       	cp	r7, r27
     82e:	61 f4       	brne	.+24     	; 0x848 <__stack+0x349>
     830:	ce 01       	movw	r24, r28
     832:	c6 96       	adiw	r24, 0x36	; 54
     834:	68 e7       	ldi	r22, 0x78	; 120
     836:	70 e0       	ldi	r23, 0x00	; 0
     838:	48 e7       	ldi	r20, 0x78	; 120
     83a:	50 e0       	ldi	r21, 0x00	; 0
     83c:	20 eb       	ldi	r18, 0xB0	; 176
     83e:	30 e0       	ldi	r19, 0x00	; 0
     840:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <__eerd_block>
     844:	44 e0       	ldi	r20, 0x04	; 4
     846:	74 2e       	mov	r7, r20
			switchPlayModes(stringState, buttonStringPatterns, &controllerMode);

			// Next, using our strumState array, we process that data to figure out what sort
			//  of buttons on the controller we want to emulate pressing.
			// find out if we're in a transitional controller mode or not
			if (!(controllerMode % 2)) // Not a transitional mode
     848:	67 2d       	mov	r22, r7
     84a:	ce 01       	movw	r24, r28
     84c:	09 96       	adiw	r24, 0x09	; 9
     84e:	70 fc       	sbrc	r7, 0
     850:	12 c0       	rjmp	.+36     	; 0x876 <__stack+0x377>
			{	//  This function can be found in processStringState.h/.c
				processStringState(&data, stringState, buttonStringPatterns, controllerMode, greenTimers, triedGreen);
     852:	be 01       	movw	r22, r28
     854:	66 5d       	subi	r22, 0xD6	; 214
     856:	7f 4f       	sbci	r23, 0xFF	; 255
     858:	ae 01       	movw	r20, r28
     85a:	4a 5c       	subi	r20, 0xCA	; 202
     85c:	5f 4f       	sbci	r21, 0xFF	; 255
     85e:	27 2d       	mov	r18, r7
     860:	8e 01       	movw	r16, r28
     862:	0e 5e       	subi	r16, 0xEE	; 238
     864:	1f 4f       	sbci	r17, 0xFF	; 255
     866:	3e e1       	ldi	r19, 0x1E	; 30
     868:	e3 2e       	mov	r14, r19
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	0e 94 72 08 	call	0x10e4	; 0x10e4 <processStringState>
     874:	03 c0       	rjmp	.+6      	; 0x87c <__stack+0x37d>
			}
			else
			{   // Now, if we're in a transitional controller mode, we'll forget that data and substitue 
				// visual cue data to show that we're changing to a specific mode
				//  The function itself can be found in processStringState.h/.c
				displayTransitionState(&data, controllerMode);
     876:	70 e0       	ldi	r23, 0x00	; 0
     878:	0e 94 89 08 	call	0x1112	; 0x1112 <displayTransitionState>
     87c:	66 24       	eor	r6, r6
		}
			    
		// Now our processing is complete, so using those button presses, we set up the 
		// button data packet. This function depends on the console and is 
		// set specially in the interface functions - see ps3interface.h, wiiinterface.h, etc.
		sendData(data);
     87e:	09 85       	ldd	r16, Y+9	; 0x09
     880:	1a 85       	ldd	r17, Y+10	; 0x0a
     882:	2b 85       	ldd	r18, Y+11	; 0x0b
     884:	3c 85       	ldd	r19, Y+12	; 0x0c
     886:	4d 85       	ldd	r20, Y+13	; 0x0d
     888:	5e 85       	ldd	r21, Y+14	; 0x0e
     88a:	6f 85       	ldd	r22, Y+15	; 0x0f
     88c:	78 89       	ldd	r23, Y+16	; 0x10
     88e:	89 89       	ldd	r24, Y+17	; 0x11
     890:	0e 94 38 0a 	call	0x1470	; 0x1470 <sendData>
     894:	47 cd       	rjmp	.-1394   	; 0x324 <main+0xe4>
				else
				{
					// Now set up the data packet to the Wii to say we're pressing whatever button we're currently
					// assigning, and if we're pressing 'plus', go ahead and lock that string combination in
					//  The function itself can be found in processStringState.h/.c
					configSetButtonData(&data, &buttonToAssign, buttonStringPatterns, stringState, controllerMode,
     896:	b6 e3       	ldi	r27, 0x36	; 54
     898:	4b 2e       	mov	r4, r27
     89a:	51 2c       	mov	r5, r1
     89c:	4c 0e       	add	r4, r28
     89e:	5d 1e       	adc	r5, r29
     8a0:	ce 01       	movw	r24, r28
     8a2:	09 96       	adiw	r24, 0x09	; 9
     8a4:	be 01       	movw	r22, r28
     8a6:	6b 5f       	subi	r22, 0xFB	; 251
     8a8:	7f 4f       	sbci	r23, 0xFF	; 255
     8aa:	a2 01       	movw	r20, r4
     8ac:	9e 01       	movw	r18, r28
     8ae:	26 5d       	subi	r18, 0xD6	; 214
     8b0:	3f 4f       	sbci	r19, 0xFF	; 255
     8b2:	07 2d       	mov	r16, r7
     8b4:	a3 e0       	ldi	r26, 0x03	; 3
     8b6:	ea 2e       	mov	r14, r26
     8b8:	f1 2c       	mov	r15, r1
     8ba:	ec 0e       	add	r14, r28
     8bc:	fd 1e       	adc	r15, r29
     8be:	f4 e0       	ldi	r31, 0x04	; 4
     8c0:	cf 2e       	mov	r12, r31
     8c2:	d1 2c       	mov	r13, r1
     8c4:	cc 0e       	add	r12, r28
     8c6:	dd 1e       	adc	r13, r29
     8c8:	e7 e0       	ldi	r30, 0x07	; 7
     8ca:	ae 2e       	mov	r10, r30
     8cc:	b1 2c       	mov	r11, r1
     8ce:	ac 0e       	add	r10, r28
     8d0:	bd 1e       	adc	r11, r29
     8d2:	0e 94 9f 08 	call	0x113e	; 0x113e <configSetButtonData>
											&plusLock, &previousPlusOn, &debounceTimer);

					// If we've assigned allcolors in Notes mode, cycle back to programming Green 
					if (controllerMode == NOTES && buttonToAssign >= NUM_NOTES_BUTTONS && plusLock == 0 )
     8d6:	e2 e0       	ldi	r30, 0x02	; 2
     8d8:	7e 16       	cp	r7, r30
     8da:	09 f0       	breq	.+2      	; 0x8de <__stack+0x3df>
     8dc:	45 cf       	rjmp	.-374    	; 0x768 <__stack+0x269>
     8de:	38 cf       	rjmp	.-400    	; 0x750 <__stack+0x251>

000008e0 <setPins>:
#include "guitarInitFunctions.h"

void setPins(void)
{
	// Set the fret pins as input pins, with internal resistor
	fret_ddr &= ~(1<<green_pin);        // input
     8e0:	21 98       	cbi	0x04, 1	; 4
	fret_port |= (1<<green_pin);		//pull-up enabled	
     8e2:	29 9a       	sbi	0x05, 1	; 5
	fret_ddr &= ~(1<<red_pin);
     8e4:	22 98       	cbi	0x04, 2	; 4
	fret_port |= (1<<red_pin);
     8e6:	2a 9a       	sbi	0x05, 2	; 5
	fret_ddr &= ~(1<<yellow_pin);
     8e8:	23 98       	cbi	0x04, 3	; 4
	fret_port |= (1<<yellow_pin);
     8ea:	2b 9a       	sbi	0x05, 3	; 5
	fret_ddr &= ~(1<<blue_pin);
     8ec:	24 98       	cbi	0x04, 4	; 4
	fret_port |= (1<<blue_pin);
     8ee:	2c 9a       	sbi	0x05, 4	; 5
	fret_ddr &= ~(1<<orange_pin);
     8f0:	25 98       	cbi	0x04, 5	; 4
	fret_port |= (1<<orange_pin);
     8f2:	2d 9a       	sbi	0x05, 5	; 5

	// Set the pins on strumming and plus as inputs, with internal resistor
	misc_ddr &= ~(1<<plus_pin);
     8f4:	38 98       	cbi	0x07, 0	; 7
	misc_port |= (1<<plus_pin);
     8f6:	40 9a       	sbi	0x08, 0	; 8
	misc_ddr &= ~(1<<minus_pin);
     8f8:	39 98       	cbi	0x07, 1	; 7
	misc_port |= (1<<minus_pin);
     8fa:	41 9a       	sbi	0x08, 1	; 8

	pick_ddr &= ~(1<<strum_pin);
     8fc:	3a 98       	cbi	0x07, 2	; 7
	pick_port |= (1<<strum_pin);
     8fe:	42 9a       	sbi	0x08, 2	; 8

	// Set the string pins as output pins, outputting HIGH
	/* MAKE SURE YOU HAVE DIODES OPPOSING THIS CURRENT OUTFLOW! */
	string_ddr |= (1<<first_string);  //output
     900:	57 9a       	sbi	0x0a, 7	; 10
	string_port |= (1<<first_string); // set high
     902:	5f 9a       	sbi	0x0b, 7	; 11
	string_ddr |= (1<<second_string);  
     904:	56 9a       	sbi	0x0a, 6	; 10
	string_port |= (1<<second_string);
     906:	5e 9a       	sbi	0x0b, 6	; 11
	string_ddr |= (1<<third_string);  
     908:	55 9a       	sbi	0x0a, 5	; 10
	string_port |= (1<<third_string);
     90a:	5d 9a       	sbi	0x0b, 5	; 11
	string_ddr |= (1<<fourth_string);  
     90c:	52 9a       	sbi	0x0a, 2	; 10
	string_port |= (1<<fourth_string);
     90e:	5a 9a       	sbi	0x0b, 2	; 11
	string_ddr |= (1<<fifth_string);  
     910:	51 9a       	sbi	0x0a, 1	; 10
	string_port |= (1<<fifth_string);
     912:	59 9a       	sbi	0x0b, 1	; 11
	string_ddr |= (1<<sixth_string);  
     914:	50 9a       	sbi	0x0a, 0	; 10
	string_port |= (1<<sixth_string);
     916:	58 9a       	sbi	0x0b, 0	; 11
}
     918:	08 95       	ret

0000091a <setTimer>:

void setTimer(void) //This sets up a timer to handle the green button thing
{
	PRR &= ~(1<<PRTIM1);	// ensure power to Timer/Counter1
     91a:	e4 e6       	ldi	r30, 0x64	; 100
     91c:	f0 e0       	ldi	r31, 0x00	; 0
     91e:	80 81       	ld	r24, Z
     920:	87 7f       	andi	r24, 0xF7	; 247
     922:	80 83       	st	Z, r24

	TCCR1A &= ~(1<<COM1A1);  // This prevents OC2A pin from doing anything
     924:	e0 e8       	ldi	r30, 0x80	; 128
     926:	f0 e0       	ldi	r31, 0x00	; 0
     928:	80 81       	ld	r24, Z
     92a:	8f 77       	andi	r24, 0x7F	; 127
     92c:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<COM1A0);  //  to the pins on the chip. Otherwise, we might
     92e:	80 81       	ld	r24, Z
     930:	8f 7b       	andi	r24, 0xBF	; 191
     932:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<COM1B1);  //  get signals coming out of some of the pins we might use
     934:	80 81       	ld	r24, Z
     936:	8f 7d       	andi	r24, 0xDF	; 223
     938:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<COM1B0);
     93a:	80 81       	ld	r24, Z
     93c:	8f 7e       	andi	r24, 0xEF	; 239
     93e:	80 83       	st	Z, r24

	TCCR1A &= ~(1<<WGM11);  // These bits set up normal mode on the Waveform Generation
     940:	80 81       	ld	r24, Z
     942:	8d 7f       	andi	r24, 0xFD	; 253
     944:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<WGM10);  // This means that the counter acts like a normal timer,
     946:	80 81       	ld	r24, Z
     948:	8e 7f       	andi	r24, 0xFE	; 254
     94a:	80 83       	st	Z, r24
	TCCR1B &= ~(1<<WGM12);  // not some sort of fancy digital-analog converter or anything
     94c:	e1 e8       	ldi	r30, 0x81	; 129
     94e:	f0 e0       	ldi	r31, 0x00	; 0
     950:	80 81       	ld	r24, Z
     952:	87 7f       	andi	r24, 0xF7	; 247
     954:	80 83       	st	Z, r24
	TCCR1B &= ~(1<<WGM13);  // It counts up to 65536 and overflows to zero
     956:	80 81       	ld	r24, Z
     958:	8f 7e       	andi	r24, 0xEF	; 239
     95a:	80 83       	st	Z, r24

	TCCR1B |= (1<<CS12);   // These set the clock to CPU (8MHz) / 1024 
     95c:	80 81       	ld	r24, Z
     95e:	84 60       	ori	r24, 0x04	; 4
     960:	80 83       	st	Z, r24
	TCCR1B &= ~(1<<CS11);  // or roughly 8 kHz (7.8125 kHz)
     962:	80 81       	ld	r24, Z
     964:	8d 7f       	andi	r24, 0xFD	; 253
     966:	80 83       	st	Z, r24
	TCCR1B |= (1<<CS10);   // When counting from zero to 0xFFFF, it takes about 8 seconds
     968:	80 81       	ld	r24, Z
     96a:	81 60       	ori	r24, 0x01	; 1
     96c:	80 83       	st	Z, r24

	// The counter's value is stored in TCNT1
}
     96e:	08 95       	ret

00000970 <processChords>:
*/
#include "processStringState.h"

void processChords(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
     970:	0f 93       	push	r16
     972:	1f 93       	push	r17
     974:	cf 93       	push	r28
     976:	df 93       	push	r29
     978:	8c 01       	movw	r16, r24
     97a:	fb 01       	movw	r30, r22
     97c:	ea 01       	movw	r28, r20
     97e:	20 e0       	ldi	r18, 0x00	; 0
     980:	30 e0       	ldi	r19, 0x00	; 0
				data->downOn = 1;
				data->upOn   = 0;
			}
			else
			{
				data->upOn   = 1;
     982:	41 e0       	ldi	r20, 0x01	; 1
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
	// First take care of registering strumming
	for (int guitarString = 0; guitarString < 6; guitarString++)
	{
		if (stringState[guitarString] & 1)
     984:	db 01       	movw	r26, r22
     986:	8d 91       	ld	r24, X+
     988:	9c 91       	ld	r25, X
     98a:	11 97       	sbiw	r26, 0x01	; 1
     98c:	80 ff       	sbrs	r24, 0
     98e:	13 c0       	rjmp	.+38     	; 0x9b6 <processChords+0x46>
		{
			stringState[guitarString] &= ~1; //Set the last bit to zero
     990:	8e 7f       	andi	r24, 0xFE	; 254
     992:	8d 93       	st	X+, r24
     994:	9c 93       	st	X, r25
			if (guitarString < 3)
     996:	23 30       	cpi	r18, 0x03	; 3
     998:	31 05       	cpc	r19, r1
     99a:	3c f4       	brge	.+14     	; 0x9aa <processChords+0x3a>
			{
				data->downOn = 1;
     99c:	d8 01       	movw	r26, r16
     99e:	16 96       	adiw	r26, 0x06	; 6
     9a0:	4c 93       	st	X, r20
     9a2:	16 97       	sbiw	r26, 0x06	; 6
				data->upOn   = 0;
     9a4:	15 96       	adiw	r26, 0x05	; 5
     9a6:	1c 92       	st	X, r1
     9a8:	06 c0       	rjmp	.+12     	; 0x9b6 <processChords+0x46>
			}
			else
			{
				data->upOn   = 1;
     9aa:	d8 01       	movw	r26, r16
     9ac:	15 96       	adiw	r26, 0x05	; 5
     9ae:	4c 93       	st	X, r20
     9b0:	15 97       	sbiw	r26, 0x05	; 5
				data->downOn = 0;
     9b2:	16 96       	adiw	r26, 0x06	; 6
     9b4:	1c 92       	st	X, r1

void processChords(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
	// First take care of registering strumming
	for (int guitarString = 0; guitarString < 6; guitarString++)
     9b6:	2f 5f       	subi	r18, 0xFF	; 255
     9b8:	3f 4f       	sbci	r19, 0xFF	; 255
     9ba:	6e 5f       	subi	r22, 0xFE	; 254
     9bc:	7f 4f       	sbci	r23, 0xFF	; 255
     9be:	26 30       	cpi	r18, 0x06	; 6
     9c0:	31 05       	cpc	r19, r1
     9c2:	01 f7       	brne	.-64     	; 0x984 <processChords+0x14>
			}
		}
	}

	// First, save us some trouble and see if we're not pressing anything at all..
	if ((stringState[0] == 0b00000000) &&
     9c4:	40 81       	ld	r20, Z
     9c6:	51 81       	ldd	r21, Z+1	; 0x01
     9c8:	41 15       	cp	r20, r1
     9ca:	51 05       	cpc	r21, r1
     9cc:	a9 f4       	brne	.+42     	; 0x9f8 <processChords+0x88>
     9ce:	82 81       	ldd	r24, Z+2	; 0x02
     9d0:	93 81       	ldd	r25, Z+3	; 0x03
     9d2:	89 2b       	or	r24, r25
     9d4:	89 f4       	brne	.+34     	; 0x9f8 <processChords+0x88>
     9d6:	84 81       	ldd	r24, Z+4	; 0x04
     9d8:	95 81       	ldd	r25, Z+5	; 0x05
     9da:	89 2b       	or	r24, r25
     9dc:	69 f4       	brne	.+26     	; 0x9f8 <processChords+0x88>
     9de:	86 81       	ldd	r24, Z+6	; 0x06
     9e0:	97 81       	ldd	r25, Z+7	; 0x07
     9e2:	89 2b       	or	r24, r25
     9e4:	49 f4       	brne	.+18     	; 0x9f8 <processChords+0x88>
     9e6:	80 85       	ldd	r24, Z+8	; 0x08
     9e8:	91 85       	ldd	r25, Z+9	; 0x09
     9ea:	89 2b       	or	r24, r25
     9ec:	29 f4       	brne	.+10     	; 0x9f8 <processChords+0x88>
     9ee:	82 85       	ldd	r24, Z+10	; 0x0a
     9f0:	93 85       	ldd	r25, Z+11	; 0x0b
     9f2:	89 2b       	or	r24, r25
     9f4:	09 f4       	brne	.+2      	; 0x9f8 <processChords+0x88>
     9f6:	31 c2       	rjmp	.+1122   	; 0xe5a <processChords+0x4ea>
		return;

	// Now see if what's being played on the fretboard matches any of the button patterns in
	//  buttonStringPatterns
	// green
	if(stringState[0] == buttonStringPatterns[0][0] &&
     9f8:	88 81       	ld	r24, Y
     9fa:	99 81       	ldd	r25, Y+1	; 0x01
     9fc:	48 17       	cp	r20, r24
     9fe:	59 07       	cpc	r21, r25
     a00:	39 f5       	brne	.+78     	; 0xa50 <processChords+0xe0>
     a02:	22 81       	ldd	r18, Z+2	; 0x02
     a04:	33 81       	ldd	r19, Z+3	; 0x03
     a06:	8a 81       	ldd	r24, Y+2	; 0x02
     a08:	9b 81       	ldd	r25, Y+3	; 0x03
     a0a:	28 17       	cp	r18, r24
     a0c:	39 07       	cpc	r19, r25
     a0e:	01 f5       	brne	.+64     	; 0xa50 <processChords+0xe0>
     a10:	24 81       	ldd	r18, Z+4	; 0x04
     a12:	35 81       	ldd	r19, Z+5	; 0x05
     a14:	8c 81       	ldd	r24, Y+4	; 0x04
     a16:	9d 81       	ldd	r25, Y+5	; 0x05
     a18:	28 17       	cp	r18, r24
     a1a:	39 07       	cpc	r19, r25
     a1c:	c9 f4       	brne	.+50     	; 0xa50 <processChords+0xe0>
     a1e:	26 81       	ldd	r18, Z+6	; 0x06
     a20:	37 81       	ldd	r19, Z+7	; 0x07
     a22:	8e 81       	ldd	r24, Y+6	; 0x06
     a24:	9f 81       	ldd	r25, Y+7	; 0x07
     a26:	28 17       	cp	r18, r24
     a28:	39 07       	cpc	r19, r25
     a2a:	91 f4       	brne	.+36     	; 0xa50 <processChords+0xe0>
     a2c:	20 85       	ldd	r18, Z+8	; 0x08
     a2e:	31 85       	ldd	r19, Z+9	; 0x09
     a30:	88 85       	ldd	r24, Y+8	; 0x08
     a32:	99 85       	ldd	r25, Y+9	; 0x09
     a34:	28 17       	cp	r18, r24
     a36:	39 07       	cpc	r19, r25
     a38:	59 f4       	brne	.+22     	; 0xa50 <processChords+0xe0>
     a3a:	22 85       	ldd	r18, Z+10	; 0x0a
     a3c:	33 85       	ldd	r19, Z+11	; 0x0b
     a3e:	8a 85       	ldd	r24, Y+10	; 0x0a
     a40:	9b 85       	ldd	r25, Y+11	; 0x0b
     a42:	28 17       	cp	r18, r24
     a44:	39 07       	cpc	r19, r25
     a46:	21 f4       	brne	.+8      	; 0xa50 <processChords+0xe0>
	   stringState[2] == buttonStringPatterns[0][2] &&
	   stringState[3] == buttonStringPatterns[0][3] &&
	   stringState[4] == buttonStringPatterns[0][4] &&
	   stringState[5] == buttonStringPatterns[0][5]  ) 
		{
			data->greenOn = 1;
     a48:	81 e0       	ldi	r24, 0x01	; 1
     a4a:	f8 01       	movw	r30, r16
     a4c:	80 83       	st	Z, r24
     a4e:	05 c2       	rjmp	.+1034   	; 0xe5a <processChords+0x4ea>
  		}
	// red
	else if(stringState[0] == buttonStringPatterns[1][0] &&
     a50:	de 01       	movw	r26, r28
     a52:	1c 96       	adiw	r26, 0x0c	; 12
     a54:	8c 85       	ldd	r24, Y+12	; 0x0c
     a56:	9d 85       	ldd	r25, Y+13	; 0x0d
     a58:	48 17       	cp	r20, r24
     a5a:	59 07       	cpc	r21, r25
     a5c:	81 f5       	brne	.+96     	; 0xabe <processChords+0x14e>
     a5e:	22 81       	ldd	r18, Z+2	; 0x02
     a60:	33 81       	ldd	r19, Z+3	; 0x03
     a62:	12 96       	adiw	r26, 0x02	; 2
     a64:	8d 91       	ld	r24, X+
     a66:	9c 91       	ld	r25, X
     a68:	13 97       	sbiw	r26, 0x03	; 3
     a6a:	28 17       	cp	r18, r24
     a6c:	39 07       	cpc	r19, r25
     a6e:	39 f5       	brne	.+78     	; 0xabe <processChords+0x14e>
     a70:	24 81       	ldd	r18, Z+4	; 0x04
     a72:	35 81       	ldd	r19, Z+5	; 0x05
     a74:	14 96       	adiw	r26, 0x04	; 4
     a76:	8d 91       	ld	r24, X+
     a78:	9c 91       	ld	r25, X
     a7a:	15 97       	sbiw	r26, 0x05	; 5
     a7c:	28 17       	cp	r18, r24
     a7e:	39 07       	cpc	r19, r25
     a80:	f1 f4       	brne	.+60     	; 0xabe <processChords+0x14e>
     a82:	26 81       	ldd	r18, Z+6	; 0x06
     a84:	37 81       	ldd	r19, Z+7	; 0x07
     a86:	16 96       	adiw	r26, 0x06	; 6
     a88:	8d 91       	ld	r24, X+
     a8a:	9c 91       	ld	r25, X
     a8c:	17 97       	sbiw	r26, 0x07	; 7
     a8e:	28 17       	cp	r18, r24
     a90:	39 07       	cpc	r19, r25
     a92:	a9 f4       	brne	.+42     	; 0xabe <processChords+0x14e>
     a94:	20 85       	ldd	r18, Z+8	; 0x08
     a96:	31 85       	ldd	r19, Z+9	; 0x09
     a98:	18 96       	adiw	r26, 0x08	; 8
     a9a:	8d 91       	ld	r24, X+
     a9c:	9c 91       	ld	r25, X
     a9e:	19 97       	sbiw	r26, 0x09	; 9
     aa0:	28 17       	cp	r18, r24
     aa2:	39 07       	cpc	r19, r25
     aa4:	61 f4       	brne	.+24     	; 0xabe <processChords+0x14e>
     aa6:	22 85       	ldd	r18, Z+10	; 0x0a
     aa8:	33 85       	ldd	r19, Z+11	; 0x0b
     aaa:	1a 96       	adiw	r26, 0x0a	; 10
     aac:	8d 91       	ld	r24, X+
     aae:	9c 91       	ld	r25, X
     ab0:	1b 97       	sbiw	r26, 0x0b	; 11
     ab2:	28 17       	cp	r18, r24
     ab4:	39 07       	cpc	r19, r25
     ab6:	19 f4       	brne	.+6      	; 0xabe <processChords+0x14e>
	   stringState[2] == buttonStringPatterns[1][2] &&
	   stringState[3] == buttonStringPatterns[1][3] &&
	   stringState[4] == buttonStringPatterns[1][4] &&
	   stringState[5] == buttonStringPatterns[1][5]  ) 
		{
			data->redOn = 1;
     ab8:	81 e0       	ldi	r24, 0x01	; 1
     aba:	d8 01       	movw	r26, r16
     abc:	dd c0       	rjmp	.+442    	; 0xc78 <processChords+0x308>
  		}

	// yellow
	else if(stringState[0] == buttonStringPatterns[2][0] &&
     abe:	de 01       	movw	r26, r28
     ac0:	58 96       	adiw	r26, 0x18	; 24
     ac2:	88 8d       	ldd	r24, Y+24	; 0x18
     ac4:	99 8d       	ldd	r25, Y+25	; 0x19
     ac6:	48 17       	cp	r20, r24
     ac8:	59 07       	cpc	r21, r25
     aca:	81 f5       	brne	.+96     	; 0xb2c <processChords+0x1bc>
     acc:	22 81       	ldd	r18, Z+2	; 0x02
     ace:	33 81       	ldd	r19, Z+3	; 0x03
     ad0:	12 96       	adiw	r26, 0x02	; 2
     ad2:	8d 91       	ld	r24, X+
     ad4:	9c 91       	ld	r25, X
     ad6:	13 97       	sbiw	r26, 0x03	; 3
     ad8:	28 17       	cp	r18, r24
     ada:	39 07       	cpc	r19, r25
     adc:	39 f5       	brne	.+78     	; 0xb2c <processChords+0x1bc>
     ade:	24 81       	ldd	r18, Z+4	; 0x04
     ae0:	35 81       	ldd	r19, Z+5	; 0x05
     ae2:	14 96       	adiw	r26, 0x04	; 4
     ae4:	8d 91       	ld	r24, X+
     ae6:	9c 91       	ld	r25, X
     ae8:	15 97       	sbiw	r26, 0x05	; 5
     aea:	28 17       	cp	r18, r24
     aec:	39 07       	cpc	r19, r25
     aee:	f1 f4       	brne	.+60     	; 0xb2c <processChords+0x1bc>
     af0:	26 81       	ldd	r18, Z+6	; 0x06
     af2:	37 81       	ldd	r19, Z+7	; 0x07
     af4:	16 96       	adiw	r26, 0x06	; 6
     af6:	8d 91       	ld	r24, X+
     af8:	9c 91       	ld	r25, X
     afa:	17 97       	sbiw	r26, 0x07	; 7
     afc:	28 17       	cp	r18, r24
     afe:	39 07       	cpc	r19, r25
     b00:	a9 f4       	brne	.+42     	; 0xb2c <processChords+0x1bc>
     b02:	20 85       	ldd	r18, Z+8	; 0x08
     b04:	31 85       	ldd	r19, Z+9	; 0x09
     b06:	18 96       	adiw	r26, 0x08	; 8
     b08:	8d 91       	ld	r24, X+
     b0a:	9c 91       	ld	r25, X
     b0c:	19 97       	sbiw	r26, 0x09	; 9
     b0e:	28 17       	cp	r18, r24
     b10:	39 07       	cpc	r19, r25
     b12:	61 f4       	brne	.+24     	; 0xb2c <processChords+0x1bc>
     b14:	22 85       	ldd	r18, Z+10	; 0x0a
     b16:	33 85       	ldd	r19, Z+11	; 0x0b
     b18:	1a 96       	adiw	r26, 0x0a	; 10
     b1a:	8d 91       	ld	r24, X+
     b1c:	9c 91       	ld	r25, X
     b1e:	1b 97       	sbiw	r26, 0x0b	; 11
     b20:	28 17       	cp	r18, r24
     b22:	39 07       	cpc	r19, r25
     b24:	19 f4       	brne	.+6      	; 0xb2c <processChords+0x1bc>
	   stringState[2] == buttonStringPatterns[2][2] &&
	   stringState[3] == buttonStringPatterns[2][3] &&
	   stringState[4] == buttonStringPatterns[2][4] &&
	   stringState[5] == buttonStringPatterns[2][5]  ) 
		{
			 data->yellowOn = 1;
     b26:	81 e0       	ldi	r24, 0x01	; 1
     b28:	f8 01       	movw	r30, r16
     b2a:	58 c1       	rjmp	.+688    	; 0xddc <processChords+0x46c>
  		}
	// blue
	else if(stringState[0] == buttonStringPatterns[3][0] &&
     b2c:	de 01       	movw	r26, r28
     b2e:	94 96       	adiw	r26, 0x24	; 36
     b30:	8c a1       	ldd	r24, Y+36	; 0x24
     b32:	9d a1       	ldd	r25, Y+37	; 0x25
     b34:	48 17       	cp	r20, r24
     b36:	59 07       	cpc	r21, r25
     b38:	81 f5       	brne	.+96     	; 0xb9a <processChords+0x22a>
     b3a:	22 81       	ldd	r18, Z+2	; 0x02
     b3c:	33 81       	ldd	r19, Z+3	; 0x03
     b3e:	12 96       	adiw	r26, 0x02	; 2
     b40:	8d 91       	ld	r24, X+
     b42:	9c 91       	ld	r25, X
     b44:	13 97       	sbiw	r26, 0x03	; 3
     b46:	28 17       	cp	r18, r24
     b48:	39 07       	cpc	r19, r25
     b4a:	39 f5       	brne	.+78     	; 0xb9a <processChords+0x22a>
     b4c:	24 81       	ldd	r18, Z+4	; 0x04
     b4e:	35 81       	ldd	r19, Z+5	; 0x05
     b50:	14 96       	adiw	r26, 0x04	; 4
     b52:	8d 91       	ld	r24, X+
     b54:	9c 91       	ld	r25, X
     b56:	15 97       	sbiw	r26, 0x05	; 5
     b58:	28 17       	cp	r18, r24
     b5a:	39 07       	cpc	r19, r25
     b5c:	f1 f4       	brne	.+60     	; 0xb9a <processChords+0x22a>
     b5e:	26 81       	ldd	r18, Z+6	; 0x06
     b60:	37 81       	ldd	r19, Z+7	; 0x07
     b62:	16 96       	adiw	r26, 0x06	; 6
     b64:	8d 91       	ld	r24, X+
     b66:	9c 91       	ld	r25, X
     b68:	17 97       	sbiw	r26, 0x07	; 7
     b6a:	28 17       	cp	r18, r24
     b6c:	39 07       	cpc	r19, r25
     b6e:	a9 f4       	brne	.+42     	; 0xb9a <processChords+0x22a>
     b70:	20 85       	ldd	r18, Z+8	; 0x08
     b72:	31 85       	ldd	r19, Z+9	; 0x09
     b74:	18 96       	adiw	r26, 0x08	; 8
     b76:	8d 91       	ld	r24, X+
     b78:	9c 91       	ld	r25, X
     b7a:	19 97       	sbiw	r26, 0x09	; 9
     b7c:	28 17       	cp	r18, r24
     b7e:	39 07       	cpc	r19, r25
     b80:	61 f4       	brne	.+24     	; 0xb9a <processChords+0x22a>
     b82:	22 85       	ldd	r18, Z+10	; 0x0a
     b84:	33 85       	ldd	r19, Z+11	; 0x0b
     b86:	1a 96       	adiw	r26, 0x0a	; 10
     b88:	8d 91       	ld	r24, X+
     b8a:	9c 91       	ld	r25, X
     b8c:	1b 97       	sbiw	r26, 0x0b	; 11
     b8e:	28 17       	cp	r18, r24
     b90:	39 07       	cpc	r19, r25
     b92:	19 f4       	brne	.+6      	; 0xb9a <processChords+0x22a>
	   stringState[2] == buttonStringPatterns[3][2] &&
	   stringState[3] == buttonStringPatterns[3][3] &&
	   stringState[4] == buttonStringPatterns[3][4] &&
	   stringState[5] == buttonStringPatterns[3][5]  ) 
		{
			 data->blueOn = 1;
     b94:	81 e0       	ldi	r24, 0x01	; 1
     b96:	d8 01       	movw	r26, r16
     b98:	5e c1       	rjmp	.+700    	; 0xe56 <processChords+0x4e6>
  		}
	// orange
	else if(stringState[0] == buttonStringPatterns[4][0] &&
     b9a:	de 01       	movw	r26, r28
     b9c:	d0 96       	adiw	r26, 0x30	; 48
     b9e:	88 a9       	ldd	r24, Y+48	; 0x30
     ba0:	99 a9       	ldd	r25, Y+49	; 0x31
     ba2:	48 17       	cp	r20, r24
     ba4:	59 07       	cpc	r21, r25
     ba6:	89 f5       	brne	.+98     	; 0xc0a <processChords+0x29a>
     ba8:	22 81       	ldd	r18, Z+2	; 0x02
     baa:	33 81       	ldd	r19, Z+3	; 0x03
     bac:	12 96       	adiw	r26, 0x02	; 2
     bae:	8d 91       	ld	r24, X+
     bb0:	9c 91       	ld	r25, X
     bb2:	13 97       	sbiw	r26, 0x03	; 3
     bb4:	28 17       	cp	r18, r24
     bb6:	39 07       	cpc	r19, r25
     bb8:	41 f5       	brne	.+80     	; 0xc0a <processChords+0x29a>
     bba:	24 81       	ldd	r18, Z+4	; 0x04
     bbc:	35 81       	ldd	r19, Z+5	; 0x05
     bbe:	14 96       	adiw	r26, 0x04	; 4
     bc0:	8d 91       	ld	r24, X+
     bc2:	9c 91       	ld	r25, X
     bc4:	15 97       	sbiw	r26, 0x05	; 5
     bc6:	28 17       	cp	r18, r24
     bc8:	39 07       	cpc	r19, r25
     bca:	f9 f4       	brne	.+62     	; 0xc0a <processChords+0x29a>
     bcc:	26 81       	ldd	r18, Z+6	; 0x06
     bce:	37 81       	ldd	r19, Z+7	; 0x07
     bd0:	16 96       	adiw	r26, 0x06	; 6
     bd2:	8d 91       	ld	r24, X+
     bd4:	9c 91       	ld	r25, X
     bd6:	17 97       	sbiw	r26, 0x07	; 7
     bd8:	28 17       	cp	r18, r24
     bda:	39 07       	cpc	r19, r25
     bdc:	b1 f4       	brne	.+44     	; 0xc0a <processChords+0x29a>
     bde:	20 85       	ldd	r18, Z+8	; 0x08
     be0:	31 85       	ldd	r19, Z+9	; 0x09
     be2:	18 96       	adiw	r26, 0x08	; 8
     be4:	8d 91       	ld	r24, X+
     be6:	9c 91       	ld	r25, X
     be8:	19 97       	sbiw	r26, 0x09	; 9
     bea:	28 17       	cp	r18, r24
     bec:	39 07       	cpc	r19, r25
     bee:	69 f4       	brne	.+26     	; 0xc0a <processChords+0x29a>
     bf0:	22 85       	ldd	r18, Z+10	; 0x0a
     bf2:	33 85       	ldd	r19, Z+11	; 0x0b
     bf4:	1a 96       	adiw	r26, 0x0a	; 10
     bf6:	8d 91       	ld	r24, X+
     bf8:	9c 91       	ld	r25, X
     bfa:	1b 97       	sbiw	r26, 0x0b	; 11
     bfc:	28 17       	cp	r18, r24
     bfe:	39 07       	cpc	r19, r25
     c00:	21 f4       	brne	.+8      	; 0xc0a <processChords+0x29a>
	   stringState[2] == buttonStringPatterns[4][2] &&
	   stringState[3] == buttonStringPatterns[4][3] &&
	   stringState[4] == buttonStringPatterns[4][4] &&
	   stringState[5] == buttonStringPatterns[4][5]  ) 
		{
			 data->orangeOn = 1;
     c02:	81 e0       	ldi	r24, 0x01	; 1
     c04:	f8 01       	movw	r30, r16
     c06:	84 83       	std	Z+4, r24	; 0x04
     c08:	28 c1       	rjmp	.+592    	; 0xe5a <processChords+0x4ea>
  		}
	//Green and Red
	else if(stringState[0] == buttonStringPatterns[5][0] &&
     c0a:	de 01       	movw	r26, r28
     c0c:	dc 96       	adiw	r26, 0x3c	; 60
     c0e:	8c ad       	ldd	r24, Y+60	; 0x3c
     c10:	9d ad       	ldd	r25, Y+61	; 0x3d
     c12:	48 17       	cp	r20, r24
     c14:	59 07       	cpc	r21, r25
     c16:	99 f5       	brne	.+102    	; 0xc7e <processChords+0x30e>
     c18:	22 81       	ldd	r18, Z+2	; 0x02
     c1a:	33 81       	ldd	r19, Z+3	; 0x03
     c1c:	12 96       	adiw	r26, 0x02	; 2
     c1e:	8d 91       	ld	r24, X+
     c20:	9c 91       	ld	r25, X
     c22:	13 97       	sbiw	r26, 0x03	; 3
     c24:	28 17       	cp	r18, r24
     c26:	39 07       	cpc	r19, r25
     c28:	51 f5       	brne	.+84     	; 0xc7e <processChords+0x30e>
     c2a:	24 81       	ldd	r18, Z+4	; 0x04
     c2c:	35 81       	ldd	r19, Z+5	; 0x05
     c2e:	14 96       	adiw	r26, 0x04	; 4
     c30:	8d 91       	ld	r24, X+
     c32:	9c 91       	ld	r25, X
     c34:	15 97       	sbiw	r26, 0x05	; 5
     c36:	28 17       	cp	r18, r24
     c38:	39 07       	cpc	r19, r25
     c3a:	09 f5       	brne	.+66     	; 0xc7e <processChords+0x30e>
     c3c:	26 81       	ldd	r18, Z+6	; 0x06
     c3e:	37 81       	ldd	r19, Z+7	; 0x07
     c40:	16 96       	adiw	r26, 0x06	; 6
     c42:	8d 91       	ld	r24, X+
     c44:	9c 91       	ld	r25, X
     c46:	17 97       	sbiw	r26, 0x07	; 7
     c48:	28 17       	cp	r18, r24
     c4a:	39 07       	cpc	r19, r25
     c4c:	c1 f4       	brne	.+48     	; 0xc7e <processChords+0x30e>
     c4e:	20 85       	ldd	r18, Z+8	; 0x08
     c50:	31 85       	ldd	r19, Z+9	; 0x09
     c52:	18 96       	adiw	r26, 0x08	; 8
     c54:	8d 91       	ld	r24, X+
     c56:	9c 91       	ld	r25, X
     c58:	19 97       	sbiw	r26, 0x09	; 9
     c5a:	28 17       	cp	r18, r24
     c5c:	39 07       	cpc	r19, r25
     c5e:	79 f4       	brne	.+30     	; 0xc7e <processChords+0x30e>
     c60:	22 85       	ldd	r18, Z+10	; 0x0a
     c62:	33 85       	ldd	r19, Z+11	; 0x0b
     c64:	1a 96       	adiw	r26, 0x0a	; 10
     c66:	8d 91       	ld	r24, X+
     c68:	9c 91       	ld	r25, X
     c6a:	1b 97       	sbiw	r26, 0x0b	; 11
     c6c:	28 17       	cp	r18, r24
     c6e:	39 07       	cpc	r19, r25
     c70:	31 f4       	brne	.+12     	; 0xc7e <processChords+0x30e>
	   stringState[2] == buttonStringPatterns[5][2] &&
	   stringState[3] == buttonStringPatterns[5][3] &&
	   stringState[4] == buttonStringPatterns[5][4] &&
	   stringState[5] == buttonStringPatterns[5][5]  ) 
		{
			data->greenOn = 1;
     c72:	81 e0       	ldi	r24, 0x01	; 1
     c74:	d8 01       	movw	r26, r16
     c76:	8c 93       	st	X, r24
			data->redOn = 1;
     c78:	11 96       	adiw	r26, 0x01	; 1
     c7a:	8c 93       	st	X, r24
     c7c:	ee c0       	rjmp	.+476    	; 0xe5a <processChords+0x4ea>
  		}
	//Red and Yellow
	else if(stringState[0] == buttonStringPatterns[6][0] &&
     c7e:	de 01       	movw	r26, r28
     c80:	a8 5b       	subi	r26, 0xB8	; 184
     c82:	bf 4f       	sbci	r27, 0xFF	; 255
     c84:	8d 91       	ld	r24, X+
     c86:	9c 91       	ld	r25, X
     c88:	11 97       	sbiw	r26, 0x01	; 1
     c8a:	48 17       	cp	r20, r24
     c8c:	59 07       	cpc	r21, r25
     c8e:	89 f5       	brne	.+98     	; 0xcf2 <processChords+0x382>
     c90:	22 81       	ldd	r18, Z+2	; 0x02
     c92:	33 81       	ldd	r19, Z+3	; 0x03
     c94:	12 96       	adiw	r26, 0x02	; 2
     c96:	8d 91       	ld	r24, X+
     c98:	9c 91       	ld	r25, X
     c9a:	13 97       	sbiw	r26, 0x03	; 3
     c9c:	28 17       	cp	r18, r24
     c9e:	39 07       	cpc	r19, r25
     ca0:	41 f5       	brne	.+80     	; 0xcf2 <processChords+0x382>
     ca2:	24 81       	ldd	r18, Z+4	; 0x04
     ca4:	35 81       	ldd	r19, Z+5	; 0x05
     ca6:	14 96       	adiw	r26, 0x04	; 4
     ca8:	8d 91       	ld	r24, X+
     caa:	9c 91       	ld	r25, X
     cac:	15 97       	sbiw	r26, 0x05	; 5
     cae:	28 17       	cp	r18, r24
     cb0:	39 07       	cpc	r19, r25
     cb2:	f9 f4       	brne	.+62     	; 0xcf2 <processChords+0x382>
     cb4:	26 81       	ldd	r18, Z+6	; 0x06
     cb6:	37 81       	ldd	r19, Z+7	; 0x07
     cb8:	16 96       	adiw	r26, 0x06	; 6
     cba:	8d 91       	ld	r24, X+
     cbc:	9c 91       	ld	r25, X
     cbe:	17 97       	sbiw	r26, 0x07	; 7
     cc0:	28 17       	cp	r18, r24
     cc2:	39 07       	cpc	r19, r25
     cc4:	b1 f4       	brne	.+44     	; 0xcf2 <processChords+0x382>
     cc6:	20 85       	ldd	r18, Z+8	; 0x08
     cc8:	31 85       	ldd	r19, Z+9	; 0x09
     cca:	18 96       	adiw	r26, 0x08	; 8
     ccc:	8d 91       	ld	r24, X+
     cce:	9c 91       	ld	r25, X
     cd0:	19 97       	sbiw	r26, 0x09	; 9
     cd2:	28 17       	cp	r18, r24
     cd4:	39 07       	cpc	r19, r25
     cd6:	69 f4       	brne	.+26     	; 0xcf2 <processChords+0x382>
     cd8:	22 85       	ldd	r18, Z+10	; 0x0a
     cda:	33 85       	ldd	r19, Z+11	; 0x0b
     cdc:	1a 96       	adiw	r26, 0x0a	; 10
     cde:	8d 91       	ld	r24, X+
     ce0:	9c 91       	ld	r25, X
     ce2:	1b 97       	sbiw	r26, 0x0b	; 11
     ce4:	28 17       	cp	r18, r24
     ce6:	39 07       	cpc	r19, r25
     ce8:	21 f4       	brne	.+8      	; 0xcf2 <processChords+0x382>
	   stringState[2] == buttonStringPatterns[6][2] &&
	   stringState[3] == buttonStringPatterns[6][3] &&
	   stringState[4] == buttonStringPatterns[6][4] &&
	   stringState[5] == buttonStringPatterns[6][5]  ) 
		{
			data->redOn = 1;
     cea:	81 e0       	ldi	r24, 0x01	; 1
     cec:	f8 01       	movw	r30, r16
     cee:	81 83       	std	Z+1, r24	; 0x01
     cf0:	75 c0       	rjmp	.+234    	; 0xddc <processChords+0x46c>
			data->yellowOn = 1;
  		}
	// Yellow and Blue
	else if(stringState[0] == buttonStringPatterns[7][0] &&
     cf2:	de 01       	movw	r26, r28
     cf4:	ac 5a       	subi	r26, 0xAC	; 172
     cf6:	bf 4f       	sbci	r27, 0xFF	; 255
     cf8:	8d 91       	ld	r24, X+
     cfa:	9c 91       	ld	r25, X
     cfc:	11 97       	sbiw	r26, 0x01	; 1
     cfe:	48 17       	cp	r20, r24
     d00:	59 07       	cpc	r21, r25
     d02:	99 f5       	brne	.+102    	; 0xd6a <processChords+0x3fa>
     d04:	22 81       	ldd	r18, Z+2	; 0x02
     d06:	33 81       	ldd	r19, Z+3	; 0x03
     d08:	12 96       	adiw	r26, 0x02	; 2
     d0a:	8d 91       	ld	r24, X+
     d0c:	9c 91       	ld	r25, X
     d0e:	13 97       	sbiw	r26, 0x03	; 3
     d10:	28 17       	cp	r18, r24
     d12:	39 07       	cpc	r19, r25
     d14:	51 f5       	brne	.+84     	; 0xd6a <processChords+0x3fa>
     d16:	24 81       	ldd	r18, Z+4	; 0x04
     d18:	35 81       	ldd	r19, Z+5	; 0x05
     d1a:	14 96       	adiw	r26, 0x04	; 4
     d1c:	8d 91       	ld	r24, X+
     d1e:	9c 91       	ld	r25, X
     d20:	15 97       	sbiw	r26, 0x05	; 5
     d22:	28 17       	cp	r18, r24
     d24:	39 07       	cpc	r19, r25
     d26:	09 f5       	brne	.+66     	; 0xd6a <processChords+0x3fa>
     d28:	26 81       	ldd	r18, Z+6	; 0x06
     d2a:	37 81       	ldd	r19, Z+7	; 0x07
     d2c:	16 96       	adiw	r26, 0x06	; 6
     d2e:	8d 91       	ld	r24, X+
     d30:	9c 91       	ld	r25, X
     d32:	17 97       	sbiw	r26, 0x07	; 7
     d34:	28 17       	cp	r18, r24
     d36:	39 07       	cpc	r19, r25
     d38:	c1 f4       	brne	.+48     	; 0xd6a <processChords+0x3fa>
     d3a:	20 85       	ldd	r18, Z+8	; 0x08
     d3c:	31 85       	ldd	r19, Z+9	; 0x09
     d3e:	18 96       	adiw	r26, 0x08	; 8
     d40:	8d 91       	ld	r24, X+
     d42:	9c 91       	ld	r25, X
     d44:	19 97       	sbiw	r26, 0x09	; 9
     d46:	28 17       	cp	r18, r24
     d48:	39 07       	cpc	r19, r25
     d4a:	79 f4       	brne	.+30     	; 0xd6a <processChords+0x3fa>
     d4c:	22 85       	ldd	r18, Z+10	; 0x0a
     d4e:	33 85       	ldd	r19, Z+11	; 0x0b
     d50:	1a 96       	adiw	r26, 0x0a	; 10
     d52:	8d 91       	ld	r24, X+
     d54:	9c 91       	ld	r25, X
     d56:	1b 97       	sbiw	r26, 0x0b	; 11
     d58:	28 17       	cp	r18, r24
     d5a:	39 07       	cpc	r19, r25
     d5c:	31 f4       	brne	.+12     	; 0xd6a <processChords+0x3fa>
	   stringState[2] == buttonStringPatterns[7][2] &&
	   stringState[3] == buttonStringPatterns[7][3] &&
	   stringState[4] == buttonStringPatterns[7][4] &&
	   stringState[5] == buttonStringPatterns[7][5]  ) 
		{
			 data->yellowOn = 1;
     d5e:	81 e0       	ldi	r24, 0x01	; 1
     d60:	d8 01       	movw	r26, r16
     d62:	12 96       	adiw	r26, 0x02	; 2
     d64:	8c 93       	st	X, r24
     d66:	12 97       	sbiw	r26, 0x02	; 2
     d68:	76 c0       	rjmp	.+236    	; 0xe56 <processChords+0x4e6>
			 data->blueOn = 1;
  		}
	// Green and Yellow
	else if(stringState[0] == buttonStringPatterns[8][0] &&
     d6a:	de 01       	movw	r26, r28
     d6c:	a0 5a       	subi	r26, 0xA0	; 160
     d6e:	bf 4f       	sbci	r27, 0xFF	; 255
     d70:	8d 91       	ld	r24, X+
     d72:	9c 91       	ld	r25, X
     d74:	11 97       	sbiw	r26, 0x01	; 1
     d76:	48 17       	cp	r20, r24
     d78:	59 07       	cpc	r21, r25
     d7a:	91 f5       	brne	.+100    	; 0xde0 <processChords+0x470>
     d7c:	22 81       	ldd	r18, Z+2	; 0x02
     d7e:	33 81       	ldd	r19, Z+3	; 0x03
     d80:	12 96       	adiw	r26, 0x02	; 2
     d82:	8d 91       	ld	r24, X+
     d84:	9c 91       	ld	r25, X
     d86:	13 97       	sbiw	r26, 0x03	; 3
     d88:	28 17       	cp	r18, r24
     d8a:	39 07       	cpc	r19, r25
     d8c:	49 f5       	brne	.+82     	; 0xde0 <processChords+0x470>
     d8e:	24 81       	ldd	r18, Z+4	; 0x04
     d90:	35 81       	ldd	r19, Z+5	; 0x05
     d92:	14 96       	adiw	r26, 0x04	; 4
     d94:	8d 91       	ld	r24, X+
     d96:	9c 91       	ld	r25, X
     d98:	15 97       	sbiw	r26, 0x05	; 5
     d9a:	28 17       	cp	r18, r24
     d9c:	39 07       	cpc	r19, r25
     d9e:	01 f5       	brne	.+64     	; 0xde0 <processChords+0x470>
     da0:	26 81       	ldd	r18, Z+6	; 0x06
     da2:	37 81       	ldd	r19, Z+7	; 0x07
     da4:	16 96       	adiw	r26, 0x06	; 6
     da6:	8d 91       	ld	r24, X+
     da8:	9c 91       	ld	r25, X
     daa:	17 97       	sbiw	r26, 0x07	; 7
     dac:	28 17       	cp	r18, r24
     dae:	39 07       	cpc	r19, r25
     db0:	b9 f4       	brne	.+46     	; 0xde0 <processChords+0x470>
     db2:	20 85       	ldd	r18, Z+8	; 0x08
     db4:	31 85       	ldd	r19, Z+9	; 0x09
     db6:	18 96       	adiw	r26, 0x08	; 8
     db8:	8d 91       	ld	r24, X+
     dba:	9c 91       	ld	r25, X
     dbc:	19 97       	sbiw	r26, 0x09	; 9
     dbe:	28 17       	cp	r18, r24
     dc0:	39 07       	cpc	r19, r25
     dc2:	71 f4       	brne	.+28     	; 0xde0 <processChords+0x470>
     dc4:	22 85       	ldd	r18, Z+10	; 0x0a
     dc6:	33 85       	ldd	r19, Z+11	; 0x0b
     dc8:	1a 96       	adiw	r26, 0x0a	; 10
     dca:	8d 91       	ld	r24, X+
     dcc:	9c 91       	ld	r25, X
     dce:	1b 97       	sbiw	r26, 0x0b	; 11
     dd0:	28 17       	cp	r18, r24
     dd2:	39 07       	cpc	r19, r25
     dd4:	29 f4       	brne	.+10     	; 0xde0 <processChords+0x470>
	   stringState[2] == buttonStringPatterns[8][2] &&
	   stringState[3] == buttonStringPatterns[8][3] &&
	   stringState[4] == buttonStringPatterns[8][4] &&
	   stringState[5] == buttonStringPatterns[8][5]  ) 
		{
			 data->greenOn = 1;
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	f8 01       	movw	r30, r16
     dda:	80 83       	st	Z, r24
			 data->yellowOn = 1;
     ddc:	82 83       	std	Z+2, r24	; 0x02
     dde:	3d c0       	rjmp	.+122    	; 0xe5a <processChords+0x4ea>
  		}
	// Red and Blue
	else if(stringState[0] == buttonStringPatterns[9][0] &&
     de0:	de 01       	movw	r26, r28
     de2:	a4 59       	subi	r26, 0x94	; 148
     de4:	bf 4f       	sbci	r27, 0xFF	; 255
     de6:	8d 91       	ld	r24, X+
     de8:	9c 91       	ld	r25, X
     dea:	11 97       	sbiw	r26, 0x01	; 1
     dec:	48 17       	cp	r20, r24
     dee:	59 07       	cpc	r21, r25
     df0:	a1 f5       	brne	.+104    	; 0xe5a <processChords+0x4ea>
     df2:	22 81       	ldd	r18, Z+2	; 0x02
     df4:	33 81       	ldd	r19, Z+3	; 0x03
     df6:	12 96       	adiw	r26, 0x02	; 2
     df8:	8d 91       	ld	r24, X+
     dfa:	9c 91       	ld	r25, X
     dfc:	13 97       	sbiw	r26, 0x03	; 3
     dfe:	28 17       	cp	r18, r24
     e00:	39 07       	cpc	r19, r25
     e02:	59 f5       	brne	.+86     	; 0xe5a <processChords+0x4ea>
     e04:	24 81       	ldd	r18, Z+4	; 0x04
     e06:	35 81       	ldd	r19, Z+5	; 0x05
     e08:	14 96       	adiw	r26, 0x04	; 4
     e0a:	8d 91       	ld	r24, X+
     e0c:	9c 91       	ld	r25, X
     e0e:	15 97       	sbiw	r26, 0x05	; 5
     e10:	28 17       	cp	r18, r24
     e12:	39 07       	cpc	r19, r25
     e14:	11 f5       	brne	.+68     	; 0xe5a <processChords+0x4ea>
     e16:	26 81       	ldd	r18, Z+6	; 0x06
     e18:	37 81       	ldd	r19, Z+7	; 0x07
     e1a:	16 96       	adiw	r26, 0x06	; 6
     e1c:	8d 91       	ld	r24, X+
     e1e:	9c 91       	ld	r25, X
     e20:	17 97       	sbiw	r26, 0x07	; 7
     e22:	28 17       	cp	r18, r24
     e24:	39 07       	cpc	r19, r25
     e26:	c9 f4       	brne	.+50     	; 0xe5a <processChords+0x4ea>
     e28:	20 85       	ldd	r18, Z+8	; 0x08
     e2a:	31 85       	ldd	r19, Z+9	; 0x09
     e2c:	18 96       	adiw	r26, 0x08	; 8
     e2e:	8d 91       	ld	r24, X+
     e30:	9c 91       	ld	r25, X
     e32:	19 97       	sbiw	r26, 0x09	; 9
     e34:	28 17       	cp	r18, r24
     e36:	39 07       	cpc	r19, r25
     e38:	81 f4       	brne	.+32     	; 0xe5a <processChords+0x4ea>
     e3a:	22 85       	ldd	r18, Z+10	; 0x0a
     e3c:	33 85       	ldd	r19, Z+11	; 0x0b
     e3e:	1a 96       	adiw	r26, 0x0a	; 10
     e40:	8d 91       	ld	r24, X+
     e42:	9c 91       	ld	r25, X
     e44:	1b 97       	sbiw	r26, 0x0b	; 11
     e46:	28 17       	cp	r18, r24
     e48:	39 07       	cpc	r19, r25
     e4a:	39 f4       	brne	.+14     	; 0xe5a <processChords+0x4ea>
	   stringState[2] == buttonStringPatterns[9][2] &&
	   stringState[3] == buttonStringPatterns[9][3] &&
	   stringState[4] == buttonStringPatterns[9][4] &&
	   stringState[5] == buttonStringPatterns[9][5]  ) 
		{
			 data->redOn = 1;
     e4c:	81 e0       	ldi	r24, 0x01	; 1
     e4e:	d8 01       	movw	r26, r16
     e50:	11 96       	adiw	r26, 0x01	; 1
     e52:	8c 93       	st	X, r24
     e54:	11 97       	sbiw	r26, 0x01	; 1
			 data->blueOn = 1;
     e56:	13 96       	adiw	r26, 0x03	; 3
     e58:	8c 93       	st	X, r24
  		}



	return;
}
     e5a:	df 91       	pop	r29
     e5c:	cf 91       	pop	r28
     e5e:	1f 91       	pop	r17
     e60:	0f 91       	pop	r16
     e62:	08 95       	ret

00000e64 <processNotes>:

void processNotes(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
     e64:	ef 92       	push	r14
     e66:	ff 92       	push	r15
     e68:	0f 93       	push	r16
     e6a:	1f 93       	push	r17
     e6c:	cf 93       	push	r28
     e6e:	df 93       	push	r29
     e70:	fc 01       	movw	r30, r24
	/* If we're playing with notes on a scale, then we have to figure out if the proper note is being
	   played, and also if we strummed the correct string.
	 */
	// First thing, we need to reset the strumming code, since we need to check and see if we 
	//  strummed on the correct string or not
	data->upOn = 0;
     e72:	15 82       	std	Z+5, r1	; 0x05
	data->downOn = 0;
     e74:	16 82       	std	Z+6, r1	; 0x06
     e76:	db 01       	movw	r26, r22
     e78:	7a 01       	movw	r14, r20
     e7a:	ba 01       	movw	r22, r20
     e7c:	6c 5d       	subi	r22, 0xDC	; 220
     e7e:	7f 4f       	sbci	r23, 0xFF	; 255
     e80:	4f ef       	ldi	r20, 0xFF	; 255
     e82:	00 e0       	ldi	r16, 0x00	; 0
     e84:	50 e0       	ldi	r21, 0x00	; 0
					buttonPressed = 1;
					}				
				if (stringState[i] == buttonStringPatterns[4][i] && 
										buttonStringPatterns[4][i] != 0)
				{
					data->orangeOn =  1;
     e86:	11 e0       	ldi	r17, 0x01	; 1
	char strumOn = -1; // This holds which string the pick is strumming
	char buttonPressed = 0;
	char strumPressed  = 0;
	for (int i = 0; i < 6; i++)
	{
		if (stringState[i] != 0) // Only look at strings that are being touched or strummed
     e88:	8d 91       	ld	r24, X+
     e8a:	9c 91       	ld	r25, X
     e8c:	11 97       	sbiw	r26, 0x01	; 1
     e8e:	00 97       	sbiw	r24, 0x00	; 0
     e90:	09 f4       	brne	.+2      	; 0xe94 <processNotes+0x30>
     e92:	7c c0       	rjmp	.+248    	; 0xf8c <processNotes+0x128>
		{
			// Check for open strings being strummed first
			if (stringState[i] == 1) // This means we're strumming an open string
     e94:	81 30       	cpi	r24, 0x01	; 1
     e96:	91 05       	cpc	r25, r1
     e98:	a1 f5       	brne	.+104    	; 0xf02 <processNotes+0x9e>
			{
				if (stringState[i] == buttonStringPatterns[0][i])
     e9a:	e7 01       	movw	r28, r14
     e9c:	88 81       	ld	r24, Y
     e9e:	99 81       	ldd	r25, Y+1	; 0x01
     ea0:	01 97       	sbiw	r24, 0x01	; 1
     ea2:	11 f4       	brne	.+4      	; 0xea8 <processNotes+0x44>
				{
					strumOn = i;
					data->greenOn =  1;	
     ea4:	10 83       	st	Z, r17
     ea6:	45 2f       	mov	r20, r21
				}
				if (stringState[i] == buttonStringPatterns[1][i])
     ea8:	2d 91       	ld	r18, X+
     eaa:	3c 91       	ld	r19, X
     eac:	11 97       	sbiw	r26, 0x01	; 1
     eae:	e7 01       	movw	r28, r14
     eb0:	8c 85       	ldd	r24, Y+12	; 0x0c
     eb2:	9d 85       	ldd	r25, Y+13	; 0x0d
     eb4:	28 17       	cp	r18, r24
     eb6:	39 07       	cpc	r19, r25
     eb8:	11 f4       	brne	.+4      	; 0xebe <processNotes+0x5a>
				{
					strumOn = i;
					data->redOn =  1;	
     eba:	11 83       	std	Z+1, r17	; 0x01
     ebc:	45 2f       	mov	r20, r21
				}
				if (stringState[i] == buttonStringPatterns[2][i])
     ebe:	2d 91       	ld	r18, X+
     ec0:	3c 91       	ld	r19, X
     ec2:	11 97       	sbiw	r26, 0x01	; 1
     ec4:	e7 01       	movw	r28, r14
     ec6:	88 8d       	ldd	r24, Y+24	; 0x18
     ec8:	99 8d       	ldd	r25, Y+25	; 0x19
     eca:	28 17       	cp	r18, r24
     ecc:	39 07       	cpc	r19, r25
     ece:	11 f4       	brne	.+4      	; 0xed4 <processNotes+0x70>
				{
					strumOn = i;
					data->yellowOn =  1;
     ed0:	12 83       	std	Z+2, r17	; 0x02
     ed2:	45 2f       	mov	r20, r21
				}				
				if (stringState[i] == buttonStringPatterns[3][i])
     ed4:	2d 91       	ld	r18, X+
     ed6:	3c 91       	ld	r19, X
     ed8:	11 97       	sbiw	r26, 0x01	; 1
     eda:	eb 01       	movw	r28, r22
     edc:	88 81       	ld	r24, Y
     ede:	99 81       	ldd	r25, Y+1	; 0x01
     ee0:	28 17       	cp	r18, r24
     ee2:	39 07       	cpc	r19, r25
     ee4:	11 f4       	brne	.+4      	; 0xeea <processNotes+0x86>
				{
					strumOn = i;
					data->blueOn =  1;
     ee6:	13 83       	std	Z+3, r17	; 0x03
     ee8:	45 2f       	mov	r20, r21
				}				
				if (stringState[i] == buttonStringPatterns[4][i])
     eea:	2d 91       	ld	r18, X+
     eec:	3c 91       	ld	r19, X
     eee:	11 97       	sbiw	r26, 0x01	; 1
     ef0:	eb 01       	movw	r28, r22
     ef2:	8c 85       	ldd	r24, Y+12	; 0x0c
     ef4:	9d 85       	ldd	r25, Y+13	; 0x0d
     ef6:	28 17       	cp	r18, r24
     ef8:	39 07       	cpc	r19, r25
     efa:	29 f4       	brne	.+10     	; 0xf06 <processNotes+0xa2>
				{
					strumOn = i;
					data->orangeOn =  1;				
     efc:	14 83       	std	Z+4, r17	; 0x04
     efe:	45 2f       	mov	r20, r21
     f00:	02 c0       	rjmp	.+4      	; 0xf06 <processNotes+0xa2>
			}
			 // Now we have checked for strummed notes, we need to check for pressed notes
			 //  so that we can display them for reference as well as use them when strummed
			else
				// First see if we're strumming or not
				strumPressed = stringState[i] & 1;
     f02:	08 2f       	mov	r16, r24
     f04:	01 70       	andi	r16, 0x01	; 1
				// Now ensure the strum bit is zero
				stringState[i] &= (~1);
     f06:	2d 91       	ld	r18, X+
     f08:	3c 91       	ld	r19, X
     f0a:	11 97       	sbiw	r26, 0x01	; 1
     f0c:	2e 7f       	andi	r18, 0xFE	; 254
     f0e:	11 96       	adiw	r26, 0x01	; 1
     f10:	3c 93       	st	X, r19
     f12:	2e 93       	st	-X, r18
				// Take care of displaying closed notes
				if (stringState[i] == buttonStringPatterns[0][i]&& 
     f14:	e7 01       	movw	r28, r14
     f16:	88 81       	ld	r24, Y
     f18:	99 81       	ldd	r25, Y+1	; 0x01
     f1a:	28 17       	cp	r18, r24
     f1c:	39 07       	cpc	r19, r25
     f1e:	19 f4       	brne	.+6      	; 0xf26 <processNotes+0xc2>
     f20:	23 2b       	or	r18, r19
     f22:	09 f0       	breq	.+2      	; 0xf26 <processNotes+0xc2>
										buttonStringPatterns[0][i] != 0)
				{
					data->greenOn =  1;	
     f24:	10 83       	st	Z, r17
					buttonPressed = 1;
				}
				if (stringState[i] == buttonStringPatterns[1][i] && 
     f26:	2d 91       	ld	r18, X+
     f28:	3c 91       	ld	r19, X
     f2a:	11 97       	sbiw	r26, 0x01	; 1
     f2c:	e7 01       	movw	r28, r14
     f2e:	8c 85       	ldd	r24, Y+12	; 0x0c
     f30:	9d 85       	ldd	r25, Y+13	; 0x0d
     f32:	28 17       	cp	r18, r24
     f34:	39 07       	cpc	r19, r25
     f36:	19 f4       	brne	.+6      	; 0xf3e <processNotes+0xda>
     f38:	23 2b       	or	r18, r19
     f3a:	09 f0       	breq	.+2      	; 0xf3e <processNotes+0xda>
										buttonStringPatterns[1][i] != 0)
				{
					data->redOn =  1;	
     f3c:	11 83       	std	Z+1, r17	; 0x01
					buttonPressed = 1;
				}
				if (stringState[i] == buttonStringPatterns[2][i] && 
     f3e:	2d 91       	ld	r18, X+
     f40:	3c 91       	ld	r19, X
     f42:	11 97       	sbiw	r26, 0x01	; 1
     f44:	e7 01       	movw	r28, r14
     f46:	88 8d       	ldd	r24, Y+24	; 0x18
     f48:	99 8d       	ldd	r25, Y+25	; 0x19
     f4a:	28 17       	cp	r18, r24
     f4c:	39 07       	cpc	r19, r25
     f4e:	19 f4       	brne	.+6      	; 0xf56 <processNotes+0xf2>
     f50:	23 2b       	or	r18, r19
     f52:	09 f0       	breq	.+2      	; 0xf56 <processNotes+0xf2>
										buttonStringPatterns[2][i] != 0)
					{
					data->yellowOn =  1;
     f54:	12 83       	std	Z+2, r17	; 0x02
					buttonPressed = 1;
				}
				if (stringState[i] == buttonStringPatterns[3][i] && 
     f56:	2d 91       	ld	r18, X+
     f58:	3c 91       	ld	r19, X
     f5a:	11 97       	sbiw	r26, 0x01	; 1
     f5c:	eb 01       	movw	r28, r22
     f5e:	88 81       	ld	r24, Y
     f60:	99 81       	ldd	r25, Y+1	; 0x01
     f62:	28 17       	cp	r18, r24
     f64:	39 07       	cpc	r19, r25
     f66:	19 f4       	brne	.+6      	; 0xf6e <processNotes+0x10a>
     f68:	23 2b       	or	r18, r19
     f6a:	09 f0       	breq	.+2      	; 0xf6e <processNotes+0x10a>
										buttonStringPatterns[3][i] != 0)
				{
					data->blueOn =  1;
     f6c:	13 83       	std	Z+3, r17	; 0x03
					buttonPressed = 1;
					}				
				if (stringState[i] == buttonStringPatterns[4][i] && 
     f6e:	2d 91       	ld	r18, X+
     f70:	3c 91       	ld	r19, X
     f72:	11 97       	sbiw	r26, 0x01	; 1
     f74:	eb 01       	movw	r28, r22
     f76:	8c 85       	ldd	r24, Y+12	; 0x0c
     f78:	9d 85       	ldd	r25, Y+13	; 0x0d
     f7a:	28 17       	cp	r18, r24
     f7c:	39 07       	cpc	r19, r25
     f7e:	19 f4       	brne	.+6      	; 0xf86 <processNotes+0x122>
     f80:	23 2b       	or	r18, r19
     f82:	09 f0       	breq	.+2      	; 0xf86 <processNotes+0x122>
										buttonStringPatterns[4][i] != 0)
				{
					data->orangeOn =  1;
     f84:	14 83       	std	Z+4, r17	; 0x04
					buttonPressed = 1;									
				}
					// Now deal with strumming
				if ((buttonPressed = 1) && (strumPressed == 1))
     f86:	01 30       	cpi	r16, 0x01	; 1
     f88:	09 f4       	brne	.+2      	; 0xf8c <processNotes+0x128>
     f8a:	45 2f       	mov	r20, r21
     f8c:	12 96       	adiw	r26, 0x02	; 2
     f8e:	5f 5f       	subi	r21, 0xFF	; 255
     f90:	82 e0       	ldi	r24, 0x02	; 2
     f92:	90 e0       	ldi	r25, 0x00	; 0
     f94:	e8 0e       	add	r14, r24
     f96:	f9 1e       	adc	r15, r25
     f98:	6e 5f       	subi	r22, 0xFE	; 254
     f9a:	7f 4f       	sbci	r23, 0xFF	; 255
	data->upOn = 0;
	data->downOn = 0;
	char strumOn = -1; // This holds which string the pick is strumming
	char buttonPressed = 0;
	char strumPressed  = 0;
	for (int i = 0; i < 6; i++)
     f9c:	56 30       	cpi	r21, 0x06	; 6
     f9e:	09 f0       	breq	.+2      	; 0xfa2 <processNotes+0x13e>
     fa0:	73 cf       	rjmp	.-282    	; 0xe88 <processNotes+0x24>
				}
			}
	}

	//Now set the strum buttons properly, so we can have both up and down if we're in this mode
	if ((strumOn >= 0) && (strumOn < 3))
     fa2:	43 30       	cpi	r20, 0x03	; 3
     fa4:	18 f4       	brcc	.+6      	; 0xfac <processNotes+0x148>
	{
		data->downOn = 1;
     fa6:	81 e0       	ldi	r24, 0x01	; 1
     fa8:	86 83       	std	Z+6, r24	; 0x06
     faa:	08 c0       	rjmp	.+16     	; 0xfbc <processNotes+0x158>
	}
	else if ((strumOn >= 3) && (strumOn < 6 ) && (data->downOn != 1))
     fac:	43 50       	subi	r20, 0x03	; 3
     fae:	43 30       	cpi	r20, 0x03	; 3
     fb0:	28 f4       	brcc	.+10     	; 0xfbc <processNotes+0x158>
     fb2:	86 81       	ldd	r24, Z+6	; 0x06
     fb4:	81 30       	cpi	r24, 0x01	; 1
     fb6:	11 f0       	breq	.+4      	; 0xfbc <processNotes+0x158>
	{
		data->upOn = 1;
     fb8:	81 e0       	ldi	r24, 0x01	; 1
     fba:	85 83       	std	Z+5, r24	; 0x05
	}
	return;
}
     fbc:	df 91       	pop	r29
     fbe:	cf 91       	pop	r28
     fc0:	1f 91       	pop	r17
     fc2:	0f 91       	pop	r16
     fc4:	ff 90       	pop	r15
     fc6:	ef 90       	pop	r14
     fc8:	08 95       	ret

00000fca <processFrets>:

void processFrets(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS], 
									int greenTimers[NUMBER_OF_STRINGS], int triedGreen[NUMBER_OF_STRINGS])
{
     fca:	af 92       	push	r10
     fcc:	bf 92       	push	r11
     fce:	cf 92       	push	r12
     fd0:	df 92       	push	r13
     fd2:	ff 92       	push	r15
     fd4:	0f 93       	push	r16
     fd6:	1f 93       	push	r17
     fd8:	cf 93       	push	r28
     fda:	df 93       	push	r29
     fdc:	fc 01       	movw	r30, r24
     fde:	5b 01       	movw	r10, r22
     fe0:	d8 01       	movw	r26, r16
     fe2:	89 01       	movw	r16, r18
     fe4:	60 e0       	ldi	r22, 0x00	; 0
     fe6:	70 e0       	ldi	r23, 0x00	; 0
				// now we test to see if the counter has counted high enough, and
				// if it has, then we do record a green hit.
				int test = TCNT1 - greenTimers[guitarString];
		    	if (  (data->greenOn == 0) && (( test > GREEN_TIMER_WAIT) || (test <= 0)) )
		    	{
		        	data->greenOn = 1;
     fe8:	ff 24       	eor	r15, r15
     fea:	f3 94       	inc	r15
		{
		    if (triedGreen[guitarString] == 0) // we didn't touch green last cycle
		    {        
				// so we start the counter and say we did touch it.
		      greenTimers[guitarString] = TCNT1;
		      triedGreen[guitarString] = 1;
     fec:	81 e0       	ldi	r24, 0x01	; 1
     fee:	c8 2e       	mov	r12, r24
     ff0:	d1 2c       	mov	r13, r1
		counts up to the GREEN_TIMER_WAIT, red gets activated and green doesn't.
	 */
	for(int guitarString = 0; guitarString < 6; guitarString++)
	{
		// find the proper value by masking the stringState variable for each fret
		char orange = (stringState[guitarString] & (1<<5));
     ff2:	e5 01       	movw	r28, r10
     ff4:	88 81       	ld	r24, Y
		char blue   = (stringState[guitarString] & (1<<4));
     ff6:	98 2f       	mov	r25, r24
     ff8:	90 71       	andi	r25, 0x10	; 16
		char yellow = (stringState[guitarString] & (1<<3));
     ffa:	28 2f       	mov	r18, r24
     ffc:	28 70       	andi	r18, 0x08	; 8
		char red    = (stringState[guitarString] & (1<<2));
     ffe:	38 2f       	mov	r19, r24
    1000:	34 70       	andi	r19, 0x04	; 4
		char green  = (stringState[guitarString] & (1<<1));
    1002:	48 2f       	mov	r20, r24
    1004:	42 70       	andi	r20, 0x02	; 2
		if ((orange != 0) && (blue != 0) && (data->orangeOn == 0))
    1006:	85 ff       	sbrs	r24, 5
    1008:	07 c0       	rjmp	.+14     	; 0x1018 <processFrets+0x4e>
    100a:	99 23       	and	r25, r25
    100c:	71 f0       	breq	.+28     	; 0x102a <processFrets+0x60>
    100e:	84 81       	ldd	r24, Z+4	; 0x04
    1010:	88 23       	and	r24, r24
    1012:	21 f4       	brne	.+8      	; 0x101c <processFrets+0x52>
		{    
		    data->orangeOn = 1;
    1014:	f4 82       	std	Z+4, r15	; 0x04
    1016:	40 c0       	rjmp	.+128    	; 0x1098 <processFrets+0xce>
		    triedGreen[guitarString] = 0;
		}
		else if ((blue != 0) && (yellow != 0) && (data->blueOn == 0))
    1018:	99 23       	and	r25, r25
    101a:	39 f0       	breq	.+14     	; 0x102a <processFrets+0x60>
    101c:	22 23       	and	r18, r18
    101e:	71 f0       	breq	.+28     	; 0x103c <processFrets+0x72>
    1020:	83 81       	ldd	r24, Z+3	; 0x03
    1022:	88 23       	and	r24, r24
    1024:	21 f4       	brne	.+8      	; 0x102e <processFrets+0x64>
		{
		    data->blueOn = 1;
    1026:	f3 82       	std	Z+3, r15	; 0x03
    1028:	37 c0       	rjmp	.+110    	; 0x1098 <processFrets+0xce>
		    triedGreen[guitarString] = 0;
		}
		else if ((yellow != 0) && (red != 0) && (data->yellowOn == 0))
    102a:	22 23       	and	r18, r18
    102c:	39 f0       	breq	.+14     	; 0x103c <processFrets+0x72>
    102e:	33 23       	and	r19, r19
    1030:	71 f0       	breq	.+28     	; 0x104e <processFrets+0x84>
    1032:	82 81       	ldd	r24, Z+2	; 0x02
    1034:	88 23       	and	r24, r24
    1036:	21 f4       	brne	.+8      	; 0x1040 <processFrets+0x76>
		{
		    data->yellowOn = 1;
    1038:	f2 82       	std	Z+2, r15	; 0x02
    103a:	2e c0       	rjmp	.+92     	; 0x1098 <processFrets+0xce>
		    triedGreen[guitarString] = 0;
		}
		else if ((red != 0) && (green != 0) && (data->redOn == 0))
    103c:	33 23       	and	r19, r19
    103e:	39 f0       	breq	.+14     	; 0x104e <processFrets+0x84>
    1040:	44 23       	and	r20, r20
    1042:	51 f1       	breq	.+84     	; 0x1098 <processFrets+0xce>
    1044:	81 81       	ldd	r24, Z+1	; 0x01
    1046:	88 23       	and	r24, r24
    1048:	21 f4       	brne	.+8      	; 0x1052 <processFrets+0x88>
		{
		    data->redOn = 1;
    104a:	f1 82       	std	Z+1, r15	; 0x01
    104c:	25 c0       	rjmp	.+74     	; 0x1098 <processFrets+0xce>
		    triedGreen[guitarString] = 0;
		}
		else if (green != 0)
    104e:	44 23       	and	r20, r20
    1050:	19 f1       	breq	.+70     	; 0x1098 <processFrets+0xce>
		{
		    if (triedGreen[guitarString] == 0) // we didn't touch green last cycle
    1052:	8d 91       	ld	r24, X+
    1054:	9c 91       	ld	r25, X
    1056:	11 97       	sbiw	r26, 0x01	; 1
    1058:	89 2b       	or	r24, r25
    105a:	59 f4       	brne	.+22     	; 0x1072 <processFrets+0xa8>
		    {        
				// so we start the counter and say we did touch it.
		      greenTimers[guitarString] = TCNT1;
    105c:	80 91 84 00 	lds	r24, 0x0084
    1060:	90 91 85 00 	lds	r25, 0x0085
    1064:	e8 01       	movw	r28, r16
    1066:	99 83       	std	Y+1, r25	; 0x01
    1068:	88 83       	st	Y, r24
		      triedGreen[guitarString] = 1;
    106a:	11 96       	adiw	r26, 0x01	; 1
    106c:	dc 92       	st	X, r13
    106e:	ce 92       	st	-X, r12
    1070:	16 c0       	rjmp	.+44     	; 0x109e <processFrets+0xd4>
		    }
		    else //triedGreen == true
		    {
				// now we test to see if the counter has counted high enough, and
				// if it has, then we do record a green hit.
				int test = TCNT1 - greenTimers[guitarString];
    1072:	20 91 84 00 	lds	r18, 0x0084
    1076:	30 91 85 00 	lds	r19, 0x0085
    107a:	e8 01       	movw	r28, r16
    107c:	48 81       	ld	r20, Y
    107e:	59 81       	ldd	r21, Y+1	; 0x01
		    	if (  (data->greenOn == 0) && (( test > GREEN_TIMER_WAIT) || (test <= 0)) )
    1080:	80 81       	ld	r24, Z
    1082:	88 23       	and	r24, r24
    1084:	61 f4       	brne	.+24     	; 0x109e <processFrets+0xd4>
    1086:	21 50       	subi	r18, 0x01	; 1
    1088:	30 40       	sbci	r19, 0x00	; 0
    108a:	24 1b       	sub	r18, r20
    108c:	35 0b       	sbc	r19, r21
    108e:	24 36       	cpi	r18, 0x64	; 100
    1090:	31 05       	cpc	r19, r1
    1092:	28 f0       	brcs	.+10     	; 0x109e <processFrets+0xd4>
		    	{
		        	data->greenOn = 1;
    1094:	f0 82       	st	Z, r15
    1096:	03 c0       	rjmp	.+6      	; 0x109e <processFrets+0xd4>
		    	}
		    }
		}
	    else  //no buttons pressed
	    {
	        triedGreen[guitarString] = 0;
    1098:	11 96       	adiw	r26, 0x01	; 1
    109a:	1c 92       	st	X, r1
    109c:	1e 92       	st	-X, r1
		the strum has a direction, so if you strum the
		top 3 strings, you strum down, and if you strum
		the bottom 3 strings, you're strumming up.
	*/
		// Check for strumming
		if (stringState[guitarString] & 1)
    109e:	e5 01       	movw	r28, r10
    10a0:	88 81       	ld	r24, Y
    10a2:	80 ff       	sbrs	r24, 0
    10a4:	08 c0       	rjmp	.+16     	; 0x10b6 <processFrets+0xec>
		{
			if (guitarString < 3)
    10a6:	63 30       	cpi	r22, 0x03	; 3
    10a8:	71 05       	cpc	r23, r1
    10aa:	1c f4       	brge	.+6      	; 0x10b2 <processFrets+0xe8>
			{
				data->downOn = 1;
    10ac:	f6 82       	std	Z+6, r15	; 0x06
				data->upOn   = 0;
    10ae:	15 82       	std	Z+5, r1	; 0x05
    10b0:	02 c0       	rjmp	.+4      	; 0x10b6 <processFrets+0xec>
			}
			else
			{
				data->upOn   = 1;
    10b2:	f5 82       	std	Z+5, r15	; 0x05
				data->downOn = 0;
    10b4:	16 82       	std	Z+6, r1	; 0x06
		you don't want that to register as a green button press.  So we do some
		timing on that one, so when you press just green, it starts counting
		instead of turing greenOn on, so if the red fret is turned on before it
		counts up to the GREEN_TIMER_WAIT, red gets activated and green doesn't.
	 */
	for(int guitarString = 0; guitarString < 6; guitarString++)
    10b6:	6f 5f       	subi	r22, 0xFF	; 255
    10b8:	7f 4f       	sbci	r23, 0xFF	; 255
    10ba:	82 e0       	ldi	r24, 0x02	; 2
    10bc:	90 e0       	ldi	r25, 0x00	; 0
    10be:	a8 0e       	add	r10, r24
    10c0:	b9 1e       	adc	r11, r25
    10c2:	12 96       	adiw	r26, 0x02	; 2
    10c4:	0e 5f       	subi	r16, 0xFE	; 254
    10c6:	1f 4f       	sbci	r17, 0xFF	; 255
    10c8:	66 30       	cpi	r22, 0x06	; 6
    10ca:	71 05       	cpc	r23, r1
    10cc:	09 f0       	breq	.+2      	; 0x10d0 <processFrets+0x106>
    10ce:	91 cf       	rjmp	.-222    	; 0xff2 <processFrets+0x28>
				data->downOn = 0;
			}
		}
	}	// end of for loop
	return;
}
    10d0:	df 91       	pop	r29
    10d2:	cf 91       	pop	r28
    10d4:	1f 91       	pop	r17
    10d6:	0f 91       	pop	r16
    10d8:	ff 90       	pop	r15
    10da:	df 90       	pop	r13
    10dc:	cf 90       	pop	r12
    10de:	bf 90       	pop	r11
    10e0:	af 90       	pop	r10
    10e2:	08 95       	ret

000010e4 <processStringState>:

void processStringState(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS], char controllerMode, 
									int greenTimers[NUMBER_OF_STRINGS], int triedGreen[NUMBER_OF_STRINGS])
{
    10e4:	ef 92       	push	r14
    10e6:	ff 92       	push	r15
    10e8:	0f 93       	push	r16
    10ea:	1f 93       	push	r17
	if (controllerMode == CHORDS) // If we're playing with Chords - default is FRETS
    10ec:	24 30       	cpi	r18, 0x04	; 4
    10ee:	19 f4       	brne	.+6      	; 0x10f6 <processStringState+0x12>
		processChords(data, stringState, buttonStringPatterns);
    10f0:	0e 94 b8 04 	call	0x970	; 0x970 <processChords>
    10f4:	09 c0       	rjmp	.+18     	; 0x1108 <processStringState+0x24>

	else if (controllerMode == NOTES) // We're playing with notes
    10f6:	22 30       	cpi	r18, 0x02	; 2
    10f8:	19 f4       	brne	.+6      	; 0x1100 <processStringState+0x1c>
		processNotes(data, stringState, buttonStringPatterns);
    10fa:	0e 94 32 07 	call	0xe64	; 0xe64 <processNotes>
    10fe:	04 c0       	rjmp	.+8      	; 0x1108 <processStringState+0x24>
	
	else // We're playing with frets
		processFrets(data, stringState,	buttonStringPatterns, greenTimers, triedGreen);
    1100:	98 01       	movw	r18, r16
    1102:	87 01       	movw	r16, r14
    1104:	0e 94 e5 07 	call	0xfca	; 0xfca <processFrets>

	return;	
}
    1108:	1f 91       	pop	r17
    110a:	0f 91       	pop	r16
    110c:	ff 90       	pop	r15
    110e:	ef 90       	pop	r14
    1110:	08 95       	ret

00001112 <displayTransitionState>:

// This simple function takes in the controller mode and sets the
//  data struct to certain patterns to give the user feedback
//  as to what state is being pressed
void displayTransitionState(dataForController* data, int controllerMode)
{
    1112:	fc 01       	movw	r30, r24
	if (controllerMode == FRETS_TO_NOTES)
    1114:	61 30       	cpi	r22, 0x01	; 1
    1116:	71 05       	cpc	r23, r1
    1118:	21 f4       	brne	.+8      	; 0x1122 <displayTransitionState+0x10>
	{
		data->greenOn = 1;
    111a:	81 e0       	ldi	r24, 0x01	; 1
    111c:	80 83       	st	Z, r24
		data->yellowOn = 1;
    111e:	82 83       	std	Z+2, r24	; 0x02
    1120:	08 95       	ret
	}
	else if (controllerMode == NOTES_TO_CHORDS)
    1122:	63 30       	cpi	r22, 0x03	; 3
    1124:	71 05       	cpc	r23, r1
    1126:	21 f4       	brne	.+8      	; 0x1130 <displayTransitionState+0x1e>
	{
		data->greenOn = 1;
    1128:	81 e0       	ldi	r24, 0x01	; 1
    112a:	80 83       	st	Z, r24
		data->blueOn = 1;
    112c:	83 83       	std	Z+3, r24	; 0x03
    112e:	08 95       	ret
	}
	else if (controllerMode == CHORDS_TO_FRETS)
    1130:	65 30       	cpi	r22, 0x05	; 5
    1132:	71 05       	cpc	r23, r1
    1134:	19 f4       	brne	.+6      	; 0x113c <displayTransitionState+0x2a>
	{
		data->greenOn = 1;
    1136:	81 e0       	ldi	r24, 0x01	; 1
    1138:	80 83       	st	Z, r24
		data->orangeOn = 1;
    113a:	84 83       	std	Z+4, r24	; 0x04
    113c:	08 95       	ret

0000113e <configSetButtonData>:
/* This function sets up the data struct when we're in config mode so that it shows
 *  the user which colors are currently being programmed.
 */
void configSetButtonData(dataForController* data, int* buttonToAssign, int buttonStringPatterns[][6], 
						int stringState[], char controllerMode, char* plusLock, char* previousPlusOn, int* debounceTimer)
{
    113e:	af 92       	push	r10
    1140:	bf 92       	push	r11
    1142:	cf 92       	push	r12
    1144:	df 92       	push	r13
    1146:	ef 92       	push	r14
    1148:	ff 92       	push	r15
    114a:	0f 93       	push	r16
    114c:	cf 93       	push	r28
    114e:	df 93       	push	r29
    1150:	fc 01       	movw	r30, r24
    1152:	db 01       	movw	r26, r22
    1154:	b9 01       	movw	r22, r18
    1156:	95 01       	movw	r18, r10
	// Since 'colorOn' is 1 when a fret is pressed, we invert, shift, invert, and & it to set the
	// corresponding button bit to zero, which corresponds to a button press.
	if (*buttonToAssign == 0)
    1158:	8d 91       	ld	r24, X+
    115a:	9c 91       	ld	r25, X
    115c:	11 97       	sbiw	r26, 0x01	; 1
    115e:	00 97       	sbiw	r24, 0x00	; 0
    1160:	19 f4       	brne	.+6      	; 0x1168 <configSetButtonData+0x2a>
		data->greenOn = 1;
    1162:	81 e0       	ldi	r24, 0x01	; 1
    1164:	80 83       	st	Z, r24
    1166:	34 c0       	rjmp	.+104    	; 0x11d0 <configSetButtonData+0x92>
	else if(*buttonToAssign == 1)
    1168:	81 30       	cpi	r24, 0x01	; 1
    116a:	91 05       	cpc	r25, r1
    116c:	11 f4       	brne	.+4      	; 0x1172 <configSetButtonData+0x34>
		data->redOn = 1;
    116e:	81 e0       	ldi	r24, 0x01	; 1
    1170:	15 c0       	rjmp	.+42     	; 0x119c <configSetButtonData+0x5e>
	else if(*buttonToAssign == 2)
    1172:	82 30       	cpi	r24, 0x02	; 2
    1174:	91 05       	cpc	r25, r1
    1176:	11 f4       	brne	.+4      	; 0x117c <configSetButtonData+0x3e>
		data->yellowOn = 1;
    1178:	81 e0       	ldi	r24, 0x01	; 1
    117a:	23 c0       	rjmp	.+70     	; 0x11c2 <configSetButtonData+0x84>
	else if(*buttonToAssign == 3)
    117c:	83 30       	cpi	r24, 0x03	; 3
    117e:	91 05       	cpc	r25, r1
    1180:	11 f4       	brne	.+4      	; 0x1186 <configSetButtonData+0x48>
		data->blueOn = 1;
    1182:	81 e0       	ldi	r24, 0x01	; 1
    1184:	24 c0       	rjmp	.+72     	; 0x11ce <configSetButtonData+0x90>
	else if(*buttonToAssign == 4)
    1186:	84 30       	cpi	r24, 0x04	; 4
    1188:	91 05       	cpc	r25, r1
    118a:	19 f4       	brne	.+6      	; 0x1192 <configSetButtonData+0x54>
		data->orangeOn = 1;
    118c:	81 e0       	ldi	r24, 0x01	; 1
    118e:	84 83       	std	Z+4, r24	; 0x04
    1190:	1f c0       	rjmp	.+62     	; 0x11d0 <configSetButtonData+0x92>
	else if(*buttonToAssign == 5)
    1192:	85 30       	cpi	r24, 0x05	; 5
    1194:	91 05       	cpc	r25, r1
    1196:	21 f4       	brne	.+8      	; 0x11a0 <configSetButtonData+0x62>
	{
		data->greenOn = 1;
    1198:	81 e0       	ldi	r24, 0x01	; 1
    119a:	80 83       	st	Z, r24
		data->redOn = 1;
    119c:	81 83       	std	Z+1, r24	; 0x01
    119e:	18 c0       	rjmp	.+48     	; 0x11d0 <configSetButtonData+0x92>
	}
	else if(*buttonToAssign == 6)
    11a0:	86 30       	cpi	r24, 0x06	; 6
    11a2:	91 05       	cpc	r25, r1
    11a4:	19 f4       	brne	.+6      	; 0x11ac <configSetButtonData+0x6e>
	{
		data->redOn = 1;
    11a6:	81 e0       	ldi	r24, 0x01	; 1
    11a8:	81 83       	std	Z+1, r24	; 0x01
    11aa:	0b c0       	rjmp	.+22     	; 0x11c2 <configSetButtonData+0x84>
		data->yellowOn = 1;
	}
	else if(*buttonToAssign == 7)
    11ac:	87 30       	cpi	r24, 0x07	; 7
    11ae:	91 05       	cpc	r25, r1
    11b0:	19 f4       	brne	.+6      	; 0x11b8 <configSetButtonData+0x7a>
	{
		data->yellowOn = 1;
    11b2:	81 e0       	ldi	r24, 0x01	; 1
    11b4:	82 83       	std	Z+2, r24	; 0x02
    11b6:	0b c0       	rjmp	.+22     	; 0x11ce <configSetButtonData+0x90>
		data->blueOn = 1;
	}
	else if(*buttonToAssign == 8)
    11b8:	88 30       	cpi	r24, 0x08	; 8
    11ba:	91 05       	cpc	r25, r1
    11bc:	21 f4       	brne	.+8      	; 0x11c6 <configSetButtonData+0x88>
	{
		data->greenOn = 1;
    11be:	81 e0       	ldi	r24, 0x01	; 1
    11c0:	80 83       	st	Z, r24
		data->yellowOn = 1;
    11c2:	82 83       	std	Z+2, r24	; 0x02
    11c4:	05 c0       	rjmp	.+10     	; 0x11d0 <configSetButtonData+0x92>
	}
	else if(*buttonToAssign == 9)
    11c6:	09 97       	sbiw	r24, 0x09	; 9
    11c8:	19 f4       	brne	.+6      	; 0x11d0 <configSetButtonData+0x92>
	{
		data->redOn = 1;
    11ca:	81 e0       	ldi	r24, 0x01	; 1
    11cc:	81 83       	std	Z+1, r24	; 0x01
		data->blueOn = 1;
    11ce:	83 83       	std	Z+3, r24	; 0x03
	}



	// Code to debounce our plus button, the current state of plusOn to it's recent history
	if (data->plusOn != 0)  // So we're pressing plus
    11d0:	87 81       	ldd	r24, Z+7	; 0x07
    11d2:	88 23       	and	r24, r24
    11d4:	09 f1       	breq	.+66     	; 0x1218 <configSetButtonData+0xda>
	{ 
		if (*previousPlusOn == 0)  // If we weren't pressing plus last time through the main loop
    11d6:	e6 01       	movw	r28, r12
    11d8:	88 81       	ld	r24, Y
    11da:	88 23       	and	r24, r24
    11dc:	59 f4       	brne	.+22     	; 0x11f4 <configSetButtonData+0xb6>
		{ 
			*debounceTimer = TCNT1;  // Set up a timer
    11de:	80 91 84 00 	lds	r24, 0x0084
    11e2:	90 91 85 00 	lds	r25, 0x0085
    11e6:	e9 01       	movw	r28, r18
    11e8:	99 83       	std	Y+1, r25	; 0x01
    11ea:	88 83       	st	Y, r24
			*previousPlusOn = 1;     // remember plus was pressed for the next iteration
    11ec:	81 e0       	ldi	r24, 0x01	; 1
    11ee:	e6 01       	movw	r28, r12
    11f0:	88 83       	st	Y, r24
    11f2:	10 c0       	rjmp	.+32     	; 0x1214 <configSetButtonData+0xd6>
			data->plusOn = 0;        // but for now, consider plus not pressed.
		}
		else if ( (TCNT1 - *debounceTimer < DEBOUNCE_DELAY) && (TCNT1 - *debounceTimer >= 0))
    11f4:	80 91 84 00 	lds	r24, 0x0084
    11f8:	90 91 85 00 	lds	r25, 0x0085
    11fc:	e9 01       	movw	r28, r18
    11fe:	28 81       	ld	r18, Y
    1200:	39 81       	ldd	r19, Y+1	; 0x01
    1202:	82 1b       	sub	r24, r18
    1204:	93 0b       	sbc	r25, r19
    1206:	88 5e       	subi	r24, 0xE8	; 232
    1208:	93 40       	sbci	r25, 0x03	; 3
    120a:	40 f4       	brcc	.+16     	; 0x121c <configSetButtonData+0xde>
    120c:	80 91 84 00 	lds	r24, 0x0084
    1210:	90 91 85 00 	lds	r25, 0x0085
		{
			data->plusOn = 0;  // This keeps telling us plus wasn't pressed until it's been held long enough
    1214:	17 82       	std	Z+7, r1	; 0x07
    1216:	02 c0       	rjmp	.+4      	; 0x121c <configSetButtonData+0xde>
		}		
	}
	else
	{
		*previousPlusOn = 0; // and if plus wasn't pressed, remember that for next time
    1218:	e6 01       	movw	r28, r12
    121a:	18 82       	st	Y, r1
	}

	// Now, if you press plus, it will lock in whatever string pattern
	// and advance to working on the next pattern.
	if((data->plusOn) && (*plusLock == 0))
    121c:	87 81       	ldd	r24, Z+7	; 0x07
    121e:	88 23       	and	r24, r24
    1220:	09 f4       	brne	.+2      	; 0x1224 <configSetButtonData+0xe6>
    1222:	f7 c0       	rjmp	.+494    	; 0x1412 <configSetButtonData+0x2d4>
    1224:	f7 01       	movw	r30, r14
    1226:	80 81       	ld	r24, Z
    1228:	88 23       	and	r24, r24
    122a:	09 f0       	breq	.+2      	; 0x122e <configSetButtonData+0xf0>
    122c:	f4 c0       	rjmp	.+488    	; 0x1416 <configSetButtonData+0x2d8>
	{

		if (controllerMode == CHORDS) 
    122e:	04 30       	cpi	r16, 0x04	; 4
    1230:	09 f0       	breq	.+2      	; 0x1234 <configSetButtonData+0xf6>
    1232:	60 c0       	rjmp	.+192    	; 0x12f4 <configSetButtonData+0x1b6>
		{   // Set the pattern to nothing pressed
			buttonStringPatterns[*buttonToAssign][0] = 0;
    1234:	8d 91       	ld	r24, X+
    1236:	9c 91       	ld	r25, X
    1238:	11 97       	sbiw	r26, 0x01	; 1
    123a:	fc 01       	movw	r30, r24
    123c:	ee 0f       	add	r30, r30
    123e:	ff 1f       	adc	r31, r31
    1240:	e8 0f       	add	r30, r24
    1242:	f9 1f       	adc	r31, r25
    1244:	ee 0f       	add	r30, r30
    1246:	ff 1f       	adc	r31, r31
    1248:	ee 0f       	add	r30, r30
    124a:	ff 1f       	adc	r31, r31
    124c:	e4 0f       	add	r30, r20
    124e:	f5 1f       	adc	r31, r21
    1250:	11 82       	std	Z+1, r1	; 0x01
    1252:	10 82       	st	Z, r1
			buttonStringPatterns[*buttonToAssign][1] = 0;
    1254:	8d 91       	ld	r24, X+
    1256:	9c 91       	ld	r25, X
    1258:	11 97       	sbiw	r26, 0x01	; 1
    125a:	fc 01       	movw	r30, r24
    125c:	ee 0f       	add	r30, r30
    125e:	ff 1f       	adc	r31, r31
    1260:	e8 0f       	add	r30, r24
    1262:	f9 1f       	adc	r31, r25
    1264:	ee 0f       	add	r30, r30
    1266:	ff 1f       	adc	r31, r31
    1268:	ee 0f       	add	r30, r30
    126a:	ff 1f       	adc	r31, r31
    126c:	e4 0f       	add	r30, r20
    126e:	f5 1f       	adc	r31, r21
    1270:	13 82       	std	Z+3, r1	; 0x03
    1272:	12 82       	std	Z+2, r1	; 0x02
			buttonStringPatterns[*buttonToAssign][2] = 0;
    1274:	8d 91       	ld	r24, X+
    1276:	9c 91       	ld	r25, X
    1278:	11 97       	sbiw	r26, 0x01	; 1
    127a:	fc 01       	movw	r30, r24
    127c:	ee 0f       	add	r30, r30
    127e:	ff 1f       	adc	r31, r31
    1280:	e8 0f       	add	r30, r24
    1282:	f9 1f       	adc	r31, r25
    1284:	ee 0f       	add	r30, r30
    1286:	ff 1f       	adc	r31, r31
    1288:	ee 0f       	add	r30, r30
    128a:	ff 1f       	adc	r31, r31
    128c:	e4 0f       	add	r30, r20
    128e:	f5 1f       	adc	r31, r21
    1290:	15 82       	std	Z+5, r1	; 0x05
    1292:	14 82       	std	Z+4, r1	; 0x04
			buttonStringPatterns[*buttonToAssign][3] = 0;
    1294:	8d 91       	ld	r24, X+
    1296:	9c 91       	ld	r25, X
    1298:	11 97       	sbiw	r26, 0x01	; 1
    129a:	fc 01       	movw	r30, r24
    129c:	ee 0f       	add	r30, r30
    129e:	ff 1f       	adc	r31, r31
    12a0:	e8 0f       	add	r30, r24
    12a2:	f9 1f       	adc	r31, r25
    12a4:	ee 0f       	add	r30, r30
    12a6:	ff 1f       	adc	r31, r31
    12a8:	ee 0f       	add	r30, r30
    12aa:	ff 1f       	adc	r31, r31
    12ac:	e4 0f       	add	r30, r20
    12ae:	f5 1f       	adc	r31, r21
    12b0:	17 82       	std	Z+7, r1	; 0x07
    12b2:	16 82       	std	Z+6, r1	; 0x06
			buttonStringPatterns[*buttonToAssign][4] = 0;
    12b4:	8d 91       	ld	r24, X+
    12b6:	9c 91       	ld	r25, X
    12b8:	11 97       	sbiw	r26, 0x01	; 1
    12ba:	fc 01       	movw	r30, r24
    12bc:	ee 0f       	add	r30, r30
    12be:	ff 1f       	adc	r31, r31
    12c0:	e8 0f       	add	r30, r24
    12c2:	f9 1f       	adc	r31, r25
    12c4:	ee 0f       	add	r30, r30
    12c6:	ff 1f       	adc	r31, r31
    12c8:	ee 0f       	add	r30, r30
    12ca:	ff 1f       	adc	r31, r31
    12cc:	e4 0f       	add	r30, r20
    12ce:	f5 1f       	adc	r31, r21
    12d0:	11 86       	std	Z+9, r1	; 0x09
    12d2:	10 86       	std	Z+8, r1	; 0x08
			buttonStringPatterns[*buttonToAssign][5] = 0;
    12d4:	8d 91       	ld	r24, X+
    12d6:	9c 91       	ld	r25, X
    12d8:	11 97       	sbiw	r26, 0x01	; 1
    12da:	fc 01       	movw	r30, r24
    12dc:	ee 0f       	add	r30, r30
    12de:	ff 1f       	adc	r31, r31
    12e0:	e8 0f       	add	r30, r24
    12e2:	f9 1f       	adc	r31, r25
    12e4:	ee 0f       	add	r30, r30
    12e6:	ff 1f       	adc	r31, r31
    12e8:	ee 0f       	add	r30, r30
    12ea:	ff 1f       	adc	r31, r31
    12ec:	e4 0f       	add	r30, r20
    12ee:	f5 1f       	adc	r31, r21
    12f0:	13 86       	std	Z+11, r1	; 0x0b
    12f2:	12 86       	std	Z+10, r1	; 0x0a
		}
			// Assign what's being pressed on the frets to what matches the current button press
		buttonStringPatterns[*buttonToAssign][0] |= stringState[0];
    12f4:	8d 91       	ld	r24, X+
    12f6:	9c 91       	ld	r25, X
    12f8:	11 97       	sbiw	r26, 0x01	; 1
    12fa:	fc 01       	movw	r30, r24
    12fc:	ee 0f       	add	r30, r30
    12fe:	ff 1f       	adc	r31, r31
    1300:	e8 0f       	add	r30, r24
    1302:	f9 1f       	adc	r31, r25
    1304:	ee 0f       	add	r30, r30
    1306:	ff 1f       	adc	r31, r31
    1308:	ee 0f       	add	r30, r30
    130a:	ff 1f       	adc	r31, r31
    130c:	e4 0f       	add	r30, r20
    130e:	f5 1f       	adc	r31, r21
    1310:	80 81       	ld	r24, Z
    1312:	91 81       	ldd	r25, Z+1	; 0x01
    1314:	eb 01       	movw	r28, r22
    1316:	28 81       	ld	r18, Y
    1318:	39 81       	ldd	r19, Y+1	; 0x01
    131a:	82 2b       	or	r24, r18
    131c:	93 2b       	or	r25, r19
    131e:	91 83       	std	Z+1, r25	; 0x01
    1320:	80 83       	st	Z, r24
		buttonStringPatterns[*buttonToAssign][1] |= stringState[1];
    1322:	8d 91       	ld	r24, X+
    1324:	9c 91       	ld	r25, X
    1326:	11 97       	sbiw	r26, 0x01	; 1
    1328:	fc 01       	movw	r30, r24
    132a:	ee 0f       	add	r30, r30
    132c:	ff 1f       	adc	r31, r31
    132e:	e8 0f       	add	r30, r24
    1330:	f9 1f       	adc	r31, r25
    1332:	ee 0f       	add	r30, r30
    1334:	ff 1f       	adc	r31, r31
    1336:	ee 0f       	add	r30, r30
    1338:	ff 1f       	adc	r31, r31
    133a:	e4 0f       	add	r30, r20
    133c:	f5 1f       	adc	r31, r21
    133e:	82 81       	ldd	r24, Z+2	; 0x02
    1340:	93 81       	ldd	r25, Z+3	; 0x03
    1342:	2a 81       	ldd	r18, Y+2	; 0x02
    1344:	3b 81       	ldd	r19, Y+3	; 0x03
    1346:	82 2b       	or	r24, r18
    1348:	93 2b       	or	r25, r19
    134a:	93 83       	std	Z+3, r25	; 0x03
    134c:	82 83       	std	Z+2, r24	; 0x02
		buttonStringPatterns[*buttonToAssign][2] |= stringState[2];
    134e:	8d 91       	ld	r24, X+
    1350:	9c 91       	ld	r25, X
    1352:	11 97       	sbiw	r26, 0x01	; 1
    1354:	fc 01       	movw	r30, r24
    1356:	ee 0f       	add	r30, r30
    1358:	ff 1f       	adc	r31, r31
    135a:	e8 0f       	add	r30, r24
    135c:	f9 1f       	adc	r31, r25
    135e:	ee 0f       	add	r30, r30
    1360:	ff 1f       	adc	r31, r31
    1362:	ee 0f       	add	r30, r30
    1364:	ff 1f       	adc	r31, r31
    1366:	e4 0f       	add	r30, r20
    1368:	f5 1f       	adc	r31, r21
    136a:	84 81       	ldd	r24, Z+4	; 0x04
    136c:	95 81       	ldd	r25, Z+5	; 0x05
    136e:	2c 81       	ldd	r18, Y+4	; 0x04
    1370:	3d 81       	ldd	r19, Y+5	; 0x05
    1372:	82 2b       	or	r24, r18
    1374:	93 2b       	or	r25, r19
    1376:	95 83       	std	Z+5, r25	; 0x05
    1378:	84 83       	std	Z+4, r24	; 0x04
		buttonStringPatterns[*buttonToAssign][3] |= stringState[3];
    137a:	8d 91       	ld	r24, X+
    137c:	9c 91       	ld	r25, X
    137e:	11 97       	sbiw	r26, 0x01	; 1
    1380:	fc 01       	movw	r30, r24
    1382:	ee 0f       	add	r30, r30
    1384:	ff 1f       	adc	r31, r31
    1386:	e8 0f       	add	r30, r24
    1388:	f9 1f       	adc	r31, r25
    138a:	ee 0f       	add	r30, r30
    138c:	ff 1f       	adc	r31, r31
    138e:	ee 0f       	add	r30, r30
    1390:	ff 1f       	adc	r31, r31
    1392:	e4 0f       	add	r30, r20
    1394:	f5 1f       	adc	r31, r21
    1396:	86 81       	ldd	r24, Z+6	; 0x06
    1398:	97 81       	ldd	r25, Z+7	; 0x07
    139a:	2e 81       	ldd	r18, Y+6	; 0x06
    139c:	3f 81       	ldd	r19, Y+7	; 0x07
    139e:	82 2b       	or	r24, r18
    13a0:	93 2b       	or	r25, r19
    13a2:	97 83       	std	Z+7, r25	; 0x07
    13a4:	86 83       	std	Z+6, r24	; 0x06
		buttonStringPatterns[*buttonToAssign][4] |= stringState[4];
    13a6:	8d 91       	ld	r24, X+
    13a8:	9c 91       	ld	r25, X
    13aa:	11 97       	sbiw	r26, 0x01	; 1
    13ac:	fc 01       	movw	r30, r24
    13ae:	ee 0f       	add	r30, r30
    13b0:	ff 1f       	adc	r31, r31
    13b2:	e8 0f       	add	r30, r24
    13b4:	f9 1f       	adc	r31, r25
    13b6:	ee 0f       	add	r30, r30
    13b8:	ff 1f       	adc	r31, r31
    13ba:	ee 0f       	add	r30, r30
    13bc:	ff 1f       	adc	r31, r31
    13be:	e4 0f       	add	r30, r20
    13c0:	f5 1f       	adc	r31, r21
    13c2:	80 85       	ldd	r24, Z+8	; 0x08
    13c4:	91 85       	ldd	r25, Z+9	; 0x09
    13c6:	28 85       	ldd	r18, Y+8	; 0x08
    13c8:	39 85       	ldd	r19, Y+9	; 0x09
    13ca:	82 2b       	or	r24, r18
    13cc:	93 2b       	or	r25, r19
    13ce:	91 87       	std	Z+9, r25	; 0x09
    13d0:	80 87       	std	Z+8, r24	; 0x08
		buttonStringPatterns[*buttonToAssign][5] |= stringState[5];
    13d2:	8d 91       	ld	r24, X+
    13d4:	9c 91       	ld	r25, X
    13d6:	11 97       	sbiw	r26, 0x01	; 1
    13d8:	fc 01       	movw	r30, r24
    13da:	ee 0f       	add	r30, r30
    13dc:	ff 1f       	adc	r31, r31
    13de:	e8 0f       	add	r30, r24
    13e0:	f9 1f       	adc	r31, r25
    13e2:	ee 0f       	add	r30, r30
    13e4:	ff 1f       	adc	r31, r31
    13e6:	ee 0f       	add	r30, r30
    13e8:	ff 1f       	adc	r31, r31
    13ea:	e4 0f       	add	r30, r20
    13ec:	f5 1f       	adc	r31, r21
    13ee:	82 85       	ldd	r24, Z+10	; 0x0a
    13f0:	93 85       	ldd	r25, Z+11	; 0x0b
    13f2:	2a 85       	ldd	r18, Y+10	; 0x0a
    13f4:	3b 85       	ldd	r19, Y+11	; 0x0b
    13f6:	82 2b       	or	r24, r18
    13f8:	93 2b       	or	r25, r19
    13fa:	93 87       	std	Z+11, r25	; 0x0b
    13fc:	82 87       	std	Z+10, r24	; 0x0a

		*plusLock = 1;  // we set up a lock, so we don't assign all the buttons at once
    13fe:	81 e0       	ldi	r24, 0x01	; 1
    1400:	f7 01       	movw	r30, r14
    1402:	80 83       	st	Z, r24
		*buttonToAssign += 1;
    1404:	8d 91       	ld	r24, X+
    1406:	9c 91       	ld	r25, X
    1408:	11 97       	sbiw	r26, 0x01	; 1
    140a:	01 96       	adiw	r24, 0x01	; 1
    140c:	8d 93       	st	X+, r24
    140e:	9c 93       	st	X, r25
    1410:	02 c0       	rjmp	.+4      	; 0x1416 <configSetButtonData+0x2d8>
	}
	else if(data->plusOn == 0)
	{
		*plusLock = 0;
    1412:	e7 01       	movw	r28, r14
    1414:	18 82       	st	Y, r1
	}
	return;
}
    1416:	df 91       	pop	r29
    1418:	cf 91       	pop	r28
    141a:	0f 91       	pop	r16
    141c:	ff 90       	pop	r15
    141e:	ef 90       	pop	r14
    1420:	df 90       	pop	r13
    1422:	cf 90       	pop	r12
    1424:	bf 90       	pop	r11
    1426:	af 90       	pop	r10
    1428:	08 95       	ret

0000142a <usbFunctionSetup>:

/* ------------------------------------------------------------------------- */

usbMsgLen_t usbFunctionSetup(uchar data[8])
{
usbRequest_t    *rq = (void *)data;
    142a:	fc 01       	movw	r30, r24

    /* The following requests are never used. But since they are required by
     * the specification, we implement them in this example.
     */
    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* class request type */
    142c:	80 81       	ld	r24, Z
    142e:	80 76       	andi	r24, 0x60	; 96
    1430:	80 32       	cpi	r24, 0x20	; 32
    1432:	e1 f4       	brne	.+56     	; 0x146c <usbFunctionSetup+0x42>
        //DBG1(0x50, &rq->bRequest, 1);   /* debug output: print our request */
        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
    1434:	81 81       	ldd	r24, Z+1	; 0x01
    1436:	81 30       	cpi	r24, 0x01	; 1
    1438:	41 f4       	brne	.+16     	; 0x144a <usbFunctionSetup+0x20>
            /* we only have one report type, so don't look at wValue */
            usbMsgPtr = (void *)&reportBuffer;
    143a:	84 e0       	ldi	r24, 0x04	; 4
    143c:	91 e0       	ldi	r25, 0x01	; 1
    143e:	90 93 26 01 	sts	0x0126, r25
    1442:	80 93 25 01 	sts	0x0125, r24
    1446:	87 e0       	ldi	r24, 0x07	; 7
    1448:	08 95       	ret
            return sizeof(reportBuffer);
        }else if(rq->bRequest == USBRQ_HID_GET_IDLE){
    144a:	82 30       	cpi	r24, 0x02	; 2
    144c:	41 f4       	brne	.+16     	; 0x145e <usbFunctionSetup+0x34>
            usbMsgPtr = &idleRate;
    144e:	82 e0       	ldi	r24, 0x02	; 2
    1450:	91 e0       	ldi	r25, 0x01	; 1
    1452:	90 93 26 01 	sts	0x0126, r25
    1456:	80 93 25 01 	sts	0x0125, r24
    145a:	81 e0       	ldi	r24, 0x01	; 1
    145c:	08 95       	ret
            return 1;
        }else if(rq->bRequest == USBRQ_HID_SET_IDLE){
    145e:	8a 30       	cpi	r24, 0x0A	; 10
    1460:	29 f4       	brne	.+10     	; 0x146c <usbFunctionSetup+0x42>
            idleRate = rq->wValue.bytes[1];
    1462:	83 81       	ldd	r24, Z+3	; 0x03
    1464:	80 93 02 01 	sts	0x0102, r24
    1468:	80 e0       	ldi	r24, 0x00	; 0
    146a:	08 95       	ret
    146c:	80 e0       	ldi	r24, 0x00	; 0
        }
    }else{
        /* no vendor specific requests implemented */
    }
    return 0;   /* default for not implemented requests: return no data back to host */
}
    146e:	08 95       	ret

00001470 <sendData>:
	usbPoll();
}


void sendData(dataForController data)
{
    1470:	0f 93       	push	r16
    1472:	1f 93       	push	r17
    1474:	df 93       	push	r29
    1476:	cf 93       	push	r28
    1478:	cd b7       	in	r28, 0x3d	; 61
    147a:	de b7       	in	r29, 0x3e	; 62
    147c:	29 97       	sbiw	r28, 0x09	; 9
    147e:	0f b6       	in	r0, 0x3f	; 63
    1480:	f8 94       	cli
    1482:	de bf       	out	0x3e, r29	; 62
    1484:	0f be       	out	0x3f, r0	; 63
    1486:	cd bf       	out	0x3d, r28	; 61
    1488:	90 2f       	mov	r25, r16
    148a:	09 83       	std	Y+1, r16	; 0x01
    148c:	f1 2f       	mov	r31, r17
    148e:	1a 83       	std	Y+2, r17	; 0x02
    1490:	e2 2f       	mov	r30, r18
    1492:	2b 83       	std	Y+3, r18	; 0x03
    1494:	a3 2f       	mov	r26, r19
    1496:	3c 83       	std	Y+4, r19	; 0x04
    1498:	34 2f       	mov	r19, r20
    149a:	4d 83       	std	Y+5, r20	; 0x05
    149c:	b5 2f       	mov	r27, r21
    149e:	5e 83       	std	Y+6, r21	; 0x06
    14a0:	46 2f       	mov	r20, r22
    14a2:	6f 83       	std	Y+7, r22	; 0x07
    14a4:	27 2f       	mov	r18, r23
    14a6:	78 87       	std	Y+8, r23	; 0x08
    14a8:	89 87       	std	Y+9, r24	; 0x09
    14aa:	58 2f       	mov	r21, r24

       //set the buttons to all at default positions
        reportBuffer[0] = 0b00000000;
        reportBuffer[1] = 0b00000000;
    14ac:	10 92 05 01 	sts	0x0105, r1
        reportBuffer[2] = 0b00001000;
    14b0:	88 e0       	ldi	r24, 0x08	; 8
    14b2:	80 93 06 01 	sts	0x0106, r24
        reportBuffer[3] = 0b10000000;
    14b6:	80 e8       	ldi	r24, 0x80	; 128
    14b8:	80 93 07 01 	sts	0x0107, r24
        reportBuffer[4] = 0b10000000;
    14bc:	80 93 08 01 	sts	0x0108, r24
        reportBuffer[5] = 0b10000000;
    14c0:	80 93 09 01 	sts	0x0109, r24
        reportBuffer[6] = 0b00000000;
    14c4:	10 92 0a 01 	sts	0x010A, r1


        // Since 'colorOn' is 1 when a fret is pressed, we shift it to the proper place and | it to set the
        // corresponding button bit to one, which corresponds to a button press.
        reportBuffer[0] |= (data.orangeOn << ORANGE_BIT);
        reportBuffer[0] |= (data.blueOn << BLUE_BIT);
    14c8:	32 95       	swap	r19
    14ca:	30 7f       	andi	r19, 0xF0	; 240
    14cc:	3a 2b       	or	r19, r26
        reportBuffer[0] |= (data.yellowOn << YELLOW_BIT);
        reportBuffer[0] |= (data.redOn << RED_BIT);
        reportBuffer[0] |= (data.greenOn << GREEN_BIT);
    14ce:	ff 0f       	add	r31, r31
    14d0:	ff 0f       	add	r31, r31
    14d2:	ee 0f       	add	r30, r30
    14d4:	ee 0f       	add	r30, r30
    14d6:	ee 0f       	add	r30, r30
    14d8:	ef 2b       	or	r30, r31
    14da:	99 0f       	add	r25, r25
    14dc:	9e 2b       	or	r25, r30
    14de:	93 2b       	or	r25, r19
    14e0:	90 93 04 01 	sts	0x0104, r25

        // On the PS3, the strumming shows up as a hat switch, so we have to use conditionals for this..
        if (data.upOn)
    14e4:	bb 23       	and	r27, r27
    14e6:	11 f0       	breq	.+4      	; 0x14ec <sendData+0x7c>
                reportBuffer[2] = 0b00000000;
    14e8:	10 92 06 01 	sts	0x0106, r1
        if (data.downOn)
    14ec:	44 23       	and	r20, r20
    14ee:	19 f0       	breq	.+6      	; 0x14f6 <sendData+0x86>
                reportBuffer[2] = 0b00000100;
    14f0:	84 e0       	ldi	r24, 0x04	; 4
    14f2:	80 93 06 01 	sts	0x0106, r24

        reportBuffer[1] |= (data.plusOn << PLUS_BIT);
    14f6:	22 0f       	add	r18, r18
    14f8:	80 91 05 01 	lds	r24, 0x0105
    14fc:	82 2b       	or	r24, r18
    14fe:	80 93 05 01 	sts	0x0105, r24
        reportBuffer[0] |= (data.minusOn << MINUS_BIT);
    1502:	52 95       	swap	r21
    1504:	55 0f       	add	r21, r21
    1506:	50 7e       	andi	r21, 0xE0	; 224
    1508:	80 91 04 01 	lds	r24, 0x0104
    150c:	85 2b       	or	r24, r21
    150e:	80 93 04 01 	sts	0x0104, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1512:	80 e4       	ldi	r24, 0x40	; 64
    1514:	9f e1       	ldi	r25, 0x1F	; 31
    1516:	01 97       	sbiw	r24, 0x01	; 1
    1518:	f1 f7       	brne	.-4      	; 0x1516 <sendData+0xa6>
		//DEBUG STUFF
		//DDRC &= ~(1<<5); //Turn 5 on Port C to inputs
		//PORTC |= (1<<5); //Turn off the internal pullup resistor on pin 5
		_delay_ms(2);

		if (PINC & (1<<5))
    151a:	35 9b       	sbis	0x06, 5	; 6
    151c:	02 c0       	rjmp	.+4      	; 0x1522 <sendData+0xb2>
		{
			PORTB &= ~1; // Turn off LED
    151e:	28 98       	cbi	0x05, 0	; 5
    1520:	04 c0       	rjmp	.+8      	; 0x152a <sendData+0xba>
			//reportBuffer.dx = 0;
		}
		else
		{
           reportBuffer[2] = 0b00000100; //Down
    1522:	84 e0       	ldi	r24, 0x04	; 4
    1524:	80 93 06 01 	sts	0x0106, r24
			PORTB |= 1; // Turn on the LED if we're grounded
    1528:	28 9a       	sbi	0x05, 0	; 5
		}

        //Then we finish off some USB stuff.
        wdt_reset();  //Reset the watchdog timer
    152a:	a8 95       	wdr
        usbPoll();    //USB poll - must be called at least once per 10ms
    152c:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <usbPoll>

        // Now, regardless of mode, we have to send the data to the 
        // USB controlling library from the buffer we've been building
        if(usbInterruptIsReady())
    1530:	80 91 16 01 	lds	r24, 0x0116
    1534:	84 ff       	sbrs	r24, 4
    1536:	05 c0       	rjmp	.+10     	; 0x1542 <sendData+0xd2>
        {
            /* called after every poll of the interrupt endpoint */
            usbSetInterrupt((void *)&reportBuffer, sizeof(reportBuffer));
    1538:	84 e0       	ldi	r24, 0x04	; 4
    153a:	91 e0       	ldi	r25, 0x01	; 1
    153c:	67 e0       	ldi	r22, 0x07	; 7
    153e:	0e 94 08 0c 	call	0x1810	; 0x1810 <usbSetInterrupt>
        }
                

}
    1542:	29 96       	adiw	r28, 0x09	; 9
    1544:	0f b6       	in	r0, 0x3f	; 63
    1546:	f8 94       	cli
    1548:	de bf       	out	0x3e, r29	; 62
    154a:	0f be       	out	0x3f, r0	; 63
    154c:	cd bf       	out	0x3d, r28	; 61
    154e:	cf 91       	pop	r28
    1550:	df 91       	pop	r29
    1552:	1f 91       	pop	r17
    1554:	0f 91       	pop	r16
    1556:	08 95       	ret

00001558 <startCommunication>:
	reportBuffer[5] = 0b10000000;
	reportBuffer[6] = 0b00000000;
*/

    // First, set up all the USB communication stuff
    wdt_enable(WDTO_1S);
    1558:	2e e0       	ldi	r18, 0x0E	; 14
    155a:	88 e1       	ldi	r24, 0x18	; 24
    155c:	90 e0       	ldi	r25, 0x00	; 0
    155e:	0f b6       	in	r0, 0x3f	; 63
    1560:	f8 94       	cli
    1562:	a8 95       	wdr
    1564:	80 93 60 00 	sts	0x0060, r24
    1568:	0f be       	out	0x3f, r0	; 63
    156a:	20 93 60 00 	sts	0x0060, r18
     * RESET status: all port bits are inputs without pull-up.
     * That's the way we need D+ and D-. Therefore we don't need any
     * additional hardware initialization.
     */

    usbInit();
    156e:	0e 94 c9 0a 	call	0x1592	; 0x1592 <usbInit>
    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
    1572:	54 9a       	sbi	0x0a, 4	; 10
    1574:	20 e0       	ldi	r18, 0x00	; 0
    1576:	40 ea       	ldi	r20, 0xA0	; 160
    1578:	5f e0       	ldi	r21, 0x0F	; 15
    157a:	04 c0       	rjmp	.+8      	; 0x1584 <startCommunication+0x2c>
    uchar i = 0;
    while(--i){             /* fake USB disconnect for > 250 ms */
        wdt_reset();
    157c:	a8 95       	wdr
    157e:	ca 01       	movw	r24, r20
    1580:	01 97       	sbiw	r24, 0x01	; 1
    1582:	f1 f7       	brne	.-4      	; 0x1580 <startCommunication+0x28>
     */

    usbInit();
    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
    uchar i = 0;
    while(--i){             /* fake USB disconnect for > 250 ms */
    1584:	21 50       	subi	r18, 0x01	; 1
    1586:	d1 f7       	brne	.-12     	; 0x157c <startCommunication+0x24>
        wdt_reset();
        _delay_ms(1);
    }
    usbDeviceConnect();
    1588:	54 98       	cbi	0x0a, 4	; 10
    sei();
    158a:	78 94       	sei
	usbPoll();
    158c:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <usbPoll>
}
    1590:	08 95       	ret

00001592 <usbInit>:
/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbInit(void)
{
#if USB_INTR_CFG_SET != 0
    USB_INTR_CFG |= USB_INTR_CFG_SET;
    1592:	e9 e6       	ldi	r30, 0x69	; 105
    1594:	f0 e0       	ldi	r31, 0x00	; 0
    1596:	80 81       	ld	r24, Z
    1598:	8c 60       	ori	r24, 0x0C	; 12
    159a:	80 83       	st	Z, r24
#endif
#if USB_INTR_CFG_CLR != 0
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
    159c:	e9 9a       	sbi	0x1d, 1	; 29
/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    159e:	8b e4       	ldi	r24, 0x4B	; 75
    15a0:	80 93 17 01 	sts	0x0117, r24
#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    15a4:	80 93 42 01 	sts	0x0142, r24
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
    usbResetDataToggling();
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    usbTxLen1 = USBPID_NAK;
    15a8:	8a e5       	ldi	r24, 0x5A	; 90
    15aa:	80 93 16 01 	sts	0x0116, r24
#if USB_CFG_HAVE_INTRIN_ENDPOINT3
    usbTxLen3 = USBPID_NAK;
    15ae:	80 93 41 01 	sts	0x0141, r24
#endif
#endif
}
    15b2:	08 95       	ret

000015b4 <usbPoll>:
}

/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbPoll(void)
{
    15b4:	1f 93       	push	r17
    15b6:	cf 93       	push	r28
    15b8:	df 93       	push	r29
schar   len;
uchar   i;

    len = usbRxLen - 3;
    15ba:	90 91 27 01 	lds	r25, 0x0127
    15be:	93 50       	subi	r25, 0x03	; 3
    if(len >= 0){
    15c0:	97 fd       	sbrc	r25, 7
    15c2:	a8 c0       	rjmp	.+336    	; 0x1714 <usbPoll+0x160>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
    15c4:	20 91 24 01 	lds	r18, 0x0124
    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
        usbFunctionWriteOut(data, len);
        return;
    }
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
    15c8:	80 91 23 01 	lds	r24, 0x0123
    15cc:	8d 32       	cpi	r24, 0x2D	; 45
    15ce:	09 f0       	breq	.+2      	; 0x15d2 <usbPoll+0x1e>
    15d0:	9f c0       	rjmp	.+318    	; 0x1710 <usbPoll+0x15c>
        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
    15d2:	98 30       	cpi	r25, 0x08	; 8
    15d4:	09 f0       	breq	.+2      	; 0x15d8 <usbPoll+0x24>
    15d6:	9c c0       	rjmp	.+312    	; 0x1710 <usbPoll+0x15c>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
    15d8:	cc e0       	ldi	r28, 0x0C	; 12
    15da:	d0 e0       	ldi	r29, 0x00	; 0
    15dc:	c2 1b       	sub	r28, r18
    15de:	d1 09       	sbc	r29, r1
    15e0:	c5 5d       	subi	r28, 0xD5	; 213
    15e2:	de 4f       	sbci	r29, 0xFE	; 254
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
            return;
        usbMsgLen_t replyLen;
        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
    15e4:	83 ec       	ldi	r24, 0xC3	; 195
    15e6:	80 93 0b 01 	sts	0x010B, r24
        usbTxLen = USBPID_NAK;              /* abort pending transmit */
    15ea:	8a e5       	ldi	r24, 0x5A	; 90
    15ec:	80 93 00 01 	sts	0x0100, r24
        usbMsgFlags = 0;
    15f0:	10 92 03 01 	sts	0x0103, r1
        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
    15f4:	88 81       	ld	r24, Y
    15f6:	80 76       	andi	r24, 0x60	; 96
    15f8:	29 f0       	breq	.+10     	; 0x1604 <usbPoll+0x50>
            replyLen = usbFunctionSetup(data);
    15fa:	ce 01       	movw	r24, r28
    15fc:	0e 94 15 0a 	call	0x142a	; 0x142a <usbFunctionSetup>
    1600:	28 2f       	mov	r18, r24
    1602:	7d c0       	rjmp	.+250    	; 0x16fe <usbPoll+0x14a>
 * standard requests instead of class and custom requests.
 */
static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
{
uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffer */
uchar   value = rq->wValue.bytes[0];
    1604:	9a 81       	ldd	r25, Y+2	; 0x02
#if USB_CFG_IMPLEMENT_HALT
uchar   index = rq->wIndex.bytes[0];
#endif

    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
    1606:	10 92 14 01 	sts	0x0114, r1
    SWITCH_START(rq->bRequest)
    160a:	89 81       	ldd	r24, Y+1	; 0x01
    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
    160c:	88 23       	and	r24, r24
    160e:	21 f4       	brne	.+8      	; 0x1618 <usbPoll+0x64>
            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
#if USB_CFG_IMPLEMENT_HALT
        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
            dataPtr[0] = usbTxLen1 == USBPID_STALL;
#endif
        dataPtr[1] = 0;
    1610:	10 92 15 01 	sts	0x0115, r1
    1614:	22 e0       	ldi	r18, 0x02	; 2
    1616:	6d c0       	rjmp	.+218    	; 0x16f2 <usbPoll+0x13e>
        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
            usbResetDataToggling();
        }
#endif
    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
    1618:	85 30       	cpi	r24, 0x05	; 5
    161a:	19 f4       	brne	.+6      	; 0x1622 <usbPoll+0x6e>
        usbNewDeviceAddr = value;
    161c:	90 93 28 01 	sts	0x0128, r25
    1620:	67 c0       	rjmp	.+206    	; 0x16f0 <usbPoll+0x13c>
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
    1622:	86 30       	cpi	r24, 0x06	; 6
    1624:	09 f0       	breq	.+2      	; 0x1628 <usbPoll+0x74>
    1626:	4e c0       	rjmp	.+156    	; 0x16c4 <usbPoll+0x110>
static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
{
usbMsgLen_t len = 0;
uchar       flags = USB_FLG_MSGPTR_IS_ROM;

    SWITCH_START(rq->wValue.bytes[1])
    1628:	8b 81       	ldd	r24, Y+3	; 0x03
    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
    162a:	81 30       	cpi	r24, 0x01	; 1
    162c:	41 f4       	brne	.+16     	; 0x163e <usbPoll+0x8a>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
    162e:	86 ee       	ldi	r24, 0xE6	; 230
    1630:	90 e0       	ldi	r25, 0x00	; 0
    1632:	90 93 26 01 	sts	0x0126, r25
    1636:	80 93 25 01 	sts	0x0125, r24
    163a:	22 e1       	ldi	r18, 0x12	; 18
    163c:	3f c0       	rjmp	.+126    	; 0x16bc <usbPoll+0x108>
    SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
    163e:	82 30       	cpi	r24, 0x02	; 2
    1640:	41 f4       	brne	.+16     	; 0x1652 <usbPoll+0x9e>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
    1642:	88 ef       	ldi	r24, 0xF8	; 248
    1644:	90 e0       	ldi	r25, 0x00	; 0
    1646:	90 93 26 01 	sts	0x0126, r25
    164a:	80 93 25 01 	sts	0x0125, r24
    164e:	29 e2       	ldi	r18, 0x29	; 41
    1650:	35 c0       	rjmp	.+106    	; 0x16bc <usbPoll+0x108>
    SWITCH_CASE(USBDESCR_STRING)    /* 3 */
    1652:	83 30       	cpi	r24, 0x03	; 3
    1654:	f1 f4       	brne	.+60     	; 0x1692 <usbPoll+0xde>
        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
            flags = 0;
        len = usbFunctionDescriptor(rq);
#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
        SWITCH_START(rq->wValue.bytes[0])
        SWITCH_CASE(0)
    1656:	99 23       	and	r25, r25
    1658:	41 f4       	brne	.+16     	; 0x166a <usbPoll+0xb6>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
    165a:	82 eb       	ldi	r24, 0xB2	; 178
    165c:	90 e0       	ldi	r25, 0x00	; 0
    165e:	90 93 26 01 	sts	0x0126, r25
    1662:	80 93 25 01 	sts	0x0125, r24
    1666:	24 e0       	ldi	r18, 0x04	; 4
    1668:	29 c0       	rjmp	.+82     	; 0x16bc <usbPoll+0x108>
        SWITCH_CASE(1)
    166a:	91 30       	cpi	r25, 0x01	; 1
    166c:	41 f4       	brne	.+16     	; 0x167e <usbPoll+0xca>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
    166e:	86 eb       	ldi	r24, 0xB6	; 182
    1670:	90 e0       	ldi	r25, 0x00	; 0
    1672:	90 93 26 01 	sts	0x0126, r25
    1676:	80 93 25 01 	sts	0x0125, r24
    167a:	2c e1       	ldi	r18, 0x1C	; 28
    167c:	1f c0       	rjmp	.+62     	; 0x16bc <usbPoll+0x108>
        SWITCH_CASE(2)
    167e:	92 30       	cpi	r25, 0x02	; 2
    1680:	e1 f4       	brne	.+56     	; 0x16ba <usbPoll+0x106>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
    1682:	82 ed       	ldi	r24, 0xD2	; 210
    1684:	90 e0       	ldi	r25, 0x00	; 0
    1686:	90 93 26 01 	sts	0x0126, r25
    168a:	80 93 25 01 	sts	0x0125, r24
    168e:	24 e1       	ldi	r18, 0x14	; 20
    1690:	15 c0       	rjmp	.+42     	; 0x16bc <usbPoll+0x108>
                len = usbFunctionDescriptor(rq);
            }
        SWITCH_END
#endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
#if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
    SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
    1692:	81 32       	cpi	r24, 0x21	; 33
    1694:	41 f4       	brne	.+16     	; 0x16a6 <usbPoll+0xf2>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
    1696:	8a e0       	ldi	r24, 0x0A	; 10
    1698:	91 e0       	ldi	r25, 0x01	; 1
    169a:	90 93 26 01 	sts	0x0126, r25
    169e:	80 93 25 01 	sts	0x0125, r24
    16a2:	29 e0       	ldi	r18, 0x09	; 9
    16a4:	0b c0       	rjmp	.+22     	; 0x16bc <usbPoll+0x108>
    SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
    16a6:	82 32       	cpi	r24, 0x22	; 34
    16a8:	41 f4       	brne	.+16     	; 0x16ba <usbPoll+0x106>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
    16aa:	88 e6       	ldi	r24, 0x68	; 104
    16ac:	90 e0       	ldi	r25, 0x00	; 0
    16ae:	90 93 26 01 	sts	0x0126, r25
    16b2:	80 93 25 01 	sts	0x0125, r24
    16b6:	2a e4       	ldi	r18, 0x4A	; 74
    16b8:	01 c0       	rjmp	.+2      	; 0x16bc <usbPoll+0x108>
    16ba:	20 e0       	ldi	r18, 0x00	; 0
    SWITCH_DEFAULT
        if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
            len = usbFunctionDescriptor(rq);
        }
    SWITCH_END
    usbMsgFlags = flags;
    16bc:	80 e4       	ldi	r24, 0x40	; 64
    16be:	80 93 03 01 	sts	0x0103, r24
    16c2:	1d c0       	rjmp	.+58     	; 0x16fe <usbPoll+0x14a>
        usbNewDeviceAddr = value;
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
        len = usbDriverDescriptor(rq);
        goto skipMsgPtrAssignment;
    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
    16c4:	88 30       	cpi	r24, 0x08	; 8
    16c6:	21 f4       	brne	.+8      	; 0x16d0 <usbPoll+0x11c>
    16c8:	21 e0       	ldi	r18, 0x01	; 1
    16ca:	8a e2       	ldi	r24, 0x2A	; 42
    16cc:	91 e0       	ldi	r25, 0x01	; 1
    16ce:	13 c0       	rjmp	.+38     	; 0x16f6 <usbPoll+0x142>
        dataPtr = &usbConfiguration;  /* send current configuration value */
        len = 1;
    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
    16d0:	89 30       	cpi	r24, 0x09	; 9
    16d2:	19 f4       	brne	.+6      	; 0x16da <usbPoll+0x126>
        usbConfiguration = value;
    16d4:	90 93 2a 01 	sts	0x012A, r25
    16d8:	0b c0       	rjmp	.+22     	; 0x16f0 <usbPoll+0x13c>
        usbResetStall();
    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
    16da:	8a 30       	cpi	r24, 0x0A	; 10
    16dc:	11 f4       	brne	.+4      	; 0x16e2 <usbPoll+0x12e>
    16de:	21 e0       	ldi	r18, 0x01	; 1
    16e0:	08 c0       	rjmp	.+16     	; 0x16f2 <usbPoll+0x13e>
        len = 1;
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
    16e2:	8b 30       	cpi	r24, 0x0B	; 11
    16e4:	29 f4       	brne	.+10     	; 0x16f0 <usbPoll+0x13c>
/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    16e6:	8b e4       	ldi	r24, 0x4B	; 75
    16e8:	80 93 17 01 	sts	0x0117, r24
#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    16ec:	80 93 42 01 	sts	0x0142, r24
    16f0:	20 e0       	ldi	r18, 0x00	; 0
    16f2:	84 e1       	ldi	r24, 0x14	; 20
    16f4:	91 e0       	ldi	r25, 0x01	; 1
        usbResetStall();
#endif
    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
        /* Should we add an optional hook here? */
    SWITCH_END
    usbMsgPtr = dataPtr;
    16f6:	90 93 26 01 	sts	0x0126, r25
    16fa:	80 93 25 01 	sts	0x0125, r24
            }
            usbMsgFlags = USB_FLG_USE_USER_RW;
        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */
#endif
        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */
    16fe:	8f 81       	ldd	r24, Y+7	; 0x07
    1700:	88 23       	and	r24, r24
    1702:	21 f4       	brne	.+8      	; 0x170c <usbPoll+0x158>
    1704:	8e 81       	ldd	r24, Y+6	; 0x06
    1706:	82 17       	cp	r24, r18
    1708:	08 f4       	brcc	.+2      	; 0x170c <usbPoll+0x158>
    170a:	28 2f       	mov	r18, r24
                replyLen = rq->wLength.bytes[0];
        }else{
            if(replyLen > rq->wLength.word)     /* limit length to max */
                replyLen = rq->wLength.word;
        }
        usbMsgLen = replyLen;
    170c:	20 93 01 01 	sts	0x0101, r18
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
#if USB_CFG_HAVE_FLOWCONTROL
        if(usbRxLen > 0)    /* only mark as available if not inactivated */
            usbRxLen = 0;
#else
        usbRxLen = 0;       /* mark rx buffer as available */
    1710:	10 92 27 01 	sts	0x0127, r1
#endif
    }
    if(usbTxLen & 0x10){    /* transmit system idle */
    1714:	80 91 00 01 	lds	r24, 0x0100
    1718:	84 ff       	sbrs	r24, 4
    171a:	4a c0       	rjmp	.+148    	; 0x17b0 <usbPoll+0x1fc>
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
    171c:	80 91 01 01 	lds	r24, 0x0101
    1720:	8f 3f       	cpi	r24, 0xFF	; 255
    1722:	09 f4       	brne	.+2      	; 0x1726 <usbPoll+0x172>
    1724:	45 c0       	rjmp	.+138    	; 0x17b0 <usbPoll+0x1fc>
    1726:	18 2f       	mov	r17, r24
    1728:	89 30       	cpi	r24, 0x09	; 9
    172a:	08 f0       	brcs	.+2      	; 0x172e <usbPoll+0x17a>
    172c:	18 e0       	ldi	r17, 0x08	; 8
uchar       len;

    wantLen = usbMsgLen;
    if(wantLen > 8)
        wantLen = 8;
    usbMsgLen -= wantLen;
    172e:	81 1b       	sub	r24, r17
    1730:	80 93 01 01 	sts	0x0101, r24
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    1734:	80 91 0b 01 	lds	r24, 0x010B
    1738:	98 e8       	ldi	r25, 0x88	; 136
    173a:	89 27       	eor	r24, r25
    173c:	80 93 0b 01 	sts	0x010B, r24
/* This function is similar to usbFunctionRead(), but it's also called for
 * data handled automatically by the driver (e.g. descriptor reads).
 */
static uchar usbDeviceRead(uchar *data, uchar len)
{
    if(len > 0){    /* don't bother app with 0 sized reads */
    1740:	11 23       	and	r17, r17
    1742:	41 f1       	breq	.+80     	; 0x1794 <usbPoll+0x1e0>
        if(usbMsgFlags & USB_FLG_USE_USER_RW){
            len = usbFunctionRead(data, len);
        }else
#endif
        {
            uchar i = len, *r = usbMsgPtr;
    1744:	20 91 25 01 	lds	r18, 0x0125
    1748:	30 91 26 01 	lds	r19, 0x0126
            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
    174c:	80 91 03 01 	lds	r24, 0x0103
    1750:	86 ff       	sbrs	r24, 6
    1752:	0d c0       	rjmp	.+26     	; 0x176e <usbPoll+0x1ba>
    1754:	ac e0       	ldi	r26, 0x0C	; 12
    1756:	b1 e0       	ldi	r27, 0x01	; 1
    1758:	80 e0       	ldi	r24, 0x00	; 0
    175a:	90 e0       	ldi	r25, 0x00	; 0
                do{
                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */
    175c:	f9 01       	movw	r30, r18
    175e:	e8 0f       	add	r30, r24
    1760:	f9 1f       	adc	r31, r25
    1762:	e4 91       	lpm	r30, Z+
                    *data++ = c;
    1764:	ed 93       	st	X+, r30
    1766:	01 96       	adiw	r24, 0x01	; 1
                    r++;
                }while(--i);
    1768:	18 17       	cp	r17, r24
    176a:	c1 f7       	brne	.-16     	; 0x175c <usbPoll+0x1a8>
    176c:	08 c0       	rjmp	.+16     	; 0x177e <usbPoll+0x1ca>
    176e:	91 2f       	mov	r25, r17
    1770:	d9 01       	movw	r26, r18
    1772:	ec e0       	ldi	r30, 0x0C	; 12
    1774:	f1 e0       	ldi	r31, 0x01	; 1
            }else{  /* RAM data */
                do{
                    *data++ = *r++;
    1776:	8d 91       	ld	r24, X+
    1778:	81 93       	st	Z+, r24
                }while(--i);
    177a:	91 50       	subi	r25, 0x01	; 1
    177c:	e1 f7       	brne	.-8      	; 0x1776 <usbPoll+0x1c2>
    177e:	11 50       	subi	r17, 0x01	; 1
    1780:	81 2f       	mov	r24, r17
    1782:	90 e0       	ldi	r25, 0x00	; 0
    1784:	1f 5f       	subi	r17, 0xFF	; 255
    1786:	01 96       	adiw	r24, 0x01	; 1
    1788:	82 0f       	add	r24, r18
    178a:	93 1f       	adc	r25, r19
            }
            usbMsgPtr = r;
    178c:	90 93 26 01 	sts	0x0126, r25
    1790:	80 93 25 01 	sts	0x0125, r24
        wantLen = 8;
    usbMsgLen -= wantLen;
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    len = usbDeviceRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
        usbCrc16Append(&usbTxBuf[1], len);
    1794:	8c e0       	ldi	r24, 0x0C	; 12
    1796:	91 e0       	ldi	r25, 0x01	; 1
    1798:	61 2f       	mov	r22, r17
    179a:	0e 94 3f 0c 	call	0x187e	; 0x187e <usbCrc16Append>
        len += 4;           /* length including sync byte */
    179e:	61 2f       	mov	r22, r17
    17a0:	6c 5f       	subi	r22, 0xFC	; 252
        if(len < 12)        /* a partial package identifies end of message */
    17a2:	6c 30       	cpi	r22, 0x0C	; 12
    17a4:	19 f0       	breq	.+6      	; 0x17ac <usbPoll+0x1f8>
            usbMsgLen = USB_NO_MSG;
    17a6:	8f ef       	ldi	r24, 0xFF	; 255
    17a8:	80 93 01 01 	sts	0x0101, r24
    }else{
        len = USBPID_STALL;   /* stall the endpoint */
        usbMsgLen = USB_NO_MSG;
    }
    usbTxLen = len;
    17ac:	60 93 00 01 	sts	0x0100, r22
    17b0:	94 e1       	ldi	r25, 0x14	; 20
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 20; i > 0; i--){
        uchar usbLineStatus = USBIN & USBMASK;
    17b2:	89 b1       	in	r24, 0x09	; 9
        if(usbLineStatus != 0)  /* SE0 has ended */
    17b4:	88 71       	andi	r24, 0x18	; 24
    17b6:	31 f4       	brne	.+12     	; 0x17c4 <usbPoll+0x210>
    if(usbTxLen & 0x10){    /* transmit system idle */
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 20; i > 0; i--){
    17b8:	91 50       	subi	r25, 0x01	; 1
    17ba:	d9 f7       	brne	.-10     	; 0x17b2 <usbPoll+0x1fe>
        uchar usbLineStatus = USBIN & USBMASK;
        if(usbLineStatus != 0)  /* SE0 has ended */
            goto isNotReset;
    }
    /* RESET condition, called multiple times during reset */
    usbNewDeviceAddr = 0;
    17bc:	10 92 28 01 	sts	0x0128, r1
    usbDeviceAddr = 0;
    17c0:	10 92 22 01 	sts	0x0122, r1
    usbResetStall();
    DBG1(0xff, 0, 0);
isNotReset:
    usbHandleResetHook(i);
}
    17c4:	df 91       	pop	r29
    17c6:	cf 91       	pop	r28
    17c8:	1f 91       	pop	r17
    17ca:	08 95       	ret

000017cc <usbSetInterrupt3>:
}
#endif

#if USB_CFG_HAVE_INTRIN_ENDPOINT3
USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
{
    17cc:	1f 93       	push	r17
    17ce:	dc 01       	movw	r26, r24
    17d0:	16 2f       	mov	r17, r22

#if USB_CFG_IMPLEMENT_HALT
    if(usbTxLen1 == USBPID_STALL)
        return;
#endif
    if(txStatus->len & 0x10){   /* packet buffer was empty */
    17d2:	80 91 41 01 	lds	r24, 0x0141
    17d6:	84 ff       	sbrs	r24, 4
    17d8:	07 c0       	rjmp	.+14     	; 0x17e8 <usbSetInterrupt3+0x1c>
        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
    17da:	80 91 42 01 	lds	r24, 0x0142
    17de:	98 e8       	ldi	r25, 0x88	; 136
    17e0:	89 27       	eor	r24, r25
    17e2:	80 93 42 01 	sts	0x0142, r24
    17e6:	03 c0       	rjmp	.+6      	; 0x17ee <usbSetInterrupt3+0x22>
    }else{
        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
    17e8:	8a e5       	ldi	r24, 0x5A	; 90
    17ea:	80 93 41 01 	sts	0x0141, r24
    17ee:	91 2f       	mov	r25, r17
    17f0:	e3 e4       	ldi	r30, 0x43	; 67
    17f2:	f1 e0       	ldi	r31, 0x01	; 1
    }
    p = txStatus->buffer + 1;
    i = len;
    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
        *p++ = *data++;
    17f4:	8d 91       	ld	r24, X+
    17f6:	81 93       	st	Z+, r24
    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
    17f8:	91 50       	subi	r25, 0x01	; 1
    17fa:	e1 f7       	brne	.-8      	; 0x17f4 <usbSetInterrupt3+0x28>
    usbCrc16Append(&txStatus->buffer[1], len);
    17fc:	83 e4       	ldi	r24, 0x43	; 67
    17fe:	91 e0       	ldi	r25, 0x01	; 1
    1800:	61 2f       	mov	r22, r17
    1802:	0e 94 3f 0c 	call	0x187e	; 0x187e <usbCrc16Append>
    txStatus->len = len + 4;    /* len must be given including sync byte */
    1806:	1c 5f       	subi	r17, 0xFC	; 252
    1808:	10 93 41 01 	sts	0x0141, r17

#if USB_CFG_HAVE_INTRIN_ENDPOINT3
USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
{
    usbGenericSetInterrupt(data, len, &usbTxStatus3);
}
    180c:	1f 91       	pop	r17
    180e:	08 95       	ret

00001810 <usbSetInterrupt>:
    txStatus->len = len + 4;    /* len must be given including sync byte */
    DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
}

USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
{
    1810:	1f 93       	push	r17
    1812:	dc 01       	movw	r26, r24
    1814:	16 2f       	mov	r17, r22

#if USB_CFG_IMPLEMENT_HALT
    if(usbTxLen1 == USBPID_STALL)
        return;
#endif
    if(txStatus->len & 0x10){   /* packet buffer was empty */
    1816:	80 91 16 01 	lds	r24, 0x0116
    181a:	84 ff       	sbrs	r24, 4
    181c:	07 c0       	rjmp	.+14     	; 0x182c <usbSetInterrupt+0x1c>
        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
    181e:	80 91 17 01 	lds	r24, 0x0117
    1822:	98 e8       	ldi	r25, 0x88	; 136
    1824:	89 27       	eor	r24, r25
    1826:	80 93 17 01 	sts	0x0117, r24
    182a:	03 c0       	rjmp	.+6      	; 0x1832 <usbSetInterrupt+0x22>
    }else{
        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
    182c:	8a e5       	ldi	r24, 0x5A	; 90
    182e:	80 93 16 01 	sts	0x0116, r24
    1832:	91 2f       	mov	r25, r17
    1834:	e8 e1       	ldi	r30, 0x18	; 24
    1836:	f1 e0       	ldi	r31, 0x01	; 1
    }
    p = txStatus->buffer + 1;
    i = len;
    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
        *p++ = *data++;
    1838:	8d 91       	ld	r24, X+
    183a:	81 93       	st	Z+, r24
    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
    183c:	91 50       	subi	r25, 0x01	; 1
    183e:	e1 f7       	brne	.-8      	; 0x1838 <usbSetInterrupt+0x28>
    usbCrc16Append(&txStatus->buffer[1], len);
    1840:	88 e1       	ldi	r24, 0x18	; 24
    1842:	91 e0       	ldi	r25, 0x01	; 1
    1844:	61 2f       	mov	r22, r17
    1846:	0e 94 3f 0c 	call	0x187e	; 0x187e <usbCrc16Append>
    txStatus->len = len + 4;    /* len must be given including sync byte */
    184a:	1c 5f       	subi	r17, 0xFC	; 252
    184c:	10 93 16 01 	sts	0x0116, r17
}

USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
{
    usbGenericSetInterrupt(data, len, &usbTxStatus1);
}
    1850:	1f 91       	pop	r17
    1852:	08 95       	ret

00001854 <usbCrc16>:
    1854:	a8 2f       	mov	r26, r24
    1856:	b9 2f       	mov	r27, r25
    1858:	80 e0       	ldi	r24, 0x00	; 0
    185a:	90 e0       	ldi	r25, 0x00	; 0
    185c:	41 e0       	ldi	r20, 0x01	; 1
    185e:	50 ea       	ldi	r21, 0xA0	; 160
    1860:	60 95       	com	r22
    1862:	30 e0       	ldi	r19, 0x00	; 0
    1864:	09 c0       	rjmp	.+18     	; 0x1878 <usbCrcLoopEntry>

00001866 <usbCrcByteLoop>:
    1866:	2d 91       	ld	r18, X+
    1868:	82 27       	eor	r24, r18

0000186a <usbCrcBitLoop>:
    186a:	97 95       	ror	r25
    186c:	87 95       	ror	r24
    186e:	10 f0       	brcs	.+4      	; 0x1874 <usbCrcNoXor>
    1870:	84 27       	eor	r24, r20
    1872:	95 27       	eor	r25, r21

00001874 <usbCrcNoXor>:
    1874:	30 5e       	subi	r19, 0xE0	; 224
    1876:	c8 f3       	brcs	.-14     	; 0x186a <usbCrcBitLoop>

00001878 <usbCrcLoopEntry>:
    1878:	6f 5f       	subi	r22, 0xFF	; 255
    187a:	a8 f3       	brcs	.-22     	; 0x1866 <usbCrcByteLoop>

0000187c <usbCrcReady>:
    187c:	08 95       	ret

0000187e <usbCrc16Append>:
    187e:	ea df       	rcall	.-44     	; 0x1854 <usbCrc16>
    1880:	8d 93       	st	X+, r24
    1882:	9d 93       	st	X+, r25
    1884:	08 95       	ret

00001886 <__vector_2>:
    1886:	cf 93       	push	r28
    1888:	cf b7       	in	r28, 0x3f	; 63
    188a:	cf 93       	push	r28
    188c:	df 93       	push	r29

0000188e <waitForJ>:
    188e:	c3 95       	inc	r28
    1890:	4c 9b       	sbis	0x09, 4	; 9
    1892:	e9 f7       	brne	.-6      	; 0x188e <waitForJ>

00001894 <waitForK>:
    1894:	4c 9b       	sbis	0x09, 4	; 9
    1896:	0b c0       	rjmp	.+22     	; 0x18ae <foundK>
    1898:	4c 9b       	sbis	0x09, 4	; 9
    189a:	09 c0       	rjmp	.+18     	; 0x18ae <foundK>
    189c:	4c 9b       	sbis	0x09, 4	; 9
    189e:	07 c0       	rjmp	.+14     	; 0x18ae <foundK>
    18a0:	4c 9b       	sbis	0x09, 4	; 9
    18a2:	05 c0       	rjmp	.+10     	; 0x18ae <foundK>
    18a4:	4c 9b       	sbis	0x09, 4	; 9
    18a6:	03 c0       	rjmp	.+6      	; 0x18ae <foundK>
    18a8:	4c 9b       	sbis	0x09, 4	; 9
    18aa:	01 c0       	rjmp	.+2      	; 0x18ae <foundK>
    18ac:	8b c0       	rjmp	.+278    	; 0x19c4 <sofError>

000018ae <foundK>:
    18ae:	6f 93       	push	r22
    18b0:	c0 91 24 01 	lds	r28, 0x0124
    18b4:	dd 27       	eor	r29, r29
    18b6:	c5 5d       	subi	r28, 0xD5	; 213
    18b8:	de 4f       	sbci	r29, 0xFE	; 254
    18ba:	2f 93       	push	r18
    18bc:	65 e5       	ldi	r22, 0x55	; 85
    18be:	4c 9b       	sbis	0x09, 4	; 9
    18c0:	03 c0       	rjmp	.+6      	; 0x18c8 <haveTwoBitsK>
    18c2:	2f 91       	pop	r18
    18c4:	6f 91       	pop	r22
    18c6:	e6 cf       	rjmp	.-52     	; 0x1894 <waitForK>

000018c8 <haveTwoBitsK>:
    18c8:	0f 93       	push	r16
    18ca:	1f 93       	push	r17
    18cc:	4f 93       	push	r20
    18ce:	20 e0       	ldi	r18, 0x00	; 0
    18d0:	40 e1       	ldi	r20, 0x10	; 16
    18d2:	5f 93       	push	r21
    18d4:	09 b1       	in	r16, 0x09	; 9
    18d6:	08 71       	andi	r16, 0x18	; 24
    18d8:	04 fb       	bst	r16, 4
    18da:	27 f9       	bld	r18, 7
    18dc:	3f 93       	push	r19
    18de:	50 e0       	ldi	r21, 0x00	; 0
    18e0:	3b e0       	ldi	r19, 0x0B	; 11
    18e2:	39 c0       	rjmp	.+114    	; 0x1956 <rxbit1>

000018e4 <unstuff6>:
    18e4:	18 71       	andi	r17, 0x18	; 24
    18e6:	40 64       	ori	r20, 0x40	; 64
    18e8:	2f 77       	andi	r18, 0x7F	; 127
    18ea:	01 2f       	mov	r16, r17
    18ec:	5f 5f       	subi	r21, 0xFF	; 255
    18ee:	1e c0       	rjmp	.+60     	; 0x192c <didUnstuff6>

000018f0 <unstuff7>:
    18f0:	40 68       	ori	r20, 0x80	; 128
    18f2:	19 b1       	in	r17, 0x09	; 9
    18f4:	18 71       	andi	r17, 0x18	; 24
    18f6:	2f 77       	andi	r18, 0x7F	; 127
    18f8:	52 50       	subi	r21, 0x02	; 2
    18fa:	1f c0       	rjmp	.+62     	; 0x193a <didUnstuff7>

000018fc <unstuffEven>:
    18fc:	40 64       	ori	r20, 0x40	; 64
    18fe:	09 b1       	in	r16, 0x09	; 9
    1900:	2f 77       	andi	r18, 0x7F	; 127
    1902:	08 71       	andi	r16, 0x18	; 24
    1904:	d1 f1       	breq	.+116    	; 0x197a <se0>
    1906:	5f 5f       	subi	r21, 0xFF	; 255
    1908:	00 c0       	rjmp	.+0      	; 0x190a <unstuffEven+0xe>
    190a:	23 c0       	rjmp	.+70     	; 0x1952 <didUnstuffE>

0000190c <unstuffOdd>:
    190c:	40 62       	ori	r20, 0x20	; 32
    190e:	19 b1       	in	r17, 0x09	; 9
    1910:	2f 77       	andi	r18, 0x7F	; 127
    1912:	18 71       	andi	r17, 0x18	; 24
    1914:	91 f1       	breq	.+100    	; 0x197a <se0>
    1916:	5f 5f       	subi	r21, 0xFF	; 255
    1918:	00 c0       	rjmp	.+0      	; 0x191a <unstuffOdd+0xe>
    191a:	25 c0       	rjmp	.+74     	; 0x1966 <didUnstuffO>

0000191c <rxByteLoop>:
    191c:	08 71       	andi	r16, 0x18	; 24
    191e:	10 27       	eor	r17, r16
    1920:	51 50       	subi	r21, 0x01	; 1
    1922:	12 f4       	brpl	.+4      	; 0x1928 <skipLeap>
    1924:	5d 5f       	subi	r21, 0xFD	; 253
	...

00001928 <skipLeap>:
    1928:	11 50       	subi	r17, 0x01	; 1
    192a:	27 95       	ror	r18

0000192c <didUnstuff6>:
    192c:	2c 3f       	cpi	r18, 0xFC	; 252
    192e:	19 b1       	in	r17, 0x09	; 9
    1930:	c8 f6       	brcc	.-78     	; 0x18e4 <unstuff6>
    1932:	18 71       	andi	r17, 0x18	; 24
    1934:	01 27       	eor	r16, r17
    1936:	01 50       	subi	r16, 0x01	; 1
    1938:	27 95       	ror	r18

0000193a <didUnstuff7>:
    193a:	2c 3f       	cpi	r18, 0xFC	; 252
    193c:	c8 f6       	brcc	.-78     	; 0x18f0 <unstuff7>
    193e:	42 27       	eor	r20, r18
    1940:	49 93       	st	Y+, r20

00001942 <rxBitLoop>:
    1942:	09 b1       	in	r16, 0x09	; 9
    1944:	08 71       	andi	r16, 0x18	; 24
    1946:	10 27       	eor	r17, r16
    1948:	4f 73       	andi	r20, 0x3F	; 63
    194a:	11 50       	subi	r17, 0x01	; 1
    194c:	27 95       	ror	r18
    194e:	2c 3f       	cpi	r18, 0xFC	; 252
    1950:	a8 f6       	brcc	.-86     	; 0x18fc <unstuffEven>

00001952 <didUnstuffE>:
    1952:	46 95       	lsr	r20
    1954:	46 95       	lsr	r20

00001956 <rxbit1>:
    1956:	19 b1       	in	r17, 0x09	; 9
    1958:	18 71       	andi	r17, 0x18	; 24
    195a:	79 f0       	breq	.+30     	; 0x197a <se0>
    195c:	01 27       	eor	r16, r17
    195e:	01 50       	subi	r16, 0x01	; 1
    1960:	27 95       	ror	r18
    1962:	2c 3f       	cpi	r18, 0xFC	; 252
    1964:	98 f6       	brcc	.-90     	; 0x190c <unstuffOdd>

00001966 <didUnstuffO>:
    1966:	6b 5a       	subi	r22, 0xAB	; 171
    1968:	60 f3       	brcs	.-40     	; 0x1942 <rxBitLoop>
    196a:	31 50       	subi	r19, 0x01	; 1
    196c:	09 b1       	in	r16, 0x09	; 9
    196e:	b0 f6       	brcc	.-84     	; 0x191c <rxByteLoop>
    1970:	00 c0       	rjmp	.+0      	; 0x1972 <overflow>

00001972 <overflow>:
    1972:	12 e0       	ldi	r17, 0x02	; 2
    1974:	1c bb       	out	0x1c, r17	; 28

00001976 <ignorePacket>:
    1976:	00 27       	eor	r16, r16
    1978:	19 c0       	rjmp	.+50     	; 0x19ac <handleSetupOrOut>

0000197a <se0>:
    197a:	3b 50       	subi	r19, 0x0B	; 11
    197c:	31 95       	neg	r19
    197e:	c3 1b       	sub	r28, r19
    1980:	d0 40       	sbci	r29, 0x00	; 0
    1982:	12 e0       	ldi	r17, 0x02	; 2
    1984:	1c bb       	out	0x1c, r17	; 28
    1986:	08 81       	ld	r16, Y
    1988:	03 3c       	cpi	r16, 0xC3	; 195
    198a:	09 f1       	breq	.+66     	; 0x19ce <handleData>
    198c:	0b 34       	cpi	r16, 0x4B	; 75
    198e:	f9 f0       	breq	.+62     	; 0x19ce <handleData>
    1990:	20 91 22 01 	lds	r18, 0x0122
    1994:	19 81       	ldd	r17, Y+1	; 0x01
    1996:	11 0f       	add	r17, r17
    1998:	12 13       	cpse	r17, r18
    199a:	ed cf       	rjmp	.-38     	; 0x1976 <ignorePacket>
    199c:	4a 81       	ldd	r20, Y+2	; 0x02
    199e:	44 1f       	adc	r20, r20
    19a0:	09 36       	cpi	r16, 0x69	; 105
    19a2:	51 f1       	breq	.+84     	; 0x19f8 <handleIn>
    19a4:	0d 32       	cpi	r16, 0x2D	; 45
    19a6:	11 f0       	breq	.+4      	; 0x19ac <handleSetupOrOut>
    19a8:	01 3e       	cpi	r16, 0xE1	; 225
    19aa:	29 f7       	brne	.-54     	; 0x1976 <ignorePacket>

000019ac <handleSetupOrOut>:
    19ac:	00 93 29 01 	sts	0x0129, r16

000019b0 <doReturn>:
    19b0:	3f 91       	pop	r19
    19b2:	5f 91       	pop	r21
    19b4:	4f 91       	pop	r20
    19b6:	1f 91       	pop	r17
    19b8:	0f 91       	pop	r16
    19ba:	2f 91       	pop	r18
    19bc:	6f 91       	pop	r22
    19be:	cc b3       	in	r28, 0x1c	; 28
    19c0:	c1 fd       	sbrc	r28, 1
    19c2:	65 cf       	rjmp	.-310    	; 0x188e <waitForJ>

000019c4 <sofError>:
    19c4:	df 91       	pop	r29
    19c6:	cf 91       	pop	r28
    19c8:	cf bf       	out	0x3f, r28	; 63
    19ca:	cf 91       	pop	r28
    19cc:	18 95       	reti

000019ce <handleData>:
    19ce:	20 91 29 01 	lds	r18, 0x0129
    19d2:	22 23       	and	r18, r18
    19d4:	69 f3       	breq	.-38     	; 0x19b0 <doReturn>
    19d6:	10 91 27 01 	lds	r17, 0x0127
    19da:	11 23       	and	r17, r17
    19dc:	e9 f5       	brne	.+122    	; 0x1a58 <sendNakAndReti>
    19de:	34 30       	cpi	r19, 0x04	; 4
    19e0:	ea f1       	brmi	.+122    	; 0x1a5c <sendAckAndReti>
    19e2:	30 93 27 01 	sts	0x0127, r19
    19e6:	20 93 23 01 	sts	0x0123, r18
    19ea:	10 91 24 01 	lds	r17, 0x0124
    19ee:	3b e0       	ldi	r19, 0x0B	; 11
    19f0:	31 1b       	sub	r19, r17
    19f2:	30 93 24 01 	sts	0x0124, r19
    19f6:	32 c0       	rjmp	.+100    	; 0x1a5c <sendAckAndReti>

000019f8 <handleIn>:
    19f8:	00 91 27 01 	lds	r16, 0x0127
    19fc:	01 30       	cpi	r16, 0x01	; 1
    19fe:	64 f5       	brge	.+88     	; 0x1a58 <sendNakAndReti>
    1a00:	0a e5       	ldi	r16, 0x5A	; 90
    1a02:	4f 70       	andi	r20, 0x0F	; 15
    1a04:	49 f4       	brne	.+18     	; 0x1a18 <handleIn1>
    1a06:	30 91 00 01 	lds	r19, 0x0100
    1a0a:	34 fd       	sbrc	r19, 4
    1a0c:	28 c0       	rjmp	.+80     	; 0x1a5e <sendCntAndReti>
    1a0e:	00 93 00 01 	sts	0x0100, r16
    1a12:	cb e0       	ldi	r28, 0x0B	; 11
    1a14:	d1 e0       	ldi	r29, 0x01	; 1
    1a16:	27 c0       	rjmp	.+78     	; 0x1a66 <usbSendAndReti>

00001a18 <handleIn1>:
    1a18:	41 35       	cpi	r20, 0x51	; 81
    1a1a:	49 f0       	breq	.+18     	; 0x1a2e <handleIn3>
    1a1c:	30 91 16 01 	lds	r19, 0x0116
    1a20:	34 fd       	sbrc	r19, 4
    1a22:	1d c0       	rjmp	.+58     	; 0x1a5e <sendCntAndReti>
    1a24:	00 93 16 01 	sts	0x0116, r16
    1a28:	c7 e1       	ldi	r28, 0x17	; 23
    1a2a:	d1 e0       	ldi	r29, 0x01	; 1
    1a2c:	1c c0       	rjmp	.+56     	; 0x1a66 <usbSendAndReti>

00001a2e <handleIn3>:
    1a2e:	30 91 41 01 	lds	r19, 0x0141
    1a32:	34 fd       	sbrc	r19, 4
    1a34:	14 c0       	rjmp	.+40     	; 0x1a5e <sendCntAndReti>
    1a36:	00 93 41 01 	sts	0x0141, r16
    1a3a:	c2 e4       	ldi	r28, 0x42	; 66
    1a3c:	d1 e0       	ldi	r29, 0x01	; 1
    1a3e:	13 c0       	rjmp	.+38     	; 0x1a66 <usbSendAndReti>

00001a40 <bitstuffN>:
    1a40:	05 27       	eor	r16, r21
    1a42:	10 e0       	ldi	r17, 0x00	; 0
    1a44:	00 c0       	rjmp	.+0      	; 0x1a46 <bitstuffN+0x6>
    1a46:	00 00       	nop
    1a48:	0b b9       	out	0x0b, r16	; 11
    1a4a:	1a c0       	rjmp	.+52     	; 0x1a80 <didStuffN>

00001a4c <bitstuff6>:
    1a4c:	05 27       	eor	r16, r21
    1a4e:	10 e0       	ldi	r17, 0x00	; 0
    1a50:	22 1f       	adc	r18, r18
    1a52:	1d c0       	rjmp	.+58     	; 0x1a8e <didStuff6>

00001a54 <bitstuff7>:
    1a54:	10 e0       	ldi	r17, 0x00	; 0
    1a56:	21 c0       	rjmp	.+66     	; 0x1a9a <didStuff7>

00001a58 <sendNakAndReti>:
    1a58:	4a e5       	ldi	r20, 0x5A	; 90
    1a5a:	02 c0       	rjmp	.+4      	; 0x1a60 <sendX3AndReti>

00001a5c <sendAckAndReti>:
    1a5c:	32 ed       	ldi	r19, 0xD2	; 210

00001a5e <sendCntAndReti>:
    1a5e:	43 2f       	mov	r20, r19

00001a60 <sendX3AndReti>:
    1a60:	c4 e1       	ldi	r28, 0x14	; 20
    1a62:	d0 e0       	ldi	r29, 0x00	; 0
    1a64:	32 e0       	ldi	r19, 0x02	; 2

00001a66 <usbSendAndReti>:
    1a66:	1a b1       	in	r17, 0x0a	; 10
    1a68:	18 61       	ori	r17, 0x18	; 24
    1a6a:	5c 9a       	sbi	0x0b, 4	; 11
    1a6c:	0b b1       	in	r16, 0x0b	; 11
    1a6e:	1a b9       	out	0x0a, r17	; 10
    1a70:	58 e1       	ldi	r21, 0x18	; 24
    1a72:	20 e8       	ldi	r18, 0x80	; 128

00001a74 <txByteLoop>:
    1a74:	65 e3       	ldi	r22, 0x35	; 53

00001a76 <txBitLoop>:
    1a76:	20 ff       	sbrs	r18, 0
    1a78:	05 27       	eor	r16, r21
    1a7a:	0b b9       	out	0x0b, r16	; 11
    1a7c:	27 95       	ror	r18
    1a7e:	17 95       	ror	r17

00001a80 <didStuffN>:
    1a80:	1c 3f       	cpi	r17, 0xFC	; 252
    1a82:	f0 f6       	brcc	.-68     	; 0x1a40 <bitstuffN>
    1a84:	66 95       	lsr	r22
    1a86:	b8 f7       	brcc	.-18     	; 0x1a76 <txBitLoop>
    1a88:	b1 f7       	brne	.-20     	; 0x1a76 <txBitLoop>
    1a8a:	20 ff       	sbrs	r18, 0
    1a8c:	05 27       	eor	r16, r21

00001a8e <didStuff6>:
    1a8e:	0b b9       	out	0x0b, r16	; 11
    1a90:	27 95       	ror	r18
    1a92:	17 95       	ror	r17
    1a94:	1c 3f       	cpi	r17, 0xFC	; 252
    1a96:	d0 f6       	brcc	.-76     	; 0x1a4c <bitstuff6>
    1a98:	27 95       	ror	r18

00001a9a <didStuff7>:
    1a9a:	17 95       	ror	r17
    1a9c:	17 ff       	sbrs	r17, 7
    1a9e:	05 27       	eor	r16, r21
    1aa0:	00 00       	nop
    1aa2:	1c 3f       	cpi	r17, 0xFC	; 252
    1aa4:	0b b9       	out	0x0b, r16	; 11
    1aa6:	b0 f6       	brcc	.-84     	; 0x1a54 <bitstuff7>
    1aa8:	29 91       	ld	r18, Y+
    1aaa:	3a 95       	dec	r19
    1aac:	19 f7       	brne	.-58     	; 0x1a74 <txByteLoop>
    1aae:	07 7e       	andi	r16, 0xE7	; 231
    1ab0:	10 91 28 01 	lds	r17, 0x0128
    1ab4:	11 0f       	add	r17, r17
    1ab6:	c6 51       	subi	r28, 0x16	; 22
    1ab8:	d0 40       	sbci	r29, 0x00	; 0
    1aba:	0b b9       	out	0x0b, r16	; 11
    1abc:	11 f0       	breq	.+4      	; 0x1ac2 <skipAddrAssign>
    1abe:	10 93 22 01 	sts	0x0122, r17

00001ac2 <skipAddrAssign>:
    1ac2:	12 e0       	ldi	r17, 0x02	; 2
    1ac4:	1c bb       	out	0x1c, r17	; 28
    1ac6:	00 61       	ori	r16, 0x10	; 16
    1ac8:	1a b1       	in	r17, 0x0a	; 10
    1aca:	17 7e       	andi	r17, 0xE7	; 231
    1acc:	40 2f       	mov	r20, r16
    1ace:	47 7e       	andi	r20, 0xE7	; 231
    1ad0:	54 e0       	ldi	r21, 0x04	; 4

00001ad2 <se0Delay>:
    1ad2:	5a 95       	dec	r21
    1ad4:	f1 f7       	brne	.-4      	; 0x1ad2 <se0Delay>
    1ad6:	0b b9       	out	0x0b, r16	; 11
    1ad8:	1a b9       	out	0x0a, r17	; 10
    1ada:	4b b9       	out	0x0b, r20	; 11
    1adc:	69 cf       	rjmp	.-302    	; 0x19b0 <doReturn>

00001ade <__eerd_block>:
    1ade:	a0 e0       	ldi	r26, 0x00	; 0
    1ae0:	b0 e0       	ldi	r27, 0x00	; 0
    1ae2:	e5 e7       	ldi	r30, 0x75	; 117
    1ae4:	fd e0       	ldi	r31, 0x0D	; 13
    1ae6:	0c 94 b1 0d 	jmp	0x1b62	; 0x1b62 <__prologue_saves__+0x14>
    1aea:	7c 01       	movw	r14, r24
    1aec:	eb 01       	movw	r28, r22
    1aee:	8a 01       	movw	r16, r20
    1af0:	69 01       	movw	r12, r18
    1af2:	09 c0       	rjmp	.+18     	; 0x1b06 <__eerd_block+0x28>
    1af4:	ce 01       	movw	r24, r28
    1af6:	21 96       	adiw	r28, 0x01	; 1
    1af8:	f6 01       	movw	r30, r12
    1afa:	09 95       	icall
    1afc:	f7 01       	movw	r30, r14
    1afe:	81 93       	st	Z+, r24
    1b00:	7f 01       	movw	r14, r30
    1b02:	01 50       	subi	r16, 0x01	; 1
    1b04:	10 40       	sbci	r17, 0x00	; 0
    1b06:	01 15       	cp	r16, r1
    1b08:	11 05       	cpc	r17, r1
    1b0a:	a1 f7       	brne	.-24     	; 0x1af4 <__eerd_block+0x16>
    1b0c:	cd b7       	in	r28, 0x3d	; 61
    1b0e:	de b7       	in	r29, 0x3e	; 62
    1b10:	e8 e0       	ldi	r30, 0x08	; 8
    1b12:	0c 94 cd 0d 	jmp	0x1b9a	; 0x1b9a <__epilogue_restores__+0x14>

00001b16 <__eewr_block>:
    1b16:	a0 e0       	ldi	r26, 0x00	; 0
    1b18:	b0 e0       	ldi	r27, 0x00	; 0
    1b1a:	e1 e9       	ldi	r30, 0x91	; 145
    1b1c:	fd e0       	ldi	r31, 0x0D	; 13
    1b1e:	0c 94 b1 0d 	jmp	0x1b62	; 0x1b62 <__prologue_saves__+0x14>
    1b22:	ec 01       	movw	r28, r24
    1b24:	7b 01       	movw	r14, r22
    1b26:	8a 01       	movw	r16, r20
    1b28:	69 01       	movw	r12, r18
    1b2a:	09 c0       	rjmp	.+18     	; 0x1b3e <__eewr_block+0x28>
    1b2c:	ce 01       	movw	r24, r28
    1b2e:	21 96       	adiw	r28, 0x01	; 1
    1b30:	f7 01       	movw	r30, r14
    1b32:	61 91       	ld	r22, Z+
    1b34:	7f 01       	movw	r14, r30
    1b36:	f6 01       	movw	r30, r12
    1b38:	09 95       	icall
    1b3a:	01 50       	subi	r16, 0x01	; 1
    1b3c:	10 40       	sbci	r17, 0x00	; 0
    1b3e:	01 15       	cp	r16, r1
    1b40:	11 05       	cpc	r17, r1
    1b42:	a1 f7       	brne	.-24     	; 0x1b2c <__eewr_block+0x16>
    1b44:	cd b7       	in	r28, 0x3d	; 61
    1b46:	de b7       	in	r29, 0x3e	; 62
    1b48:	e8 e0       	ldi	r30, 0x08	; 8
    1b4a:	0c 94 cd 0d 	jmp	0x1b9a	; 0x1b9a <__epilogue_restores__+0x14>

00001b4e <__prologue_saves__>:
    1b4e:	2f 92       	push	r2
    1b50:	3f 92       	push	r3
    1b52:	4f 92       	push	r4
    1b54:	5f 92       	push	r5
    1b56:	6f 92       	push	r6
    1b58:	7f 92       	push	r7
    1b5a:	8f 92       	push	r8
    1b5c:	9f 92       	push	r9
    1b5e:	af 92       	push	r10
    1b60:	bf 92       	push	r11
    1b62:	cf 92       	push	r12
    1b64:	df 92       	push	r13
    1b66:	ef 92       	push	r14
    1b68:	ff 92       	push	r15
    1b6a:	0f 93       	push	r16
    1b6c:	1f 93       	push	r17
    1b6e:	cf 93       	push	r28
    1b70:	df 93       	push	r29
    1b72:	cd b7       	in	r28, 0x3d	; 61
    1b74:	de b7       	in	r29, 0x3e	; 62
    1b76:	ca 1b       	sub	r28, r26
    1b78:	db 0b       	sbc	r29, r27
    1b7a:	0f b6       	in	r0, 0x3f	; 63
    1b7c:	f8 94       	cli
    1b7e:	de bf       	out	0x3e, r29	; 62
    1b80:	0f be       	out	0x3f, r0	; 63
    1b82:	cd bf       	out	0x3d, r28	; 61
    1b84:	09 94       	ijmp

00001b86 <__epilogue_restores__>:
    1b86:	2a 88       	ldd	r2, Y+18	; 0x12
    1b88:	39 88       	ldd	r3, Y+17	; 0x11
    1b8a:	48 88       	ldd	r4, Y+16	; 0x10
    1b8c:	5f 84       	ldd	r5, Y+15	; 0x0f
    1b8e:	6e 84       	ldd	r6, Y+14	; 0x0e
    1b90:	7d 84       	ldd	r7, Y+13	; 0x0d
    1b92:	8c 84       	ldd	r8, Y+12	; 0x0c
    1b94:	9b 84       	ldd	r9, Y+11	; 0x0b
    1b96:	aa 84       	ldd	r10, Y+10	; 0x0a
    1b98:	b9 84       	ldd	r11, Y+9	; 0x09
    1b9a:	c8 84       	ldd	r12, Y+8	; 0x08
    1b9c:	df 80       	ldd	r13, Y+7	; 0x07
    1b9e:	ee 80       	ldd	r14, Y+6	; 0x06
    1ba0:	fd 80       	ldd	r15, Y+5	; 0x05
    1ba2:	0c 81       	ldd	r16, Y+4	; 0x04
    1ba4:	1b 81       	ldd	r17, Y+3	; 0x03
    1ba6:	aa 81       	ldd	r26, Y+2	; 0x02
    1ba8:	b9 81       	ldd	r27, Y+1	; 0x01
    1baa:	ce 0f       	add	r28, r30
    1bac:	d1 1d       	adc	r29, r1
    1bae:	0f b6       	in	r0, 0x3f	; 63
    1bb0:	f8 94       	cli
    1bb2:	de bf       	out	0x3e, r29	; 62
    1bb4:	0f be       	out	0x3f, r0	; 63
    1bb6:	cd bf       	out	0x3d, r28	; 61
    1bb8:	ed 01       	movw	r28, r26
    1bba:	08 95       	ret

00001bbc <_exit>:
    1bbc:	f8 94       	cli

00001bbe <__stop_program>:
    1bbe:	ff cf       	rjmp	.-2      	; 0x1bbe <__stop_program>
