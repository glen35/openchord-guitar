
V1_USB.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  00001d8e  00001e42  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001d8e  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000004b  00800102  00800102  00001e44  2**0
                  ALLOC
  3 .eeprom       00000172  00810000  00810000  00001e44  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 000000a0  00000000  00000000  00001fb6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000035f  00000000  00000000  00002056  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001a49  00000000  00000000  000023b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008e9  00000000  00000000  00003dfe  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000016b6  00000000  00000000  000046e7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000180  00000000  00000000  00005da0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000085b  00000000  00000000  00005f20  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000aba  00000000  00000000  0000677b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000100  00000000  00000000  00007235  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 91 00 	jmp	0x122	; 0x122 <__ctors_end>
       4:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
       8:	0c 94 11 0d 	jmp	0x1a22	; 0x1a22 <__vector_2>
       c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      10:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      14:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      18:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      1c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      20:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      24:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      28:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      2c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      30:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      34:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      38:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      3c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      40:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      44:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      48:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      4c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      50:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      54:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      58:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      5c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      60:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      64:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>

00000068 <usbDescriptorHidReport>:
      68:	05 01 09 05 a1 01 15 00 25 01 35 00 45 01 75 01     ........%.5.E.u.
      78:	95 0d 05 09 19 01 29 0d 81 02 95 03 81 01 05 01     ......).........
      88:	25 07 46 3b 01 75 04 95 01 65 14 09 39 81 42 65     %.F;.u...e..9.Be
      98:	00 95 01 81 01 26 ff 00 46 ff 00 09 30 09 31 09     .....&..F...0.1.
      a8:	32 09 35 75 08 95 04 81 02 c0                       2.5u......

000000b2 <usbDescriptorString0>:
      b2:	04 03 09 04                                         ....

000000b6 <usbDescriptorStringVendor>:
      b6:	1c 03 4f 00 70 00 65 00 6e 00 43 00 68 00 6f 00     ..O.p.e.n.C.h.o.
      c6:	72 00 64 00 2e 00 6f 00 72 00 67 00                 r.d...o.r.g.

000000d2 <usbDescriptorStringDevice>:
      d2:	14 03 56 00 31 00 20 00 47 00 75 00 69 00 74 00     ..V.1. .G.u.i.t.
      e2:	61 00 72 00                                         a.r.

000000e6 <usbDescriptorDevice>:
      e6:	12 01 10 01 00 00 00 08 ba 12 00 02 00 01 01 02     ................
      f6:	00 01                                               ..

000000f8 <usbDescriptorConfiguration>:
      f8:	09 02 29 00 01 01 00 80 32 09 04 00 00 02 03 00     ..).....2.......
     108:	00 00 09 21 01 01 00 01 22 4a 00 07 05 81 03 08     ...!...."J......
     118:	00 0a 07 05 83 03 08 00 0a 00                       ..........

00000122 <__ctors_end>:
     122:	11 24       	eor	r1, r1
     124:	1f be       	out	0x3f, r1	; 63
     126:	cf ef       	ldi	r28, 0xFF	; 255
     128:	d4 e0       	ldi	r29, 0x04	; 4
     12a:	de bf       	out	0x3e, r29	; 62
     12c:	cd bf       	out	0x3d, r28	; 61

0000012e <__do_copy_data>:
     12e:	11 e0       	ldi	r17, 0x01	; 1
     130:	a0 e0       	ldi	r26, 0x00	; 0
     132:	b1 e0       	ldi	r27, 0x01	; 1
     134:	ee e8       	ldi	r30, 0x8E	; 142
     136:	fd e1       	ldi	r31, 0x1D	; 29
     138:	02 c0       	rjmp	.+4      	; 0x13e <.do_copy_data_start>

0000013a <.do_copy_data_loop>:
     13a:	05 90       	lpm	r0, Z+
     13c:	0d 92       	st	X+, r0

0000013e <.do_copy_data_start>:
     13e:	a2 30       	cpi	r26, 0x02	; 2
     140:	b1 07       	cpc	r27, r17
     142:	d9 f7       	brne	.-10     	; 0x13a <.do_copy_data_loop>

00000144 <__do_clear_bss>:
     144:	11 e0       	ldi	r17, 0x01	; 1
     146:	a2 e0       	ldi	r26, 0x02	; 2
     148:	b1 e0       	ldi	r27, 0x01	; 1
     14a:	01 c0       	rjmp	.+2      	; 0x14e <.do_clear_bss_start>

0000014c <.do_clear_bss_loop>:
     14c:	1d 92       	st	X+, r1

0000014e <.do_clear_bss_start>:
     14e:	ad 34       	cpi	r26, 0x4D	; 77
     150:	b1 07       	cpc	r27, r17
     152:	e1 f7       	brne	.-8      	; 0x14c <.do_clear_bss_loop>
     154:	0e 94 20 01 	call	0x240	; 0x240 <main>
     158:	0c 94 c5 0e 	jmp	0x1d8a	; 0x1d8a <_exit>

0000015c <__bad_interrupt>:
     15c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000160 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
     160:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     162:	f9 99       	sbic	0x1f, 1	; 31
     164:	fe cf       	rjmp	.-4      	; 0x162 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     166:	32 bd       	out	0x22, r19	; 34
     168:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     16a:	f8 9a       	sbi	0x1f, 0	; 31
     16c:	80 b5       	in	r24, 0x20	; 32
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
     16e:	08 95       	ret

00000170 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
     170:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     172:	f9 99       	sbic	0x1f, 1	; 31
     174:	fe cf       	rjmp	.-4      	; 0x172 <eeprom_write_byte+0x2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     176:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     178:	32 bd       	out	0x22, r19	; 34
     17a:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
     17c:	60 bd       	out	0x20, r22	; 32

    __asm__ __volatile__ (
     17e:	0f b6       	in	r0, 0x3f	; 63
     180:	f8 94       	cli
     182:	fa 9a       	sbi	0x1f, 2	; 31
     184:	f9 9a       	sbi	0x1f, 1	; 31
     186:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
     188:	08 95       	ret

0000018a <readFrets>:
};

//readF reads the frets for a single string, and returns an int acting as a boolean array
//  telling which frets are being touched by the string.
int readFrets(int guitarString)
{
     18a:	1f 93       	push	r17
     18c:	cf 93       	push	r28
     18e:	df 93       	push	r29
  	string_port &= ~(1<<guitarString);  // Set the string LOW
     190:	9b b1       	in	r25, 0x0b	; 11
     192:	21 e0       	ldi	r18, 0x01	; 1
     194:	30 e0       	ldi	r19, 0x00	; 0
     196:	02 c0       	rjmp	.+4      	; 0x19c <readFrets+0x12>
     198:	22 0f       	add	r18, r18
     19a:	33 1f       	adc	r19, r19
     19c:	8a 95       	dec	r24
     19e:	e2 f7       	brpl	.-8      	; 0x198 <readFrets+0xe>
     1a0:	12 2f       	mov	r17, r18
     1a2:	82 2f       	mov	r24, r18
     1a4:	80 95       	com	r24
     1a6:	89 23       	and	r24, r25
     1a8:	8b b9       	out	0x0b, r24	; 11
     1aa:	84 e1       	ldi	r24, 0x14	; 20
     1ac:	90 e0       	ldi	r25, 0x00	; 0
	// Macro to as many NOPs as we want
	inline void doXnops(int x)
	{
		while (x >= 0)
		{
			nop();
     1ae:	00 00       	nop
			x--;
     1b0:	01 97       	sbiw	r24, 0x01	; 1
	#define nop() asm volatile("nop")

	// Macro to as many NOPs as we want
	inline void doXnops(int x)
	{
		while (x >= 0)
     1b2:	2f ef       	ldi	r18, 0xFF	; 255
     1b4:	8f 3f       	cpi	r24, 0xFF	; 255
     1b6:	92 07       	cpc	r25, r18
     1b8:	d1 f7       	brne	.-12     	; 0x1ae <readFrets+0x24>

	// Then we have to delay for a while, since right after the switch, the pin values
	// jump around a bit
	doXnops(20);	
	// Read the values on the frets
  	int i = fret_pin;               
     1ba:	83 b1       	in	r24, 0x03	; 3
	i = fret_pin;
     1bc:	83 b1       	in	r24, 0x03	; 3
	i = fret_pin;		// More delay funcitonality... without these delays, there is some bouncing
     1be:	83 b1       	in	r24, 0x03	; 3
	i = fret_pin;		// on the pins, so the read screws up.
     1c0:	83 b1       	in	r24, 0x03	; 3
	// Next, since the fret pin is zero if the a fret is grounded, we do a mask to isolate each pin from 
	//  the port, which will return a zero if pressed and non-zero if unpressed. So we ! that to get a 1 if
	//  the string touches that fret and a zero if it doesn't touch, which we then load into our storage 
	//  integer.

 	stringState |= ( (!(i & (1<<green_pin))) << 1); //green fret
     1c2:	81 fd       	sbrc	r24, 1
     1c4:	03 c0       	rjmp	.+6      	; 0x1cc <readFrets+0x42>
     1c6:	c2 e0       	ldi	r28, 0x02	; 2
     1c8:	d0 e0       	ldi	r29, 0x00	; 0
     1ca:	02 c0       	rjmp	.+4      	; 0x1d0 <readFrets+0x46>
     1cc:	c0 e0       	ldi	r28, 0x00	; 0
     1ce:	d0 e0       	ldi	r29, 0x00	; 0
 	stringState |= ( (!(i & (1<<red_pin))) << 2); //red fret
     1d0:	82 fd       	sbrc	r24, 2
     1d2:	03 c0       	rjmp	.+6      	; 0x1da <readFrets+0x50>
     1d4:	a4 e0       	ldi	r26, 0x04	; 4
     1d6:	b0 e0       	ldi	r27, 0x00	; 0
     1d8:	02 c0       	rjmp	.+4      	; 0x1de <readFrets+0x54>
     1da:	a0 e0       	ldi	r26, 0x00	; 0
     1dc:	b0 e0       	ldi	r27, 0x00	; 0
 	stringState |= ( (!(i & (1<<yellow_pin))) << 3); //yellow fret
     1de:	83 fd       	sbrc	r24, 3
     1e0:	03 c0       	rjmp	.+6      	; 0x1e8 <readFrets+0x5e>
     1e2:	e8 e0       	ldi	r30, 0x08	; 8
     1e4:	f0 e0       	ldi	r31, 0x00	; 0
     1e6:	02 c0       	rjmp	.+4      	; 0x1ec <readFrets+0x62>
     1e8:	e0 e0       	ldi	r30, 0x00	; 0
     1ea:	f0 e0       	ldi	r31, 0x00	; 0
 	stringState |= ( (!(i & (1<<blue_pin))) << 4); //blue fret
     1ec:	84 fd       	sbrc	r24, 4
     1ee:	03 c0       	rjmp	.+6      	; 0x1f6 <readFrets+0x6c>
     1f0:	60 e1       	ldi	r22, 0x10	; 16
     1f2:	70 e0       	ldi	r23, 0x00	; 0
     1f4:	02 c0       	rjmp	.+4      	; 0x1fa <readFrets+0x70>
     1f6:	60 e0       	ldi	r22, 0x00	; 0
     1f8:	70 e0       	ldi	r23, 0x00	; 0
 	stringState |= ( (!(i & (1<<orange_pin))) << 5); //orange fret
     1fa:	85 fd       	sbrc	r24, 5
     1fc:	03 c0       	rjmp	.+6      	; 0x204 <readFrets+0x7a>
     1fe:	40 e2       	ldi	r20, 0x20	; 32
     200:	50 e0       	ldi	r21, 0x00	; 0
     202:	02 c0       	rjmp	.+4      	; 0x208 <readFrets+0x7e>
     204:	40 e0       	ldi	r20, 0x00	; 0
     206:	50 e0       	ldi	r21, 0x00	; 0

	// Also, if we strummed a string, hold that in the 'zeroth' fret
	i = pick_pin;
     208:	26 b1       	in	r18, 0x06	; 6
	//  the port, which will return a zero if pressed and non-zero if unpressed. So we ! that to get a 1 if
	//  the string touches that fret and a zero if it doesn't touch, which we then load into our storage 
	//  integer.

 	stringState |= ( (!(i & (1<<green_pin))) << 1); //green fret
 	stringState |= ( (!(i & (1<<red_pin))) << 2); //red fret
     20a:	30 e0       	ldi	r19, 0x00	; 0
     20c:	36 95       	lsr	r19
     20e:	27 95       	ror	r18
     210:	36 95       	lsr	r19
     212:	27 95       	ror	r18
     214:	20 95       	com	r18
     216:	30 95       	com	r19
     218:	21 70       	andi	r18, 0x01	; 1
     21a:	30 70       	andi	r19, 0x00	; 0
     21c:	2c 2b       	or	r18, r28
     21e:	3d 2b       	or	r19, r29
 	stringState |= ( (!(i & (1<<yellow_pin))) << 3); //yellow fret
     220:	2a 2b       	or	r18, r26
     222:	3b 2b       	or	r19, r27
 	stringState |= ( (!(i & (1<<blue_pin))) << 4); //blue fret
     224:	2e 2b       	or	r18, r30
     226:	3f 2b       	or	r19, r31
 	stringState |= ( (!(i & (1<<orange_pin))) << 5); //orange fret
     228:	26 2b       	or	r18, r22
     22a:	37 2b       	or	r19, r23
	// Also, if we strummed a string, hold that in the 'zeroth' fret
	i = pick_pin;
 	stringState |= ( (!(i & (1<<strum_pin))) << 0); //pick touching the string

	//Turn the string back HIGH and return
	string_port |= (1<<guitarString); 
     22c:	8b b1       	in	r24, 0x0b	; 11
     22e:	18 2b       	or	r17, r24
     230:	1b b9       	out	0x0b, r17	; 11
     232:	24 2b       	or	r18, r20
     234:	35 2b       	or	r19, r21
	return stringState;
}
     236:	c9 01       	movw	r24, r18
     238:	df 91       	pop	r29
     23a:	cf 91       	pop	r28
     23c:	1f 91       	pop	r17
     23e:	08 95       	ret

00000240 <main>:
	 -Under config mode, the loop reads in the values of the strings and frets, assigns that current
	  string-fret combination to correspond to a button press, then locks that combination in when 
	  'Plus' is pressed and moves on to changing the next button.  It also sets the button data structure
	  to display the current controller button being programmed, and then sends that data to the controller.
*/ 
{
     240:	2f 92       	push	r2
     242:	3f 92       	push	r3
     244:	4f 92       	push	r4
     246:	5f 92       	push	r5
     248:	6f 92       	push	r6
     24a:	7f 92       	push	r7
     24c:	8f 92       	push	r8
     24e:	9f 92       	push	r9
     250:	af 92       	push	r10
     252:	bf 92       	push	r11
     254:	cf 92       	push	r12
     256:	df 92       	push	r13
     258:	ef 92       	push	r14
     25a:	ff 92       	push	r15
     25c:	0f 93       	push	r16
     25e:	1f 93       	push	r17
     260:	df 93       	push	r29
     262:	cf 93       	push	r28
     264:	cd b7       	in	r28, 0x3d	; 61
     266:	de b7       	in	r29, 0x3e	; 62
     268:	c8 54       	subi	r28, 0x48	; 72
     26a:	d1 40       	sbci	r29, 0x01	; 1
     26c:	0f b6       	in	r0, 0x3f	; 63
     26e:	f8 94       	cli
     270:	de bf       	out	0x3e, r29	; 62
     272:	0f be       	out	0x3f, r0	; 63
     274:	cd bf       	out	0x3d, r28	; 61
  // Now set up all the communication stuff - initialization routines
  //  set specially in the interface functions - see ps3interface.h, wiiinterface.h, etc.
  startCommunication();
     276:	0e 94 7a 0b 	call	0x16f4	; 0x16f4 <startCommunication>

	//Debug stuff - the following goes before the while loop in main()
	int timer;
    DDRB |= 1;
     27a:	20 9a       	sbi	0x04, 0	; 4
  // set PORTB for output
  
  uint8_t string[1];
  uint8_t x = 10;
     27c:	8a e0       	ldi	r24, 0x0A	; 10
     27e:	8a 83       	std	Y+2, r24	; 0x02
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
     280:	ce 01       	movw	r24, r28
     282:	01 96       	adiw	r24, 0x01	; 1
     284:	68 e6       	ldi	r22, 0x68	; 104
     286:	71 e0       	ldi	r23, 0x01	; 1
     288:	41 e0       	ldi	r20, 0x01	; 1
     28a:	50 e0       	ldi	r21, 0x00	; 0
     28c:	20 eb       	ldi	r18, 0xB0	; 176
     28e:	30 e0       	ldi	r19, 0x00	; 0
     290:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__eerd_block>

  eeprom_read_block( (void*)&string, (void*)&nonvolitileString, 1);
  if (string[0] == 50)
     294:	89 81       	ldd	r24, Y+1	; 0x01
     296:	be 01       	movw	r22, r28
     298:	6e 5f       	subi	r22, 0xFE	; 254
     29a:	7f 4f       	sbci	r23, 0xFF	; 255
     29c:	82 33       	cpi	r24, 0x32	; 50
     29e:	11 f4       	brne	.+4      	; 0x2a4 <main+0x64>
  {
  	  x = 250;
     2a0:	8a ef       	ldi	r24, 0xFA	; 250
     2a2:	01 c0       	rjmp	.+2      	; 0x2a6 <main+0x66>
  	  eeprom_write_block( (void*)&x, (void*)&nonvolitileString, 1);
  }
  else
  {
  	  x = 50;
     2a4:	82 e3       	ldi	r24, 0x32	; 50
     2a6:	8a 83       	std	Y+2, r24	; 0x02
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
     2a8:	88 e6       	ldi	r24, 0x68	; 104
     2aa:	91 e0       	ldi	r25, 0x01	; 1
     2ac:	41 e0       	ldi	r20, 0x01	; 1
     2ae:	50 e0       	ldi	r21, 0x00	; 0
     2b0:	28 eb       	ldi	r18, 0xB8	; 184
     2b2:	30 e0       	ldi	r19, 0x00	; 0
     2b4:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <__eewr_block>
  	  eeprom_write_block( (void*)&x, (void*)&nonvolitileString, 1);
  }
  timer = x;

	// First, set up the guitar stuff - These functions are stored in guitarInitFunctions.h/.c
	setPins();
     2b8:	0e 94 02 05 	call	0xa04	; 0xa04 <setPins>
	setTimer();	
     2bc:	0e 94 1f 05 	call	0xa3e	; 0xa3e <setTimer>

    // Declaration of variables used in Main()
	int greenTimers[NUMBER_OF_STRINGS] = {0,0,0,0,0,0}; //These give timing to properly read green buttons on each string.
     2c0:	8c e0       	ldi	r24, 0x0C	; 12
     2c2:	9e 01       	movw	r18, r28
     2c4:	2d 5e       	subi	r18, 0xED	; 237
     2c6:	3f 4f       	sbci	r19, 0xFF	; 255
     2c8:	d9 01       	movw	r26, r18
     2ca:	e8 2f       	mov	r30, r24
     2cc:	1d 92       	st	X+, r1
     2ce:	ea 95       	dec	r30
     2d0:	e9 f7       	brne	.-6      	; 0x2cc <main+0x8c>
	int triedGreen[NUMBER_OF_STRINGS] = {0,0,0,0,0,0};  // Also used for the green button timing thing
     2d2:	ae 01       	movw	r20, r28
     2d4:	41 5e       	subi	r20, 0xE1	; 225
     2d6:	5f 4f       	sbci	r21, 0xFF	; 255
     2d8:	da 01       	movw	r26, r20
     2da:	e8 2f       	mov	r30, r24
     2dc:	1d 92       	st	X+, r1
     2de:	ea 95       	dec	r30
     2e0:	e9 f7       	brne	.-6      	; 0x2dc <main+0x9c>
	int stringState[6] = {0,0,0,0,0,0}; // This stores an int for each string,
     2e2:	fe 01       	movw	r30, r28
     2e4:	bb 96       	adiw	r30, 0x2b	; 43
     2e6:	df 01       	movw	r26, r30
     2e8:	98 2f       	mov	r25, r24
     2ea:	1d 92       	st	X+, r1
     2ec:	9a 95       	dec	r25
     2ee:	e9 f7       	brne	.-6      	; 0x2ea <main+0xaa>
	int buttonStringPatterns[NUM_CHORDS_BUTTONS][NUMBER_OF_STRINGS]; //This holds the button patterns the
																	 // controller compares the string presses
																	 // to in order to judge if a button is being
																	 // pressed. It's the size of all the chord combinations,
																	 // but in Note Mode, only the first 5 blocks get looked at. 
    int stringStateTimers[NUMBER_OF_STRINGS] = {0,0,0,0,0,0};
     2f0:	be 01       	movw	r22, r28
     2f2:	6d 5b       	subi	r22, 0xBD	; 189
     2f4:	7f 4f       	sbci	r23, 0xFF	; 255
     2f6:	db 01       	movw	r26, r22
     2f8:	1d 92       	st	X+, r1
     2fa:	8a 95       	dec	r24
     2fc:	e9 f7       	brne	.-6      	; 0x2f8 <main+0xb8>

	char configMode = 0; // Start in normal mode
	int buttonToAssign = 0; // declare some variables
     2fe:	1e 82       	std	Y+6, r1	; 0x06
     300:	1d 82       	std	Y+5, r1	; 0x05
	char plusLock = 0;
     302:	1b 82       	std	Y+3, r1	; 0x03
	char previousPlusOn = 0; // This is used as a lock so we don't program all the buttons at once
     304:	1c 82       	std	Y+4, r1	; 0x04
	int debounceTimer = 0; // This is used as a global timer for debouncing buttons
     306:	18 86       	std	Y+8, r1	; 0x08
     308:	1f 82       	std	Y+7, r1	; 0x07
		char numberOfStringsPressed;
	} dataForController;

	inline void clearData(dataForController* data)
	{
		data->orangeOn = 0;
     30a:	1d 86       	std	Y+13, r1	; 0x0d
		data->blueOn   = 0;
     30c:	1c 86       	std	Y+12, r1	; 0x0c
		data->yellowOn = 0;
     30e:	1b 86       	std	Y+11, r1	; 0x0b
		data->redOn    = 0;
     310:	1a 86       	std	Y+10, r1	; 0x0a
		data->greenOn  = 0;
     312:	19 86       	std	Y+9, r1	; 0x09
		data->upOn     = 0;
     314:	1e 86       	std	Y+14, r1	; 0x0e
		data->downOn   = 0;
     316:	1f 86       	std	Y+15, r1	; 0x0f
		data->plusOn   = 0;
     318:	18 8a       	std	Y+16, r1	; 0x10
		data->minusOn  = 0;
     31a:	19 8a       	std	Y+17, r1	; 0x11
		data->numberOfStringsPressed = 0;
     31c:	1a 8a       	std	Y+18, r1	; 0x12
	
	dataForController data;
	clearData(&data); //This function is contained in configAndConstants.h

	//Debug Stuff - it's complementary code is in ps3interface.h and .c
	DDRC &= ~(1<<5); //Turn 5 on Port C to inputs
     31e:	3d 98       	cbi	0x07, 5	; 7
	PORTC |= (1<<5); //Turn off the internal pullup resistor on pin 5
     320:	45 9a       	sbi	0x08, 5	; 8
     322:	44 24       	eor	r4, r4
     324:	55 24       	eor	r5, r5
        tempStringState[0] = readFrets(first_string);
		tempStringState[1] = readFrets(second_string);
		tempStringState[2] = readFrets(third_string);
		tempStringState[3] = readFrets(fourth_string);
		tempStringState[4] = readFrets(fifth_string);
		tempStringState[5] = readFrets(sixth_string);
     326:	cf 5b       	subi	r28, 0xBF	; 191
     328:	de 4f       	sbci	r29, 0xFE	; 254
     32a:	e8 83       	st	Y, r30
     32c:	c1 54       	subi	r28, 0x41	; 65
     32e:	d1 40       	sbci	r29, 0x01	; 1
     330:	ce 5b       	subi	r28, 0xBE	; 190
     332:	de 4f       	sbci	r29, 0xFE	; 254
     334:	f8 83       	st	Y, r31
     336:	c2 54       	subi	r28, 0x42	; 66
     338:	d1 40       	sbci	r29, 0x01	; 1
     33a:	db 01       	movw	r26, r22
     33c:	cd 5b       	subi	r28, 0xBD	; 189
     33e:	de 4f       	sbci	r29, 0xFE	; 254
     340:	68 83       	st	Y, r22
     342:	c3 54       	subi	r28, 0x43	; 67
     344:	d1 40       	sbci	r29, 0x01	; 1
     346:	cc 5b       	subi	r28, 0xBC	; 188
     348:	de 4f       	sbci	r29, 0xFE	; 254
     34a:	b8 83       	st	Y, r27
     34c:	c4 54       	subi	r28, 0x44	; 68
     34e:	d1 40       	sbci	r29, 0x01	; 1

        // Debounce the strings by making sure what is being fretted
        // remains for a certain number of cycles through the main loop
        for (int i = 0; i <= 6; i++)
     350:	e7 e3       	ldi	r30, 0x37	; 55
     352:	f0 e0       	ldi	r31, 0x00	; 0
     354:	ec 0f       	add	r30, r28
     356:	fd 1f       	adc	r31, r29
     358:	3e 96       	adiw	r30, 0x0e	; 14
     35a:	c1 5c       	subi	r28, 0xC1	; 193
     35c:	de 4f       	sbci	r29, 0xFE	; 254
     35e:	f9 83       	std	Y+1, r31	; 0x01
     360:	e8 83       	st	Y, r30
     362:	cf 53       	subi	r28, 0x3F	; 63
     364:	d1 40       	sbci	r29, 0x01	; 1
			// Next, using our strumState array, we process that data to figure out what sort
			//  of buttons on the controller we want to emulate pressing.
			// find out if we're in a transitional controller mode or not
			if (!(controllerMode % 2)) // Not a transitional mode
			{	//  This function can be found in processStringState.h/.c
				processStringState(&data, stringState, buttonStringPatterns, controllerMode, greenTimers, triedGreen);
     366:	6f e4       	ldi	r22, 0x4F	; 79
     368:	66 2e       	mov	r6, r22
     36a:	71 2c       	mov	r7, r1
     36c:	6c 0e       	add	r6, r28
     36e:	7d 1e       	adc	r7, r29
     370:	cb 5b       	subi	r28, 0xBB	; 187
     372:	de 4f       	sbci	r29, 0xFE	; 254
     374:	28 83       	st	Y, r18
     376:	c5 54       	subi	r28, 0x45	; 69
     378:	d1 40       	sbci	r29, 0x01	; 1
     37a:	ca 5b       	subi	r28, 0xBA	; 186
     37c:	de 4f       	sbci	r29, 0xFE	; 254
     37e:	38 83       	st	Y, r19
     380:	c6 54       	subi	r28, 0x46	; 70
     382:	d1 40       	sbci	r29, 0x01	; 1
     384:	c9 5b       	subi	r28, 0xB9	; 185
     386:	de 4f       	sbci	r29, 0xFE	; 254
     388:	48 83       	st	Y, r20
     38a:	c7 54       	subi	r28, 0x47	; 71
     38c:	d1 40       	sbci	r29, 0x01	; 1
     38e:	c8 5b       	subi	r28, 0xB8	; 184
     390:	de 4f       	sbci	r29, 0xFE	; 254
     392:	58 83       	st	Y, r21
     394:	c8 54       	subi	r28, 0x48	; 72
     396:	d1 40       	sbci	r29, 0x01	; 1
	// array as something big enough for all 21 chord mode combinations, but we
	// only write the first 5 patterns when we write these ones to EEPROM
	int buttonStringPatterns[NUM_CHORDS_BUTTONS][NUMBER_OF_STRINGS];

    buttonStringPatterns[0][0] = 0b0000000; // [0][0] through [0][5] - green button
    buttonStringPatterns[0][0] = 0x0000000; // [0][0] through [0][5] - green button
     398:	97 ec       	ldi	r25, 0xC7	; 199
     39a:	89 2e       	mov	r8, r25
     39c:	91 2c       	mov	r9, r1
     39e:	8c 0e       	add	r8, r28
     3a0:	9d 1e       	adc	r9, r29
	buttonStringPatterns[0][1] = 0b0001100; 
     3a2:	8c e0       	ldi	r24, 0x0C	; 12
     3a4:	28 2e       	mov	r2, r24
     3a6:	31 2c       	mov	r3, r1
	              /* main event loop */


		// We first read all the strings for button hits and store them into
		//  our stringState array.  Strum processing is also handled here for now.
        tempStringState[0] = readFrets(first_string);
     3a8:	87 e0       	ldi	r24, 0x07	; 7
     3aa:	90 e0       	ldi	r25, 0x00	; 0
     3ac:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     3b0:	98 af       	std	Y+56, r25	; 0x38
     3b2:	8f ab       	std	Y+55, r24	; 0x37
		tempStringState[1] = readFrets(second_string);
     3b4:	86 e0       	ldi	r24, 0x06	; 6
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     3bc:	9a af       	std	Y+58, r25	; 0x3a
     3be:	89 af       	std	Y+57, r24	; 0x39
		tempStringState[2] = readFrets(third_string);
     3c0:	85 e0       	ldi	r24, 0x05	; 5
     3c2:	90 e0       	ldi	r25, 0x00	; 0
     3c4:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     3c8:	9c af       	std	Y+60, r25	; 0x3c
     3ca:	8b af       	std	Y+59, r24	; 0x3b
		tempStringState[3] = readFrets(fourth_string);
     3cc:	82 e0       	ldi	r24, 0x02	; 2
     3ce:	90 e0       	ldi	r25, 0x00	; 0
     3d0:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     3d4:	9e af       	std	Y+62, r25	; 0x3e
     3d6:	8d af       	std	Y+61, r24	; 0x3d
		tempStringState[4] = readFrets(fifth_string);
     3d8:	81 e0       	ldi	r24, 0x01	; 1
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     3e0:	21 96       	adiw	r28, 0x01	; 1
     3e2:	9f af       	std	Y+63, r25	; 0x3f
     3e4:	8e af       	std	Y+62, r24	; 0x3e
     3e6:	21 97       	sbiw	r28, 0x01	; 1
		tempStringState[5] = readFrets(sixth_string);
     3e8:	80 e0       	ldi	r24, 0x00	; 0
     3ea:	90 e0       	ldi	r25, 0x00	; 0
     3ec:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     3f0:	23 96       	adiw	r28, 0x03	; 3
     3f2:	9f af       	std	Y+63, r25	; 0x3f
     3f4:	8e af       	std	Y+62, r24	; 0x3e
     3f6:	23 97       	sbiw	r28, 0x03	; 3
     3f8:	9e 01       	movw	r18, r28
     3fa:	29 5c       	subi	r18, 0xC9	; 201
     3fc:	3f 4f       	sbci	r19, 0xFF	; 255
     3fe:	cf 5b       	subi	r28, 0xBF	; 191
     400:	de 4f       	sbci	r29, 0xFE	; 254
     402:	88 81       	ld	r24, Y
     404:	c1 54       	subi	r28, 0x41	; 65
     406:	d1 40       	sbci	r29, 0x01	; 1
     408:	ce 5b       	subi	r28, 0xBE	; 190
     40a:	de 4f       	sbci	r29, 0xFE	; 254
     40c:	98 81       	ld	r25, Y
     40e:	c2 54       	subi	r28, 0x42	; 66
     410:	d1 40       	sbci	r29, 0x01	; 1
     412:	bc 01       	movw	r22, r24
     414:	cd 5b       	subi	r28, 0xBD	; 189
     416:	de 4f       	sbci	r29, 0xFE	; 254
     418:	88 81       	ld	r24, Y
     41a:	c3 54       	subi	r28, 0x43	; 67
     41c:	d1 40       	sbci	r29, 0x01	; 1
     41e:	cc 5b       	subi	r28, 0xBC	; 188
     420:	de 4f       	sbci	r29, 0xFE	; 254
     422:	98 81       	ld	r25, Y
     424:	c4 54       	subi	r28, 0x44	; 68
     426:	d1 40       	sbci	r29, 0x01	; 1
     428:	fc 01       	movw	r30, r24

        // Debounce the strings by making sure what is being fretted
        // remains for a certain number of cycles through the main loop
        for (int i = 0; i <= 6; i++)
        {
                if (tempStringState[i] == stringState[i])
     42a:	d9 01       	movw	r26, r18
     42c:	4d 91       	ld	r20, X+
     42e:	5c 91       	ld	r21, X
     430:	db 01       	movw	r26, r22
     432:	8d 91       	ld	r24, X+
     434:	9c 91       	ld	r25, X
     436:	48 17       	cp	r20, r24
     438:	59 07       	cpc	r21, r25
     43a:	19 f4       	brne	.+6      	; 0x442 <main+0x202>
                        stringStateTimers[i] = 0;
     43c:	11 82       	std	Z+1, r1	; 0x01
     43e:	10 82       	st	Z, r1
     440:	05 c0       	rjmp	.+10     	; 0x44c <main+0x20c>
                else
                        stringStateTimers[i] += 1;
     442:	80 81       	ld	r24, Z
     444:	91 81       	ldd	r25, Z+1	; 0x01
     446:	01 96       	adiw	r24, 0x01	; 1
     448:	91 83       	std	Z+1, r25	; 0x01
     44a:	80 83       	st	Z, r24
                // If we've seen enough cycles of a new string state, update stringState 
                if (stringStateTimers[i] >= STRING_DEBOUNCE_DELAY)
     44c:	80 81       	ld	r24, Z
     44e:	91 81       	ldd	r25, Z+1	; 0x01
     450:	0f 97       	sbiw	r24, 0x0f	; 15
     452:	2c f0       	brlt	.+10     	; 0x45e <main+0x21e>
                {
                        stringState[i] = tempStringState[i];
     454:	db 01       	movw	r26, r22
     456:	4d 93       	st	X+, r20
     458:	5c 93       	st	X, r21
                        stringStateTimers[i] = 0;
     45a:	11 82       	std	Z+1, r1	; 0x01
     45c:	10 82       	st	Z, r1
     45e:	2e 5f       	subi	r18, 0xFE	; 254
     460:	3f 4f       	sbci	r19, 0xFF	; 255
     462:	6e 5f       	subi	r22, 0xFE	; 254
     464:	7f 4f       	sbci	r23, 0xFF	; 255
     466:	32 96       	adiw	r30, 0x02	; 2
		tempStringState[4] = readFrets(fifth_string);
		tempStringState[5] = readFrets(sixth_string);

        // Debounce the strings by making sure what is being fretted
        // remains for a certain number of cycles through the main loop
        for (int i = 0; i <= 6; i++)
     468:	c1 5c       	subi	r28, 0xC1	; 193
     46a:	de 4f       	sbci	r29, 0xFE	; 254
     46c:	88 81       	ld	r24, Y
     46e:	99 81       	ldd	r25, Y+1	; 0x01
     470:	cf 53       	subi	r28, 0x3F	; 63
     472:	d1 40       	sbci	r29, 0x01	; 1
     474:	28 17       	cp	r18, r24
     476:	39 07       	cpc	r19, r25
     478:	c1 f6       	brne	.-80     	; 0x42a <main+0x1ea>
		char numberOfStringsPressed;
	} dataForController;

	inline void clearData(dataForController* data)
	{
		data->orangeOn = 0;
     47a:	1d 86       	std	Y+13, r1	; 0x0d
		data->blueOn   = 0;
     47c:	1c 86       	std	Y+12, r1	; 0x0c
		data->yellowOn = 0;
     47e:	1b 86       	std	Y+11, r1	; 0x0b
		data->redOn    = 0;
     480:	1a 86       	std	Y+10, r1	; 0x0a
		data->greenOn  = 0;
     482:	19 86       	std	Y+9, r1	; 0x09
		data->upOn     = 0;
     484:	1e 86       	std	Y+14, r1	; 0x0e
		data->downOn   = 0;
     486:	1f 86       	std	Y+15, r1	; 0x0f
		data->plusOn   = 0;
		data->minusOn  = 0;
		data->numberOfStringsPressed = 0;
     488:	1a 8a       	std	Y+18, r1	; 0x12

// This function just reads our plus and minus buttons and sets the data struct accordingly
inline void readOtherButtons(dataForController* data)
{
	// read our plus and minus buttons
	int i = misc_pin; // check for plus and minus
     48a:	86 b1       	in	r24, 0x06	; 6
     48c:	90 e0       	ldi	r25, 0x00	; 0
	data->plusOn = !(i & (1<<plus_pin)); //Plus and minus are held high normally, but pressing it drops it low
     48e:	41 e0       	ldi	r20, 0x01	; 1
     490:	50 e0       	ldi	r21, 0x00	; 0
     492:	9c 01       	movw	r18, r24
     494:	24 27       	eor	r18, r20
     496:	35 27       	eor	r19, r21
     498:	21 70       	andi	r18, 0x01	; 1
     49a:	28 8b       	std	Y+16, r18	; 0x10
	data->minusOn = !(i & (1<<minus_pin));
     49c:	96 95       	lsr	r25
     49e:	87 95       	ror	r24
     4a0:	84 27       	eor	r24, r20
     4a2:	95 27       	eor	r25, r21
     4a4:	81 70       	andi	r24, 0x01	; 1
     4a6:	89 8b       	std	Y+17, r24	; 0x11
		return 0;
}

inline int testForResetButtonPatterns(int stringState[])
{
	if ((stringState[0] == 0b00100000) &&
     4a8:	8b a5       	ldd	r24, Y+43	; 0x2b
     4aa:	9c a5       	ldd	r25, Y+44	; 0x2c
     4ac:	80 97       	sbiw	r24, 0x20	; 32
     4ae:	09 f0       	breq	.+2      	; 0x4b2 <main+0x272>
     4b0:	e8 c0       	rjmp	.+464    	; 0x682 <__stack+0x183>
     4b2:	8d a5       	ldd	r24, Y+45	; 0x2d
     4b4:	9e a5       	ldd	r25, Y+46	; 0x2e
     4b6:	89 2b       	or	r24, r25
     4b8:	09 f0       	breq	.+2      	; 0x4bc <main+0x27c>
     4ba:	e3 c0       	rjmp	.+454    	; 0x682 <__stack+0x183>
     4bc:	8f a5       	ldd	r24, Y+47	; 0x2f
     4be:	98 a9       	ldd	r25, Y+48	; 0x30
     4c0:	80 97       	sbiw	r24, 0x20	; 32
     4c2:	09 f0       	breq	.+2      	; 0x4c6 <main+0x286>
     4c4:	de c0       	rjmp	.+444    	; 0x682 <__stack+0x183>
     4c6:	89 a9       	ldd	r24, Y+49	; 0x31
     4c8:	9a a9       	ldd	r25, Y+50	; 0x32
     4ca:	89 2b       	or	r24, r25
     4cc:	09 f0       	breq	.+2      	; 0x4d0 <main+0x290>
     4ce:	d9 c0       	rjmp	.+434    	; 0x682 <__stack+0x183>
     4d0:	8b a9       	ldd	r24, Y+51	; 0x33
     4d2:	9c a9       	ldd	r25, Y+52	; 0x34
     4d4:	80 97       	sbiw	r24, 0x20	; 32
     4d6:	09 f0       	breq	.+2      	; 0x4da <main+0x29a>
     4d8:	d4 c0       	rjmp	.+424    	; 0x682 <__stack+0x183>
     4da:	8d a9       	ldd	r24, Y+53	; 0x35
     4dc:	9e a9       	ldd	r25, Y+54	; 0x36
     4de:	89 2b       	or	r24, r25
     4e0:	09 f0       	breq	.+2      	; 0x4e4 <main+0x2a4>
     4e2:	cf c0       	rjmp	.+414    	; 0x682 <__stack+0x183>
	// array as something big enough for all 21 chord mode combinations, but we
	// only write the first 5 patterns when we write these ones to EEPROM
	int buttonStringPatterns[NUM_CHORDS_BUTTONS][NUMBER_OF_STRINGS];

    buttonStringPatterns[0][0] = 0b0000000; // [0][0] through [0][5] - green button
    buttonStringPatterns[0][0] = 0x0000000; // [0][0] through [0][5] - green button
     4e4:	d4 01       	movw	r26, r8
     4e6:	11 96       	adiw	r26, 0x01	; 1
     4e8:	1c 92       	st	X, r1
     4ea:	1e 92       	st	-X, r1
	buttonStringPatterns[0][1] = 0b0001100; 
     4ec:	13 96       	adiw	r26, 0x03	; 3
     4ee:	3c 92       	st	X, r3
     4f0:	2e 92       	st	-X, r2
     4f2:	12 97       	sbiw	r26, 0x02	; 2
	buttonStringPatterns[0][2] = 0b0000000;	
     4f4:	15 96       	adiw	r26, 0x05	; 5
     4f6:	1c 92       	st	X, r1
     4f8:	1e 92       	st	-X, r1
     4fa:	14 97       	sbiw	r26, 0x04	; 4
	buttonStringPatterns[0][3] = 0b0000110;
     4fc:	06 e0       	ldi	r16, 0x06	; 6
     4fe:	10 e0       	ldi	r17, 0x00	; 0
     500:	17 96       	adiw	r26, 0x07	; 7
     502:	1c 93       	st	X, r17
     504:	0e 93       	st	-X, r16
     506:	16 97       	sbiw	r26, 0x06	; 6
	buttonStringPatterns[0][4] = 0b0000000;
     508:	19 96       	adiw	r26, 0x09	; 9
     50a:	1c 92       	st	X, r1
     50c:	1e 92       	st	-X, r1
     50e:	18 97       	sbiw	r26, 0x08	; 8
	buttonStringPatterns[0][5] = 0b0000010;
     510:	82 e0       	ldi	r24, 0x02	; 2
     512:	90 e0       	ldi	r25, 0x00	; 0
     514:	1b 96       	adiw	r26, 0x0b	; 11
     516:	9c 93       	st	X, r25
     518:	8e 93       	st	-X, r24
     51a:	1a 97       	sbiw	r26, 0x0a	; 10

	buttonStringPatterns[1][0] = 0b0000010; // [1][0] through [1][5] - red button
     51c:	1d 96       	adiw	r26, 0x0d	; 13
     51e:	9c 93       	st	X, r25
     520:	8e 93       	st	-X, r24
     522:	1c 97       	sbiw	r26, 0x0c	; 12
	buttonStringPatterns[1][1] = 0b0000000; 
     524:	1f 96       	adiw	r26, 0x0f	; 15
     526:	1c 92       	st	X, r1
     528:	1e 92       	st	-X, r1
     52a:	1e 97       	sbiw	r26, 0x0e	; 14
	buttonStringPatterns[1][2] = 0b0000001;
     52c:	51 96       	adiw	r26, 0x11	; 17
     52e:	5c 93       	st	X, r21
     530:	4e 93       	st	-X, r20
     532:	50 97       	sbiw	r26, 0x10	; 16
	buttonStringPatterns[1][3] = 0b0000000;
     534:	53 96       	adiw	r26, 0x13	; 19
     536:	1c 92       	st	X, r1
     538:	1e 92       	st	-X, r1
     53a:	52 97       	sbiw	r26, 0x12	; 18
	buttonStringPatterns[1][4] = 0b0000001;
     53c:	55 96       	adiw	r26, 0x15	; 21
     53e:	5c 93       	st	X, r21
     540:	4e 93       	st	-X, r20
     542:	54 97       	sbiw	r26, 0x14	; 20
	buttonStringPatterns[1][5] = 0b0001100;
     544:	57 96       	adiw	r26, 0x17	; 23
     546:	3c 92       	st	X, r3
     548:	2e 92       	st	-X, r2
     54a:	56 97       	sbiw	r26, 0x16	; 22

	buttonStringPatterns[2][0] = 0b0001100; // [2][0] through [2][5] - yellow button
     54c:	59 96       	adiw	r26, 0x19	; 25
     54e:	3c 92       	st	X, r3
     550:	2e 92       	st	-X, r2
     552:	58 97       	sbiw	r26, 0x18	; 24
	buttonStringPatterns[2][1] = 0b0000000; // This is an A chord.
     554:	5b 96       	adiw	r26, 0x1b	; 27
     556:	1c 92       	st	X, r1
     558:	1e 92       	st	-X, r1
     55a:	5a 97       	sbiw	r26, 0x1a	; 26
	buttonStringPatterns[2][2] = 0b0000110;
     55c:	5d 96       	adiw	r26, 0x1d	; 29
     55e:	1c 93       	st	X, r17
     560:	0e 93       	st	-X, r16
     562:	5c 97       	sbiw	r26, 0x1c	; 28
	buttonStringPatterns[2][3] = 0b0000000;
     564:	5f 96       	adiw	r26, 0x1f	; 31
     566:	1c 92       	st	X, r1
     568:	1e 92       	st	-X, r1
     56a:	5e 97       	sbiw	r26, 0x1e	; 30
	buttonStringPatterns[2][4] = 0b0000010;
     56c:	91 96       	adiw	r26, 0x21	; 33
     56e:	9c 93       	st	X, r25
     570:	8e 93       	st	-X, r24
     572:	90 97       	sbiw	r26, 0x20	; 32
	buttonStringPatterns[2][5] = 0b0000000;
     574:	93 96       	adiw	r26, 0x23	; 35
     576:	1c 92       	st	X, r1
     578:	1e 92       	st	-X, r1
     57a:	92 97       	sbiw	r26, 0x22	; 34
							  
	buttonStringPatterns[3][0] = 0b0000000; // [3][0] through [3][5] - blue button
     57c:	95 96       	adiw	r26, 0x25	; 37
     57e:	1c 92       	st	X, r1
     580:	1e 92       	st	-X, r1
     582:	94 97       	sbiw	r26, 0x24	; 36
	buttonStringPatterns[3][1] = 0b0000001; 
     584:	97 96       	adiw	r26, 0x27	; 39
     586:	5c 93       	st	X, r21
     588:	4e 93       	st	-X, r20
     58a:	96 97       	sbiw	r26, 0x26	; 38
	buttonStringPatterns[3][2] = 0b0001100;
     58c:	99 96       	adiw	r26, 0x29	; 41
     58e:	3c 92       	st	X, r3
     590:	2e 92       	st	-X, r2
     592:	98 97       	sbiw	r26, 0x28	; 40
	buttonStringPatterns[3][3] = 0b0000000;
     594:	9b 96       	adiw	r26, 0x2b	; 43
     596:	1c 92       	st	X, r1
     598:	1e 92       	st	-X, r1
     59a:	9a 97       	sbiw	r26, 0x2a	; 42
	buttonStringPatterns[3][4] = 0b0001100;
     59c:	9d 96       	adiw	r26, 0x2d	; 45
     59e:	3c 92       	st	X, r3
     5a0:	2e 92       	st	-X, r2
     5a2:	9c 97       	sbiw	r26, 0x2c	; 44
	buttonStringPatterns[3][5] = 0b0000000;
     5a4:	9f 96       	adiw	r26, 0x2f	; 47
     5a6:	1c 92       	st	X, r1
     5a8:	1e 92       	st	-X, r1
     5aa:	9e 97       	sbiw	r26, 0x2e	; 46

	buttonStringPatterns[4][0] = 0b0000000; // [4][0] through [4][5] - orange button
     5ac:	d1 96       	adiw	r26, 0x31	; 49
     5ae:	1c 92       	st	X, r1
     5b0:	1e 92       	st	-X, r1
     5b2:	d0 97       	sbiw	r26, 0x30	; 48
	buttonStringPatterns[4][1] = 0b0000110; 
     5b4:	d3 96       	adiw	r26, 0x33	; 51
     5b6:	1c 93       	st	X, r17
     5b8:	0e 93       	st	-X, r16
     5ba:	d2 97       	sbiw	r26, 0x32	; 50
	buttonStringPatterns[4][2] = 0b0000000;
     5bc:	d5 96       	adiw	r26, 0x35	; 53
     5be:	1c 92       	st	X, r1
     5c0:	1e 92       	st	-X, r1
     5c2:	d4 97       	sbiw	r26, 0x34	; 52
	buttonStringPatterns[4][3] = 0b0000001;
     5c4:	d7 96       	adiw	r26, 0x37	; 55
     5c6:	5c 93       	st	X, r21
     5c8:	4e 93       	st	-X, r20
     5ca:	d6 97       	sbiw	r26, 0x36	; 54
	buttonStringPatterns[4][4] = 0b0000000;
     5cc:	d9 96       	adiw	r26, 0x39	; 57
     5ce:	1c 92       	st	X, r1
     5d0:	1e 92       	st	-X, r1
     5d2:	d8 97       	sbiw	r26, 0x38	; 56
	buttonStringPatterns[4][5] = 0b0000001;
     5d4:	db 96       	adiw	r26, 0x3b	; 59
     5d6:	5c 93       	st	X, r21
     5d8:	4e 93       	st	-X, r20
     5da:	da 97       	sbiw	r26, 0x3a	; 58
     5dc:	80 e0       	ldi	r24, 0x00	; 0
     5de:	90 e0       	ldi	r25, 0x00	; 0
     5e0:	b4 01       	movw	r22, r8
     5e2:	4c e3       	ldi	r20, 0x3C	; 60
     5e4:	50 e0       	ldi	r21, 0x00	; 0
     5e6:	28 eb       	ldi	r18, 0xB8	; 184
     5e8:	30 e0       	ldi	r19, 0x00	; 0
     5ea:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <__eewr_block>

	eeprom_write_block( (void*)&buttonStringPatterns, notesAddress, EEPROM_NOTES_BLOCK_SIZE);


	// Now write the default chord mapping
	buttonStringPatterns[0][0] = 0b0001110; // [0][0] through [0][5] - green button
     5ee:	8e e0       	ldi	r24, 0x0E	; 14
     5f0:	90 e0       	ldi	r25, 0x00	; 0
     5f2:	f4 01       	movw	r30, r8
     5f4:	91 83       	std	Z+1, r25	; 0x01
     5f6:	80 83       	st	Z, r24
	buttonStringPatterns[0][1] = 0b0001110; // This is a G Chord
     5f8:	93 83       	std	Z+3, r25	; 0x03
     5fa:	82 83       	std	Z+2, r24	; 0x02
	buttonStringPatterns[0][2] = 0b0000000;	
     5fc:	15 82       	std	Z+5, r1	; 0x05
     5fe:	14 82       	std	Z+4, r1	; 0x04
	buttonStringPatterns[0][3] = 0b0000000;
     600:	17 82       	std	Z+7, r1	; 0x07
     602:	16 82       	std	Z+6, r1	; 0x06
	buttonStringPatterns[0][4] = 0b0000000;
     604:	11 86       	std	Z+9, r1	; 0x09
     606:	10 86       	std	Z+8, r1	; 0x08
	buttonStringPatterns[0][5] = 0b0001110;
     608:	93 87       	std	Z+11, r25	; 0x0b
     60a:	82 87       	std	Z+10, r24	; 0x0a

	buttonStringPatterns[1][0] = 0b0000000; // [1][0] through [1][5] - red button
     60c:	15 86       	std	Z+13, r1	; 0x0d
     60e:	14 86       	std	Z+12, r1	; 0x0c
	buttonStringPatterns[1][1] = 0b0001110; // This is a C chord
     610:	97 87       	std	Z+15, r25	; 0x0f
     612:	86 87       	std	Z+14, r24	; 0x0e
	buttonStringPatterns[1][2] = 0b0001110;
     614:	91 8b       	std	Z+17, r25	; 0x11
     616:	80 8b       	std	Z+16, r24	; 0x10
	buttonStringPatterns[1][3] = 0b0000000;
     618:	13 8a       	std	Z+19, r1	; 0x13
     61a:	12 8a       	std	Z+18, r1	; 0x12
	buttonStringPatterns[1][4] = 0b0001110;
     61c:	95 8b       	std	Z+21, r25	; 0x15
     61e:	84 8b       	std	Z+20, r24	; 0x14
	buttonStringPatterns[1][5] = 0b0000000;
     620:	17 8a       	std	Z+23, r1	; 0x17
     622:	16 8a       	std	Z+22, r1	; 0x16

	buttonStringPatterns[2][0] = 0b0000000; // [2][0] through [2][5] - yellow button
     624:	11 8e       	std	Z+25, r1	; 0x19
     626:	10 8e       	std	Z+24, r1	; 0x18
	buttonStringPatterns[2][1] = 0b0000110; // This is an E chord.
     628:	13 8f       	std	Z+27, r17	; 0x1b
     62a:	02 8f       	std	Z+26, r16	; 0x1a
	buttonStringPatterns[2][2] = 0b0000110;
     62c:	15 8f       	std	Z+29, r17	; 0x1d
     62e:	04 8f       	std	Z+28, r16	; 0x1c
	buttonStringPatterns[2][3] = 0b0000110;
     630:	17 8f       	std	Z+31, r17	; 0x1f
     632:	06 8f       	std	Z+30, r16	; 0x1e
	buttonStringPatterns[2][4] = 0b0000000;
     634:	11 a2       	std	Z+33, r1	; 0x21
     636:	10 a2       	std	Z+32, r1	; 0x20
	buttonStringPatterns[2][5] = 0b0000000;
     638:	13 a2       	std	Z+35, r1	; 0x23
     63a:	12 a2       	std	Z+34, r1	; 0x22
									  
	buttonStringPatterns[3][0] = 0b0000000; // [3][0] through [3][5] - blue button
     63c:	15 a2       	std	Z+37, r1	; 0x25
     63e:	14 a2       	std	Z+36, r1	; 0x24
	buttonStringPatterns[3][1] = 0b0000000; // This an A chord
     640:	17 a2       	std	Z+39, r1	; 0x27
     642:	16 a2       	std	Z+38, r1	; 0x26
	buttonStringPatterns[3][2] = 0b0000110;
     644:	11 a7       	std	Z+41, r17	; 0x29
     646:	00 a7       	std	Z+40, r16	; 0x28
	buttonStringPatterns[3][3] = 0b0000110;
     648:	13 a7       	std	Z+43, r17	; 0x2b
     64a:	02 a7       	std	Z+42, r16	; 0x2a
	buttonStringPatterns[3][4] = 0b0000110;
     64c:	15 a7       	std	Z+45, r17	; 0x2d
     64e:	04 a7       	std	Z+44, r16	; 0x2c
	buttonStringPatterns[3][5] = 0b0000000;
     650:	17 a6       	std	Z+47, r1	; 0x2f
     652:	16 a6       	std	Z+46, r1	; 0x2e

	buttonStringPatterns[4][0] = 0b0000000; // [4][0] through [4][5] - blue button
     654:	11 aa       	std	Z+49, r1	; 0x31
     656:	10 aa       	std	Z+48, r1	; 0x30
	buttonStringPatterns[4][1] = 0b0000000;	// This is a D chord 
     658:	13 aa       	std	Z+51, r1	; 0x33
     65a:	12 aa       	std	Z+50, r1	; 0x32
	buttonStringPatterns[4][2] = 0b0000000;
     65c:	15 aa       	std	Z+53, r1	; 0x35
     65e:	14 aa       	std	Z+52, r1	; 0x34
	buttonStringPatterns[4][3] = 0b0001110;
     660:	97 ab       	std	Z+55, r25	; 0x37
     662:	86 ab       	std	Z+54, r24	; 0x36
	buttonStringPatterns[4][4] = 0b0001110;
     664:	91 af       	std	Z+57, r25	; 0x39
     666:	80 af       	std	Z+56, r24	; 0x38
	buttonStringPatterns[4][5] = 0b0001110;
     668:	93 af       	std	Z+59, r25	; 0x3b
     66a:	82 af       	std	Z+58, r24	; 0x3a
     66c:	88 e7       	ldi	r24, 0x78	; 120
     66e:	90 e0       	ldi	r25, 0x00	; 0
     670:	b4 01       	movw	r22, r8
     672:	48 e7       	ldi	r20, 0x78	; 120
     674:	50 e0       	ldi	r21, 0x00	; 0
     676:	28 eb       	ldi	r18, 0xB8	; 184
     678:	30 e0       	ldi	r19, 0x00	; 0
     67a:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <__eewr_block>
     67e:	55 24       	eor	r5, r5
     680:	fb c0       	rjmp	.+502    	; 0x878 <__stack+0x379>
			//if so, reset the button mappings to default and the play mode to chords.
			controllerMode = FRETS;
			setEepromToDefault(&notesModeButtonPatterns, &chordModeButtonPatterns); // Stored in buttonStringPatterns.h
		}

		if ((controllerMode == NOTES) || (controllerMode == CHORDS))
     682:	f2 e0       	ldi	r31, 0x02	; 2
     684:	5f 16       	cp	r5, r31
     686:	21 f0       	breq	.+8      	; 0x690 <__stack+0x191>
     688:	84 e0       	ldi	r24, 0x04	; 4
     68a:	58 16       	cp	r5, r24
     68c:	09 f0       	breq	.+2      	; 0x690 <__stack+0x191>
     68e:	f4 c0       	rjmp	.+488    	; 0x878 <__stack+0x379>
		{
			// Check to see if we're trying to enter Config Mode; disabled if we're playing with frets
			if (configMode == 0)
     690:	44 20       	and	r4, r4
     692:	09 f0       	breq	.+2      	; 0x696 <__stack+0x197>
     694:	9f c0       	rjmp	.+318    	; 0x7d4 <__stack+0x2d5>

// This function tests to see if you're pressing the top 4 strings on the orange fret,
//  thereby activating config mode. Works with both chords and scales.
inline char testForConfigMode(int stringState[])
{
	if ((stringState[0] == 0b00100000) &&
     696:	8b a5       	ldd	r24, Y+43	; 0x2b
     698:	9c a5       	ldd	r25, Y+44	; 0x2c
     69a:	80 97       	sbiw	r24, 0x20	; 32
     69c:	09 f0       	breq	.+2      	; 0x6a0 <__stack+0x1a1>
     69e:	97 c0       	rjmp	.+302    	; 0x7ce <__stack+0x2cf>
     6a0:	8d a5       	ldd	r24, Y+45	; 0x2d
     6a2:	9e a5       	ldd	r25, Y+46	; 0x2e
     6a4:	80 97       	sbiw	r24, 0x20	; 32
     6a6:	09 f0       	breq	.+2      	; 0x6aa <__stack+0x1ab>
     6a8:	92 c0       	rjmp	.+292    	; 0x7ce <__stack+0x2cf>
     6aa:	8f a5       	ldd	r24, Y+47	; 0x2f
     6ac:	98 a9       	ldd	r25, Y+48	; 0x30
     6ae:	80 97       	sbiw	r24, 0x20	; 32
     6b0:	09 f0       	breq	.+2      	; 0x6b4 <__stack+0x1b5>
     6b2:	8d c0       	rjmp	.+282    	; 0x7ce <__stack+0x2cf>
     6b4:	89 a9       	ldd	r24, Y+49	; 0x31
     6b6:	9a a9       	ldd	r25, Y+50	; 0x32
     6b8:	89 2b       	or	r24, r25
     6ba:	09 f0       	breq	.+2      	; 0x6be <__stack+0x1bf>
     6bc:	88 c0       	rjmp	.+272    	; 0x7ce <__stack+0x2cf>
     6be:	8b a9       	ldd	r24, Y+51	; 0x33
     6c0:	9c a9       	ldd	r25, Y+52	; 0x34
     6c2:	89 2b       	or	r24, r25
     6c4:	09 f0       	breq	.+2      	; 0x6c8 <__stack+0x1c9>
     6c6:	83 c0       	rjmp	.+262    	; 0x7ce <__stack+0x2cf>
     6c8:	8d a9       	ldd	r24, Y+53	; 0x35
     6ca:	9e a9       	ldd	r25, Y+54	; 0x36
     6cc:	89 2b       	or	r24, r25
     6ce:	09 f0       	breq	.+2      	; 0x6d2 <__stack+0x1d3>
     6d0:	7e c0       	rjmp	.+252    	; 0x7ce <__stack+0x2cf>
			{
				configMode = testForConfigMode(stringState);
				
				// If we're playing with notes, when we enter config mode, we need to clear the 
				//  button string patterns once so we can rebuild them.
				if (configMode == 1 && controllerMode == NOTES)
     6d2:	92 e0       	ldi	r25, 0x02	; 2
     6d4:	59 16       	cp	r5, r25
     6d6:	09 f0       	breq	.+2      	; 0x6da <__stack+0x1db>
     6d8:	78 c0       	rjmp	.+240    	; 0x7ca <__stack+0x2cb>
	return stringState;
}

inline void clearButtonStringPatterns(int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
	buttonStringPatterns[0][0] = 0;	buttonStringPatterns[0][1] = 0;
     6da:	d3 01       	movw	r26, r6
     6dc:	11 96       	adiw	r26, 0x01	; 1
     6de:	1c 92       	st	X, r1
     6e0:	1e 92       	st	-X, r1
     6e2:	13 96       	adiw	r26, 0x03	; 3
     6e4:	1c 92       	st	X, r1
     6e6:	1e 92       	st	-X, r1
     6e8:	12 97       	sbiw	r26, 0x02	; 2
	buttonStringPatterns[0][2] = 0;	buttonStringPatterns[0][3] = 0;
     6ea:	15 96       	adiw	r26, 0x05	; 5
     6ec:	1c 92       	st	X, r1
     6ee:	1e 92       	st	-X, r1
     6f0:	14 97       	sbiw	r26, 0x04	; 4
     6f2:	17 96       	adiw	r26, 0x07	; 7
     6f4:	1c 92       	st	X, r1
     6f6:	1e 92       	st	-X, r1
     6f8:	16 97       	sbiw	r26, 0x06	; 6
	buttonStringPatterns[0][4] = 0;	buttonStringPatterns[0][5] = 0;
     6fa:	19 96       	adiw	r26, 0x09	; 9
     6fc:	1c 92       	st	X, r1
     6fe:	1e 92       	st	-X, r1
     700:	18 97       	sbiw	r26, 0x08	; 8
     702:	1b 96       	adiw	r26, 0x0b	; 11
     704:	1c 92       	st	X, r1
     706:	1e 92       	st	-X, r1
     708:	1a 97       	sbiw	r26, 0x0a	; 10
	buttonStringPatterns[1][0] = 0;	buttonStringPatterns[1][1] = 0;
     70a:	1d 96       	adiw	r26, 0x0d	; 13
     70c:	1c 92       	st	X, r1
     70e:	1e 92       	st	-X, r1
     710:	1c 97       	sbiw	r26, 0x0c	; 12
     712:	1f 96       	adiw	r26, 0x0f	; 15
     714:	1c 92       	st	X, r1
     716:	1e 92       	st	-X, r1
     718:	1e 97       	sbiw	r26, 0x0e	; 14
	buttonStringPatterns[1][2] = 0;	buttonStringPatterns[1][3] = 0;
     71a:	51 96       	adiw	r26, 0x11	; 17
     71c:	1c 92       	st	X, r1
     71e:	1e 92       	st	-X, r1
     720:	50 97       	sbiw	r26, 0x10	; 16
     722:	53 96       	adiw	r26, 0x13	; 19
     724:	1c 92       	st	X, r1
     726:	1e 92       	st	-X, r1
     728:	52 97       	sbiw	r26, 0x12	; 18
	buttonStringPatterns[1][4] = 0;	buttonStringPatterns[1][5] = 0;
     72a:	55 96       	adiw	r26, 0x15	; 21
     72c:	1c 92       	st	X, r1
     72e:	1e 92       	st	-X, r1
     730:	54 97       	sbiw	r26, 0x14	; 20
     732:	57 96       	adiw	r26, 0x17	; 23
     734:	1c 92       	st	X, r1
     736:	1e 92       	st	-X, r1
     738:	56 97       	sbiw	r26, 0x16	; 22
	buttonStringPatterns[2][0] = 0;	buttonStringPatterns[2][1] = 0;
     73a:	59 96       	adiw	r26, 0x19	; 25
     73c:	1c 92       	st	X, r1
     73e:	1e 92       	st	-X, r1
     740:	58 97       	sbiw	r26, 0x18	; 24
     742:	5b 96       	adiw	r26, 0x1b	; 27
     744:	1c 92       	st	X, r1
     746:	1e 92       	st	-X, r1
     748:	5a 97       	sbiw	r26, 0x1a	; 26
	buttonStringPatterns[2][2] = 0;	buttonStringPatterns[2][3] = 0;
     74a:	5d 96       	adiw	r26, 0x1d	; 29
     74c:	1c 92       	st	X, r1
     74e:	1e 92       	st	-X, r1
     750:	5c 97       	sbiw	r26, 0x1c	; 28
     752:	5f 96       	adiw	r26, 0x1f	; 31
     754:	1c 92       	st	X, r1
     756:	1e 92       	st	-X, r1
     758:	5e 97       	sbiw	r26, 0x1e	; 30
	buttonStringPatterns[2][4] = 0;	buttonStringPatterns[2][5] = 0;
     75a:	91 96       	adiw	r26, 0x21	; 33
     75c:	1c 92       	st	X, r1
     75e:	1e 92       	st	-X, r1
     760:	90 97       	sbiw	r26, 0x20	; 32
     762:	93 96       	adiw	r26, 0x23	; 35
     764:	1c 92       	st	X, r1
     766:	1e 92       	st	-X, r1
     768:	92 97       	sbiw	r26, 0x22	; 34
	buttonStringPatterns[3][0] = 0;	buttonStringPatterns[3][1] = 0;
     76a:	95 96       	adiw	r26, 0x25	; 37
     76c:	1c 92       	st	X, r1
     76e:	1e 92       	st	-X, r1
     770:	94 97       	sbiw	r26, 0x24	; 36
     772:	97 96       	adiw	r26, 0x27	; 39
     774:	1c 92       	st	X, r1
     776:	1e 92       	st	-X, r1
     778:	96 97       	sbiw	r26, 0x26	; 38
	buttonStringPatterns[3][2] = 0;	buttonStringPatterns[3][3] = 0;
     77a:	99 96       	adiw	r26, 0x29	; 41
     77c:	1c 92       	st	X, r1
     77e:	1e 92       	st	-X, r1
     780:	98 97       	sbiw	r26, 0x28	; 40
     782:	9b 96       	adiw	r26, 0x2b	; 43
     784:	1c 92       	st	X, r1
     786:	1e 92       	st	-X, r1
     788:	9a 97       	sbiw	r26, 0x2a	; 42
	buttonStringPatterns[3][4] = 0;	buttonStringPatterns[3][5] = 0;
     78a:	9d 96       	adiw	r26, 0x2d	; 45
     78c:	1c 92       	st	X, r1
     78e:	1e 92       	st	-X, r1
     790:	9c 97       	sbiw	r26, 0x2c	; 44
     792:	9f 96       	adiw	r26, 0x2f	; 47
     794:	1c 92       	st	X, r1
     796:	1e 92       	st	-X, r1
     798:	9e 97       	sbiw	r26, 0x2e	; 46
	buttonStringPatterns[4][0] = 0;	buttonStringPatterns[4][1] = 0;
     79a:	d1 96       	adiw	r26, 0x31	; 49
     79c:	1c 92       	st	X, r1
     79e:	1e 92       	st	-X, r1
     7a0:	d0 97       	sbiw	r26, 0x30	; 48
     7a2:	d3 96       	adiw	r26, 0x33	; 51
     7a4:	1c 92       	st	X, r1
     7a6:	1e 92       	st	-X, r1
     7a8:	d2 97       	sbiw	r26, 0x32	; 50
	buttonStringPatterns[4][2] = 0;	buttonStringPatterns[4][3] = 0;
     7aa:	d5 96       	adiw	r26, 0x35	; 53
     7ac:	1c 92       	st	X, r1
     7ae:	1e 92       	st	-X, r1
     7b0:	d4 97       	sbiw	r26, 0x34	; 52
     7b2:	d7 96       	adiw	r26, 0x37	; 55
     7b4:	1c 92       	st	X, r1
     7b6:	1e 92       	st	-X, r1
     7b8:	d6 97       	sbiw	r26, 0x36	; 54
	buttonStringPatterns[4][4] = 0;	buttonStringPatterns[4][5] = 0;
     7ba:	d9 96       	adiw	r26, 0x39	; 57
     7bc:	1c 92       	st	X, r1
     7be:	1e 92       	st	-X, r1
     7c0:	d8 97       	sbiw	r26, 0x38	; 56
     7c2:	db 96       	adiw	r26, 0x3b	; 59
     7c4:	1c 92       	st	X, r1
     7c6:	1e 92       	st	-X, r1
     7c8:	da 97       	sbiw	r26, 0x3a	; 58
     7ca:	44 24       	eor	r4, r4
     7cc:	43 94       	inc	r4
				//  button string patterns once so we can rebuild them.
				if (configMode == 1 && controllerMode == NOTES)
				{
					clearButtonStringPatterns(buttonStringPatterns);
				}
				buttonToAssign = 0; // This variable keeps track of which button we're assigning
     7ce:	1e 82       	std	Y+6, r1	; 0x06
     7d0:	1d 82       	std	Y+5, r1	; 0x05
				plusLock = 0; // This is a tool to let us test that in the prior cycle, plus was or wasn't on
     7d2:	1b 82       	std	Y+3, r1	; 0x03
			}

			// Config Mode operation
			if (configMode == 1) 
     7d4:	b1 e0       	ldi	r27, 0x01	; 1
     7d6:	4b 16       	cp	r4, r27
     7d8:	09 f0       	breq	.+2      	; 0x7dc <__stack+0x2dd>
     7da:	4e c0       	rjmp	.+156    	; 0x878 <__stack+0x379>
}

//This function tests to see if we're pressing the correct string combination to end config mode
inline char testForEndConfigMode(int stringState[])
{
	if ((stringState[0] == 0b00000000) &&
     7dc:	8b a5       	ldd	r24, Y+43	; 0x2b
     7de:	9c a5       	ldd	r25, Y+44	; 0x2c
     7e0:	89 2b       	or	r24, r25
     7e2:	09 f0       	breq	.+2      	; 0x7e6 <__stack+0x2e7>
     7e4:	e7 c0       	rjmp	.+462    	; 0x9b4 <__stack+0x4b5>
     7e6:	8d a5       	ldd	r24, Y+45	; 0x2d
     7e8:	9e a5       	ldd	r25, Y+46	; 0x2e
     7ea:	80 97       	sbiw	r24, 0x20	; 32
     7ec:	09 f0       	breq	.+2      	; 0x7f0 <__stack+0x2f1>
     7ee:	e2 c0       	rjmp	.+452    	; 0x9b4 <__stack+0x4b5>
     7f0:	8f a5       	ldd	r24, Y+47	; 0x2f
     7f2:	98 a9       	ldd	r25, Y+48	; 0x30
     7f4:	80 97       	sbiw	r24, 0x20	; 32
     7f6:	09 f0       	breq	.+2      	; 0x7fa <__stack+0x2fb>
     7f8:	dd c0       	rjmp	.+442    	; 0x9b4 <__stack+0x4b5>
     7fa:	89 a9       	ldd	r24, Y+49	; 0x31
     7fc:	9a a9       	ldd	r25, Y+50	; 0x32
     7fe:	80 97       	sbiw	r24, 0x20	; 32
     800:	09 f0       	breq	.+2      	; 0x804 <__stack+0x305>
     802:	d8 c0       	rjmp	.+432    	; 0x9b4 <__stack+0x4b5>
     804:	8b a9       	ldd	r24, Y+51	; 0x33
     806:	9c a9       	ldd	r25, Y+52	; 0x34
     808:	89 2b       	or	r24, r25
     80a:	09 f0       	breq	.+2      	; 0x80e <__stack+0x30f>
     80c:	d3 c0       	rjmp	.+422    	; 0x9b4 <__stack+0x4b5>
     80e:	8d a9       	ldd	r24, Y+53	; 0x35
     810:	9e a9       	ldd	r25, Y+54	; 0x36
     812:	89 2b       	or	r24, r25
     814:	09 f0       	breq	.+2      	; 0x818 <__stack+0x319>
     816:	ce c0       	rjmp	.+412    	; 0x9b4 <__stack+0x4b5>
				if (testForEndConfigMode(stringState))
					{
						// Now save this new button mapping to the EEPROM 
						// Since we're already passing in buttonsStringPatterns
						// as a pointer, we don't use the '&' operator
						if (controllerMode == NOTES)
     818:	e2 e0       	ldi	r30, 0x02	; 2
     81a:	5e 16       	cp	r5, r30
     81c:	31 f4       	brne	.+12     	; 0x82a <__stack+0x32b>
     81e:	80 e0       	ldi	r24, 0x00	; 0
     820:	90 e0       	ldi	r25, 0x00	; 0
     822:	b3 01       	movw	r22, r6
     824:	4c e3       	ldi	r20, 0x3C	; 60
     826:	50 e0       	ldi	r21, 0x00	; 0
     828:	22 c0       	rjmp	.+68     	; 0x86e <__stack+0x36f>
							eeprom_write_block( (void*)buttonStringPatterns, (void*)&notesModeButtonPatterns, EEPROM_NOTES_BLOCK_SIZE);
						else if (controllerMode == CHORDS)
     82a:	f4 e0       	ldi	r31, 0x04	; 4
     82c:	5f 16       	cp	r5, r31
     82e:	39 f5       	brne	.+78     	; 0x87e <__stack+0x37f>
     830:	19 c0       	rjmp	.+50     	; 0x864 <__stack+0x365>
					
					data.plusOn = 0; // Make sure we're not actually sending a "plus" signal to the controller, though.
									// If we were, it would pause the game.

					// If we've assigned allcolors in Notes mode, cycle back to programming Green 
					if (controllerMode == NOTES && buttonToAssign >= NUM_NOTES_BUTTONS && plusLock == 0 )
     832:	8d 81       	ldd	r24, Y+5	; 0x05
     834:	9e 81       	ldd	r25, Y+6	; 0x06
     836:	05 97       	sbiw	r24, 0x05	; 5
     838:	0c f4       	brge	.+2      	; 0x83c <__stack+0x33d>
     83a:	af c0       	rjmp	.+350    	; 0x99a <__stack+0x49b>
     83c:	8b 81       	ldd	r24, Y+3	; 0x03
     83e:	88 23       	and	r24, r24
     840:	09 f0       	breq	.+2      	; 0x844 <__stack+0x345>
     842:	ab c0       	rjmp	.+342    	; 0x99a <__stack+0x49b>
					{
						buttonToAssign = 0;
     844:	1e 82       	std	Y+6, r1	; 0x06
     846:	1d 82       	std	Y+5, r1	; 0x05
     848:	a8 c0       	rjmp	.+336    	; 0x99a <__stack+0x49b>
					}
					
					// Or if we've programmed all 10 notes in Chord mode, exit programming mode
					if (controllerMode == CHORDS && buttonToAssign >= NUM_CHORDS_BUTTONS && plusLock == 0 )
     84a:	84 e0       	ldi	r24, 0x04	; 4
     84c:	58 16       	cp	r5, r24
     84e:	09 f0       	breq	.+2      	; 0x852 <__stack+0x353>
     850:	a4 c0       	rjmp	.+328    	; 0x99a <__stack+0x49b>
     852:	8d 81       	ldd	r24, Y+5	; 0x05
     854:	9e 81       	ldd	r25, Y+6	; 0x06
     856:	0a 97       	sbiw	r24, 0x0a	; 10
     858:	0c f4       	brge	.+2      	; 0x85c <__stack+0x35d>
     85a:	9f c0       	rjmp	.+318    	; 0x99a <__stack+0x49b>
     85c:	8b 81       	ldd	r24, Y+3	; 0x03
     85e:	88 23       	and	r24, r24
     860:	09 f0       	breq	.+2      	; 0x864 <__stack+0x365>
     862:	9b c0       	rjmp	.+310    	; 0x99a <__stack+0x49b>
     864:	88 e7       	ldi	r24, 0x78	; 120
     866:	90 e0       	ldi	r25, 0x00	; 0
     868:	b3 01       	movw	r22, r6
     86a:	48 e7       	ldi	r20, 0x78	; 120
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	28 eb       	ldi	r18, 0xB8	; 184
     870:	30 e0       	ldi	r19, 0x00	; 0
     872:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <__eewr_block>
     876:	03 c0       	rjmp	.+6      	; 0x87e <__stack+0x37f>
					}
		}	}	}	 // End of Config Mode code

		
		// Normal operation
		if (configMode == 0)
     878:	44 20       	and	r4, r4
     87a:	09 f0       	breq	.+2      	; 0x87e <__stack+0x37f>
     87c:	8e c0       	rjmp	.+284    	; 0x99a <__stack+0x49b>
		return 0;
}

inline int testForMinusChord(int stringState[])
{
	if ((stringState[0] == 0b00000000) &&
     87e:	8b a5       	ldd	r24, Y+43	; 0x2b
     880:	9c a5       	ldd	r25, Y+44	; 0x2c
     882:	89 2b       	or	r24, r25
     884:	09 f0       	breq	.+2      	; 0x888 <__stack+0x389>
     886:	5b c0       	rjmp	.+182    	; 0x93e <__stack+0x43f>
     888:	8d a5       	ldd	r24, Y+45	; 0x2d
     88a:	9e a5       	ldd	r25, Y+46	; 0x2e
     88c:	89 2b       	or	r24, r25
     88e:	09 f0       	breq	.+2      	; 0x892 <__stack+0x393>
     890:	56 c0       	rjmp	.+172    	; 0x93e <__stack+0x43f>
     892:	2f a5       	ldd	r18, Y+47	; 0x2f
     894:	38 a9       	ldd	r19, Y+48	; 0x30
     896:	21 15       	cp	r18, r1
     898:	31 05       	cpc	r19, r1
     89a:	71 f4       	brne	.+28     	; 0x8b8 <__stack+0x3b9>
     89c:	89 a9       	ldd	r24, Y+49	; 0x31
     89e:	9a a9       	ldd	r25, Y+50	; 0x32
     8a0:	89 2b       	or	r24, r25
     8a2:	51 f4       	brne	.+20     	; 0x8b8 <__stack+0x3b9>
     8a4:	8b a9       	ldd	r24, Y+51	; 0x33
     8a6:	9c a9       	ldd	r25, Y+52	; 0x34
     8a8:	89 2b       	or	r24, r25
     8aa:	31 f4       	brne	.+12     	; 0x8b8 <__stack+0x3b9>
     8ac:	8d a9       	ldd	r24, Y+53	; 0x35
     8ae:	9e a9       	ldd	r25, Y+54	; 0x36
     8b0:	80 97       	sbiw	r24, 0x20	; 32
     8b2:	11 f4       	brne	.+4      	; 0x8b8 <__stack+0x3b9>
		{
			//Test if Minus is being played by the chord instead of the button
			// This means it won't get read in config mode, which is good.
			if(testForMinusChord(stringState))
				data.minusOn = 1;
     8b4:	91 e0       	ldi	r25, 0x01	; 1
     8b6:	99 8b       	std	Y+17, r25	; 0x11
}

inline int testForSwitchModes(int stringState[])
{
	// Test for the right keypress to start the mode
	if ((stringState[0] == 0b00000000) &&
     8b8:	20 32       	cpi	r18, 0x20	; 32
     8ba:	31 05       	cpc	r19, r1
     8bc:	81 f4       	brne	.+32     	; 0x8de <__stack+0x3df>
     8be:	89 a9       	ldd	r24, Y+49	; 0x31
     8c0:	9a a9       	ldd	r25, Y+50	; 0x32
     8c2:	80 97       	sbiw	r24, 0x20	; 32
     8c4:	e1 f5       	brne	.+120    	; 0x93e <__stack+0x43f>
     8c6:	8b a9       	ldd	r24, Y+51	; 0x33
     8c8:	9c a9       	ldd	r25, Y+52	; 0x34
     8ca:	80 97       	sbiw	r24, 0x20	; 32
     8cc:	c1 f5       	brne	.+112    	; 0x93e <__stack+0x43f>
     8ce:	8d a9       	ldd	r24, Y+53	; 0x35
     8d0:	9e a9       	ldd	r25, Y+54	; 0x36
     8d2:	89 2b       	or	r24, r25
     8d4:	a1 f5       	brne	.+104    	; 0x93e <__stack+0x43f>
static inline void switchPlayModes(int stringState[], int buttonStringPatterns[][6], char* controllerMode)
{
	// Test for the right keypress to start the mode
	if (testForSwitchModes(stringState))
	{
		if (*controllerMode % 2 == 0) // This means that the mode is a full mode
     8d6:	50 fc       	sbrc	r5, 0
     8d8:	32 c0       	rjmp	.+100    	; 0x93e <__stack+0x43f>
			{++*controllerMode;}  //This puts it into a transitional mode
     8da:	53 94       	inc	r5
     8dc:	30 c0       	rjmp	.+96     	; 0x93e <__stack+0x43f>
		return 0;
}

inline int testForNoStringsPressed(int stringState[])
{
	if ((stringState[0] == 0b00000000) &&
     8de:	23 2b       	or	r18, r19
     8e0:	71 f5       	brne	.+92     	; 0x93e <__stack+0x43f>
     8e2:	89 a9       	ldd	r24, Y+49	; 0x31
     8e4:	9a a9       	ldd	r25, Y+50	; 0x32
     8e6:	89 2b       	or	r24, r25
     8e8:	51 f5       	brne	.+84     	; 0x93e <__stack+0x43f>
     8ea:	8b a9       	ldd	r24, Y+51	; 0x33
     8ec:	9c a9       	ldd	r25, Y+52	; 0x34
     8ee:	89 2b       	or	r24, r25
     8f0:	31 f5       	brne	.+76     	; 0x93e <__stack+0x43f>
     8f2:	8d a9       	ldd	r24, Y+53	; 0x35
     8f4:	9e a9       	ldd	r25, Y+54	; 0x36
     8f6:	89 2b       	or	r24, r25
     8f8:	11 f5       	brne	.+68     	; 0x93e <__stack+0x43f>
	}
	// And if we're not pressing that anymore, switch from the transitional mode to the regular mode,
	//  resetting the button patterns as necessary
	else if(testForNoStringsPressed(stringState)) 
	{
		if (*controllerMode == CHORDS_TO_FRETS) // since these modes are just numbers, we need to wrap around
     8fa:	a5 e0       	ldi	r26, 0x05	; 5
     8fc:	5a 16       	cp	r5, r26
     8fe:	11 f4       	brne	.+4      	; 0x904 <__stack+0x405>
     900:	55 24       	eor	r5, r5
     902:	1d c0       	rjmp	.+58     	; 0x93e <__stack+0x43f>
			{*controllerMode = FRETS;}

		// Now, reset the buttonStringPattern array to be appropriate for the mode
		// For this, we'll read it from the EEPROM memory.
		else if (*controllerMode  == FRETS_TO_NOTES)
     904:	b1 e0       	ldi	r27, 0x01	; 1
     906:	5b 16       	cp	r5, r27
     908:	61 f4       	brne	.+24     	; 0x922 <__stack+0x423>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
     90a:	c3 01       	movw	r24, r6
     90c:	60 e0       	ldi	r22, 0x00	; 0
     90e:	70 e0       	ldi	r23, 0x00	; 0
     910:	4c e3       	ldi	r20, 0x3C	; 60
     912:	50 e0       	ldi	r21, 0x00	; 0
     914:	20 eb       	ldi	r18, 0xB0	; 176
     916:	30 e0       	ldi	r19, 0x00	; 0
     918:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__eerd_block>
     91c:	12 e0       	ldi	r17, 0x02	; 2
     91e:	51 2e       	mov	r5, r17
     920:	0e c0       	rjmp	.+28     	; 0x93e <__stack+0x43f>
		{
			// Notice, we're already passing in buttonStringPatterns as an address, so the EEPROM read looks a bit strange
			eeprom_read_block( (void*)buttonStringPatterns, (void*)&notesModeButtonPatterns, EEPROM_NOTES_BLOCK_SIZE);
			*controllerMode = NOTES;
		}
		else if (*controllerMode  == NOTES_TO_CHORDS)
     922:	e3 e0       	ldi	r30, 0x03	; 3
     924:	5e 16       	cp	r5, r30
     926:	59 f4       	brne	.+22     	; 0x93e <__stack+0x43f>
     928:	c3 01       	movw	r24, r6
     92a:	68 e7       	ldi	r22, 0x78	; 120
     92c:	70 e0       	ldi	r23, 0x00	; 0
     92e:	48 e7       	ldi	r20, 0x78	; 120
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	20 eb       	ldi	r18, 0xB0	; 176
     934:	30 e0       	ldi	r19, 0x00	; 0
     936:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__eerd_block>
     93a:	b4 e0       	ldi	r27, 0x04	; 4
     93c:	5b 2e       	mov	r5, r27
			switchPlayModes(stringState, buttonStringPatterns, &controllerMode);

			// Next, using our strumState array, we process that data to figure out what sort
			//  of buttons on the controller we want to emulate pressing.
			// find out if we're in a transitional controller mode or not
			if (!(controllerMode % 2)) // Not a transitional mode
     93e:	65 2d       	mov	r22, r5
     940:	50 fc       	sbrc	r5, 0
     942:	25 c0       	rjmp	.+74     	; 0x98e <__stack+0x48f>
			{	//  This function can be found in processStringState.h/.c
				processStringState(&data, stringState, buttonStringPatterns, controllerMode, greenTimers, triedGreen);
     944:	ce 01       	movw	r24, r28
     946:	09 96       	adiw	r24, 0x09	; 9
     948:	cf 5b       	subi	r28, 0xBF	; 191
     94a:	de 4f       	sbci	r29, 0xFE	; 254
     94c:	68 81       	ld	r22, Y
     94e:	c1 54       	subi	r28, 0x41	; 65
     950:	d1 40       	sbci	r29, 0x01	; 1
     952:	ce 5b       	subi	r28, 0xBE	; 190
     954:	de 4f       	sbci	r29, 0xFE	; 254
     956:	78 81       	ld	r23, Y
     958:	c2 54       	subi	r28, 0x42	; 66
     95a:	d1 40       	sbci	r29, 0x01	; 1
     95c:	a3 01       	movw	r20, r6
     95e:	25 2d       	mov	r18, r5
     960:	cb 5b       	subi	r28, 0xBB	; 187
     962:	de 4f       	sbci	r29, 0xFE	; 254
     964:	08 81       	ld	r16, Y
     966:	c5 54       	subi	r28, 0x45	; 69
     968:	d1 40       	sbci	r29, 0x01	; 1
     96a:	ca 5b       	subi	r28, 0xBA	; 186
     96c:	de 4f       	sbci	r29, 0xFE	; 254
     96e:	18 81       	ld	r17, Y
     970:	c6 54       	subi	r28, 0x46	; 70
     972:	d1 40       	sbci	r29, 0x01	; 1
     974:	c9 5b       	subi	r28, 0xB9	; 185
     976:	de 4f       	sbci	r29, 0xFE	; 254
     978:	e8 80       	ld	r14, Y
     97a:	c7 54       	subi	r28, 0x47	; 71
     97c:	d1 40       	sbci	r29, 0x01	; 1
     97e:	c8 5b       	subi	r28, 0xB8	; 184
     980:	de 4f       	sbci	r29, 0xFE	; 254
     982:	f8 80       	ld	r15, Y
     984:	c8 54       	subi	r28, 0x48	; 72
     986:	d1 40       	sbci	r29, 0x01	; 1
     988:	0e 94 4c 09 	call	0x1298	; 0x1298 <processStringState>
     98c:	05 c0       	rjmp	.+10     	; 0x998 <__stack+0x499>
			}
			else
			{   // Now, if we're in a transitional controller mode, we'll forget that data and substitue 
				// visual cue data to show that we're changing to a specific mode
				//  The function itself can be found in processStringState.h/.c
				displayTransitionState(&data, controllerMode);
     98e:	ce 01       	movw	r24, r28
     990:	09 96       	adiw	r24, 0x09	; 9
     992:	70 e0       	ldi	r23, 0x00	; 0
     994:	0e 94 63 09 	call	0x12c6	; 0x12c6 <displayTransitionState>
     998:	44 24       	eor	r4, r4
		}
			    
		// Now our processing is complete, so using those button presses, we set up the 
		// button data packet. This function depends on the console and is 
		// set specially in the interface functions - see ps3interface.h, wiiinterface.h, etc.
		sendData(data);
     99a:	09 85       	ldd	r16, Y+9	; 0x09
     99c:	1a 85       	ldd	r17, Y+10	; 0x0a
     99e:	2b 85       	ldd	r18, Y+11	; 0x0b
     9a0:	3c 85       	ldd	r19, Y+12	; 0x0c
     9a2:	4d 85       	ldd	r20, Y+13	; 0x0d
     9a4:	5e 85       	ldd	r21, Y+14	; 0x0e
     9a6:	6f 85       	ldd	r22, Y+15	; 0x0f
     9a8:	78 89       	ldd	r23, Y+16	; 0x10
     9aa:	89 89       	ldd	r24, Y+17	; 0x11
     9ac:	9a 89       	ldd	r25, Y+18	; 0x12
     9ae:	0e 94 12 0b 	call	0x1624	; 0x1624 <sendData>
     9b2:	fa cc       	rjmp	.-1548   	; 0x3a8 <main+0x168>
				else
				{
					// Now set up the data packet to the interface layer to say we're pressing whatever button we're currently
					// assigning, and if we're pressing 'plus', go ahead and lock that string combination in
					//  The function itself can be found in processStringState.h/.c
					configSetButtonData(&data, &buttonToAssign, buttonStringPatterns, stringState, controllerMode,
     9b4:	ce 01       	movw	r24, r28
     9b6:	09 96       	adiw	r24, 0x09	; 9
     9b8:	be 01       	movw	r22, r28
     9ba:	6b 5f       	subi	r22, 0xFB	; 251
     9bc:	7f 4f       	sbci	r23, 0xFF	; 255
     9be:	a3 01       	movw	r20, r6
     9c0:	cf 5b       	subi	r28, 0xBF	; 191
     9c2:	de 4f       	sbci	r29, 0xFE	; 254
     9c4:	28 81       	ld	r18, Y
     9c6:	c1 54       	subi	r28, 0x41	; 65
     9c8:	d1 40       	sbci	r29, 0x01	; 1
     9ca:	ce 5b       	subi	r28, 0xBE	; 190
     9cc:	de 4f       	sbci	r29, 0xFE	; 254
     9ce:	38 81       	ld	r19, Y
     9d0:	c2 54       	subi	r28, 0x42	; 66
     9d2:	d1 40       	sbci	r29, 0x01	; 1
     9d4:	05 2d       	mov	r16, r5
     9d6:	a3 e0       	ldi	r26, 0x03	; 3
     9d8:	ea 2e       	mov	r14, r26
     9da:	f1 2c       	mov	r15, r1
     9dc:	ec 0e       	add	r14, r28
     9de:	fd 1e       	adc	r15, r29
     9e0:	f4 e0       	ldi	r31, 0x04	; 4
     9e2:	cf 2e       	mov	r12, r31
     9e4:	d1 2c       	mov	r13, r1
     9e6:	cc 0e       	add	r12, r28
     9e8:	dd 1e       	adc	r13, r29
     9ea:	e7 e0       	ldi	r30, 0x07	; 7
     9ec:	ae 2e       	mov	r10, r30
     9ee:	b1 2c       	mov	r11, r1
     9f0:	ac 0e       	add	r10, r28
     9f2:	bd 1e       	adc	r11, r29
     9f4:	0e 94 79 09 	call	0x12f2	; 0x12f2 <configSetButtonData>
											&plusLock, &previousPlusOn, &debounceTimer);
					
					data.plusOn = 0; // Make sure we're not actually sending a "plus" signal to the controller, though.
     9f8:	18 8a       	std	Y+16, r1	; 0x10
									// If we were, it would pause the game.

					// If we've assigned allcolors in Notes mode, cycle back to programming Green 
					if (controllerMode == NOTES && buttonToAssign >= NUM_NOTES_BUTTONS && plusLock == 0 )
     9fa:	f2 e0       	ldi	r31, 0x02	; 2
     9fc:	5f 16       	cp	r5, r31
     9fe:	09 f0       	breq	.+2      	; 0xa02 <__stack+0x503>
     a00:	24 cf       	rjmp	.-440    	; 0x84a <__stack+0x34b>
     a02:	17 cf       	rjmp	.-466    	; 0x832 <__stack+0x333>

00000a04 <setPins>:
#include "guitarInitFunctions.h"

void setPins(void)
{
	// Set the fret pins as input pins, with internal resistor
	fret_ddr &= ~(1<<green_pin);        // input
     a04:	21 98       	cbi	0x04, 1	; 4
	fret_port |= (1<<green_pin);		//pull-up enabled	
     a06:	29 9a       	sbi	0x05, 1	; 5
	fret_ddr &= ~(1<<red_pin);
     a08:	22 98       	cbi	0x04, 2	; 4
	fret_port |= (1<<red_pin);
     a0a:	2a 9a       	sbi	0x05, 2	; 5
	fret_ddr &= ~(1<<yellow_pin);
     a0c:	23 98       	cbi	0x04, 3	; 4
	fret_port |= (1<<yellow_pin);
     a0e:	2b 9a       	sbi	0x05, 3	; 5
	fret_ddr &= ~(1<<blue_pin);
     a10:	24 98       	cbi	0x04, 4	; 4
	fret_port |= (1<<blue_pin);
     a12:	2c 9a       	sbi	0x05, 4	; 5
	fret_ddr &= ~(1<<orange_pin);
     a14:	25 98       	cbi	0x04, 5	; 4
	fret_port |= (1<<orange_pin);
     a16:	2d 9a       	sbi	0x05, 5	; 5

	// Set the pins on strumming and plus as inputs, with internal resistor
	misc_ddr &= ~(1<<plus_pin);
     a18:	38 98       	cbi	0x07, 0	; 7
	misc_port |= (1<<plus_pin);
     a1a:	40 9a       	sbi	0x08, 0	; 8
	misc_ddr &= ~(1<<minus_pin);
     a1c:	39 98       	cbi	0x07, 1	; 7
	misc_port |= (1<<minus_pin);
     a1e:	41 9a       	sbi	0x08, 1	; 8

	pick_ddr &= ~(1<<strum_pin);
     a20:	3a 98       	cbi	0x07, 2	; 7
	pick_port |= (1<<strum_pin);
     a22:	42 9a       	sbi	0x08, 2	; 8

	// Set the string pins as output pins, outputting HIGH
	/* MAKE SURE YOU HAVE DIODES OPPOSING THIS CURRENT OUTFLOW! */
	string_ddr |= (1<<first_string);  //output
     a24:	57 9a       	sbi	0x0a, 7	; 10
	string_port |= (1<<first_string); // set high
     a26:	5f 9a       	sbi	0x0b, 7	; 11
	string_ddr |= (1<<second_string);  
     a28:	56 9a       	sbi	0x0a, 6	; 10
	string_port |= (1<<second_string);
     a2a:	5e 9a       	sbi	0x0b, 6	; 11
	string_ddr |= (1<<third_string);  
     a2c:	55 9a       	sbi	0x0a, 5	; 10
	string_port |= (1<<third_string);
     a2e:	5d 9a       	sbi	0x0b, 5	; 11
	string_ddr |= (1<<fourth_string);  
     a30:	52 9a       	sbi	0x0a, 2	; 10
	string_port |= (1<<fourth_string);
     a32:	5a 9a       	sbi	0x0b, 2	; 11
	string_ddr |= (1<<fifth_string);  
     a34:	51 9a       	sbi	0x0a, 1	; 10
	string_port |= (1<<fifth_string);
     a36:	59 9a       	sbi	0x0b, 1	; 11
	string_ddr |= (1<<sixth_string);  
     a38:	50 9a       	sbi	0x0a, 0	; 10
	string_port |= (1<<sixth_string);
     a3a:	58 9a       	sbi	0x0b, 0	; 11
}
     a3c:	08 95       	ret

00000a3e <setTimer>:

void setTimer(void) //This sets up a timer to handle the green button thing
{
	PRR &= ~(1<<PRTIM1);	// ensure power to Timer/Counter1
     a3e:	e4 e6       	ldi	r30, 0x64	; 100
     a40:	f0 e0       	ldi	r31, 0x00	; 0
     a42:	80 81       	ld	r24, Z
     a44:	87 7f       	andi	r24, 0xF7	; 247
     a46:	80 83       	st	Z, r24

	TCCR1A &= ~(1<<COM1A1);  // This prevents OC2A pin from doing anything
     a48:	e0 e8       	ldi	r30, 0x80	; 128
     a4a:	f0 e0       	ldi	r31, 0x00	; 0
     a4c:	80 81       	ld	r24, Z
     a4e:	8f 77       	andi	r24, 0x7F	; 127
     a50:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<COM1A0);  //  to the pins on the chip. Otherwise, we might
     a52:	80 81       	ld	r24, Z
     a54:	8f 7b       	andi	r24, 0xBF	; 191
     a56:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<COM1B1);  //  get signals coming out of some of the pins we might use
     a58:	80 81       	ld	r24, Z
     a5a:	8f 7d       	andi	r24, 0xDF	; 223
     a5c:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<COM1B0);
     a5e:	80 81       	ld	r24, Z
     a60:	8f 7e       	andi	r24, 0xEF	; 239
     a62:	80 83       	st	Z, r24

	TCCR1A &= ~(1<<WGM11);  // These bits set up normal mode on the Waveform Generation
     a64:	80 81       	ld	r24, Z
     a66:	8d 7f       	andi	r24, 0xFD	; 253
     a68:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<WGM10);  // This means that the counter acts like a normal timer,
     a6a:	80 81       	ld	r24, Z
     a6c:	8e 7f       	andi	r24, 0xFE	; 254
     a6e:	80 83       	st	Z, r24
	TCCR1B &= ~(1<<WGM12);  // not some sort of fancy digital-analog converter or anything
     a70:	e1 e8       	ldi	r30, 0x81	; 129
     a72:	f0 e0       	ldi	r31, 0x00	; 0
     a74:	80 81       	ld	r24, Z
     a76:	87 7f       	andi	r24, 0xF7	; 247
     a78:	80 83       	st	Z, r24
	TCCR1B &= ~(1<<WGM13);  // It counts up to 65536 and overflows to zero
     a7a:	80 81       	ld	r24, Z
     a7c:	8f 7e       	andi	r24, 0xEF	; 239
     a7e:	80 83       	st	Z, r24

	TCCR1B |= (1<<CS12);   // These set the clock to CPU (8MHz) / 1024 
     a80:	80 81       	ld	r24, Z
     a82:	84 60       	ori	r24, 0x04	; 4
     a84:	80 83       	st	Z, r24
	TCCR1B &= ~(1<<CS11);  // or roughly 8 kHz (7.8125 kHz)
     a86:	80 81       	ld	r24, Z
     a88:	8d 7f       	andi	r24, 0xFD	; 253
     a8a:	80 83       	st	Z, r24
	TCCR1B |= (1<<CS10);   // When counting from zero to 0xFFFF, it takes about 8 seconds
     a8c:	80 81       	ld	r24, Z
     a8e:	81 60       	ori	r24, 0x01	; 1
     a90:	80 83       	st	Z, r24

	// The counter's value is stored in TCNT1
}
     a92:	08 95       	ret

00000a94 <processChords>:
*/
#include "processStringState.h"

void processChords(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
     a94:	0f 93       	push	r16
     a96:	1f 93       	push	r17
     a98:	cf 93       	push	r28
     a9a:	df 93       	push	r29
     a9c:	8c 01       	movw	r16, r24
     a9e:	fb 01       	movw	r30, r22
     aa0:	ea 01       	movw	r28, r20
     aa2:	20 e0       	ldi	r18, 0x00	; 0
     aa4:	30 e0       	ldi	r19, 0x00	; 0
				data->downOn = 1;
				data->upOn   = 0;
			}
			else
			{
				data->upOn   = 1;
     aa6:	41 e0       	ldi	r20, 0x01	; 1
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
	// First take care of registering strumming
	for (int guitarString = 0; guitarString < 6; guitarString++)
	{
		if (stringState[guitarString] & 1)
     aa8:	db 01       	movw	r26, r22
     aaa:	8d 91       	ld	r24, X+
     aac:	9c 91       	ld	r25, X
     aae:	11 97       	sbiw	r26, 0x01	; 1
     ab0:	80 ff       	sbrs	r24, 0
     ab2:	13 c0       	rjmp	.+38     	; 0xada <processChords+0x46>
		{
			stringState[guitarString] &= ~1; //Set the last bit to zero
     ab4:	8e 7f       	andi	r24, 0xFE	; 254
     ab6:	8d 93       	st	X+, r24
     ab8:	9c 93       	st	X, r25
			if (guitarString < 3)
     aba:	23 30       	cpi	r18, 0x03	; 3
     abc:	31 05       	cpc	r19, r1
     abe:	3c f4       	brge	.+14     	; 0xace <processChords+0x3a>
			{
				data->downOn = 1;
     ac0:	d8 01       	movw	r26, r16
     ac2:	16 96       	adiw	r26, 0x06	; 6
     ac4:	4c 93       	st	X, r20
     ac6:	16 97       	sbiw	r26, 0x06	; 6
				data->upOn   = 0;
     ac8:	15 96       	adiw	r26, 0x05	; 5
     aca:	1c 92       	st	X, r1
     acc:	06 c0       	rjmp	.+12     	; 0xada <processChords+0x46>
			}
			else
			{
				data->upOn   = 1;
     ace:	d8 01       	movw	r26, r16
     ad0:	15 96       	adiw	r26, 0x05	; 5
     ad2:	4c 93       	st	X, r20
     ad4:	15 97       	sbiw	r26, 0x05	; 5
				data->downOn = 0;
     ad6:	16 96       	adiw	r26, 0x06	; 6
     ad8:	1c 92       	st	X, r1

void processChords(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
	// First take care of registering strumming
	for (int guitarString = 0; guitarString < 6; guitarString++)
     ada:	2f 5f       	subi	r18, 0xFF	; 255
     adc:	3f 4f       	sbci	r19, 0xFF	; 255
     ade:	6e 5f       	subi	r22, 0xFE	; 254
     ae0:	7f 4f       	sbci	r23, 0xFF	; 255
     ae2:	26 30       	cpi	r18, 0x06	; 6
     ae4:	31 05       	cpc	r19, r1
     ae6:	01 f7       	brne	.-64     	; 0xaa8 <processChords+0x14>
			}
		}
	}

	// First, save us some trouble and see if we're not pressing anything at all..
	if ((stringState[0] == 0b00000000) &&
     ae8:	40 81       	ld	r20, Z
     aea:	51 81       	ldd	r21, Z+1	; 0x01
     aec:	41 15       	cp	r20, r1
     aee:	51 05       	cpc	r21, r1
     af0:	a9 f4       	brne	.+42     	; 0xb1c <processChords+0x88>
     af2:	82 81       	ldd	r24, Z+2	; 0x02
     af4:	93 81       	ldd	r25, Z+3	; 0x03
     af6:	89 2b       	or	r24, r25
     af8:	89 f4       	brne	.+34     	; 0xb1c <processChords+0x88>
     afa:	84 81       	ldd	r24, Z+4	; 0x04
     afc:	95 81       	ldd	r25, Z+5	; 0x05
     afe:	89 2b       	or	r24, r25
     b00:	69 f4       	brne	.+26     	; 0xb1c <processChords+0x88>
     b02:	86 81       	ldd	r24, Z+6	; 0x06
     b04:	97 81       	ldd	r25, Z+7	; 0x07
     b06:	89 2b       	or	r24, r25
     b08:	49 f4       	brne	.+18     	; 0xb1c <processChords+0x88>
     b0a:	80 85       	ldd	r24, Z+8	; 0x08
     b0c:	91 85       	ldd	r25, Z+9	; 0x09
     b0e:	89 2b       	or	r24, r25
     b10:	29 f4       	brne	.+10     	; 0xb1c <processChords+0x88>
     b12:	82 85       	ldd	r24, Z+10	; 0x0a
     b14:	93 85       	ldd	r25, Z+11	; 0x0b
     b16:	89 2b       	or	r24, r25
     b18:	09 f4       	brne	.+2      	; 0xb1c <processChords+0x88>
     b1a:	31 c2       	rjmp	.+1122   	; 0xf7e <processChords+0x4ea>
		return;

	// Now see if what's being played on the fretboard matches any of the button patterns in
	//  buttonStringPatterns
	// green
	if(stringState[0] == buttonStringPatterns[0][0] &&
     b1c:	88 81       	ld	r24, Y
     b1e:	99 81       	ldd	r25, Y+1	; 0x01
     b20:	48 17       	cp	r20, r24
     b22:	59 07       	cpc	r21, r25
     b24:	39 f5       	brne	.+78     	; 0xb74 <processChords+0xe0>
     b26:	22 81       	ldd	r18, Z+2	; 0x02
     b28:	33 81       	ldd	r19, Z+3	; 0x03
     b2a:	8a 81       	ldd	r24, Y+2	; 0x02
     b2c:	9b 81       	ldd	r25, Y+3	; 0x03
     b2e:	28 17       	cp	r18, r24
     b30:	39 07       	cpc	r19, r25
     b32:	01 f5       	brne	.+64     	; 0xb74 <processChords+0xe0>
     b34:	24 81       	ldd	r18, Z+4	; 0x04
     b36:	35 81       	ldd	r19, Z+5	; 0x05
     b38:	8c 81       	ldd	r24, Y+4	; 0x04
     b3a:	9d 81       	ldd	r25, Y+5	; 0x05
     b3c:	28 17       	cp	r18, r24
     b3e:	39 07       	cpc	r19, r25
     b40:	c9 f4       	brne	.+50     	; 0xb74 <processChords+0xe0>
     b42:	26 81       	ldd	r18, Z+6	; 0x06
     b44:	37 81       	ldd	r19, Z+7	; 0x07
     b46:	8e 81       	ldd	r24, Y+6	; 0x06
     b48:	9f 81       	ldd	r25, Y+7	; 0x07
     b4a:	28 17       	cp	r18, r24
     b4c:	39 07       	cpc	r19, r25
     b4e:	91 f4       	brne	.+36     	; 0xb74 <processChords+0xe0>
     b50:	20 85       	ldd	r18, Z+8	; 0x08
     b52:	31 85       	ldd	r19, Z+9	; 0x09
     b54:	88 85       	ldd	r24, Y+8	; 0x08
     b56:	99 85       	ldd	r25, Y+9	; 0x09
     b58:	28 17       	cp	r18, r24
     b5a:	39 07       	cpc	r19, r25
     b5c:	59 f4       	brne	.+22     	; 0xb74 <processChords+0xe0>
     b5e:	22 85       	ldd	r18, Z+10	; 0x0a
     b60:	33 85       	ldd	r19, Z+11	; 0x0b
     b62:	8a 85       	ldd	r24, Y+10	; 0x0a
     b64:	9b 85       	ldd	r25, Y+11	; 0x0b
     b66:	28 17       	cp	r18, r24
     b68:	39 07       	cpc	r19, r25
     b6a:	21 f4       	brne	.+8      	; 0xb74 <processChords+0xe0>
	   stringState[2] == buttonStringPatterns[0][2] &&
	   stringState[3] == buttonStringPatterns[0][3] &&
	   stringState[4] == buttonStringPatterns[0][4] &&
	   stringState[5] == buttonStringPatterns[0][5]  ) 
		{
			data->greenOn = 1;
     b6c:	81 e0       	ldi	r24, 0x01	; 1
     b6e:	f8 01       	movw	r30, r16
     b70:	80 83       	st	Z, r24
     b72:	05 c2       	rjmp	.+1034   	; 0xf7e <processChords+0x4ea>
  		}
	// red
	else if(stringState[0] == buttonStringPatterns[1][0] &&
     b74:	de 01       	movw	r26, r28
     b76:	1c 96       	adiw	r26, 0x0c	; 12
     b78:	8c 85       	ldd	r24, Y+12	; 0x0c
     b7a:	9d 85       	ldd	r25, Y+13	; 0x0d
     b7c:	48 17       	cp	r20, r24
     b7e:	59 07       	cpc	r21, r25
     b80:	81 f5       	brne	.+96     	; 0xbe2 <processChords+0x14e>
     b82:	22 81       	ldd	r18, Z+2	; 0x02
     b84:	33 81       	ldd	r19, Z+3	; 0x03
     b86:	12 96       	adiw	r26, 0x02	; 2
     b88:	8d 91       	ld	r24, X+
     b8a:	9c 91       	ld	r25, X
     b8c:	13 97       	sbiw	r26, 0x03	; 3
     b8e:	28 17       	cp	r18, r24
     b90:	39 07       	cpc	r19, r25
     b92:	39 f5       	brne	.+78     	; 0xbe2 <processChords+0x14e>
     b94:	24 81       	ldd	r18, Z+4	; 0x04
     b96:	35 81       	ldd	r19, Z+5	; 0x05
     b98:	14 96       	adiw	r26, 0x04	; 4
     b9a:	8d 91       	ld	r24, X+
     b9c:	9c 91       	ld	r25, X
     b9e:	15 97       	sbiw	r26, 0x05	; 5
     ba0:	28 17       	cp	r18, r24
     ba2:	39 07       	cpc	r19, r25
     ba4:	f1 f4       	brne	.+60     	; 0xbe2 <processChords+0x14e>
     ba6:	26 81       	ldd	r18, Z+6	; 0x06
     ba8:	37 81       	ldd	r19, Z+7	; 0x07
     baa:	16 96       	adiw	r26, 0x06	; 6
     bac:	8d 91       	ld	r24, X+
     bae:	9c 91       	ld	r25, X
     bb0:	17 97       	sbiw	r26, 0x07	; 7
     bb2:	28 17       	cp	r18, r24
     bb4:	39 07       	cpc	r19, r25
     bb6:	a9 f4       	brne	.+42     	; 0xbe2 <processChords+0x14e>
     bb8:	20 85       	ldd	r18, Z+8	; 0x08
     bba:	31 85       	ldd	r19, Z+9	; 0x09
     bbc:	18 96       	adiw	r26, 0x08	; 8
     bbe:	8d 91       	ld	r24, X+
     bc0:	9c 91       	ld	r25, X
     bc2:	19 97       	sbiw	r26, 0x09	; 9
     bc4:	28 17       	cp	r18, r24
     bc6:	39 07       	cpc	r19, r25
     bc8:	61 f4       	brne	.+24     	; 0xbe2 <processChords+0x14e>
     bca:	22 85       	ldd	r18, Z+10	; 0x0a
     bcc:	33 85       	ldd	r19, Z+11	; 0x0b
     bce:	1a 96       	adiw	r26, 0x0a	; 10
     bd0:	8d 91       	ld	r24, X+
     bd2:	9c 91       	ld	r25, X
     bd4:	1b 97       	sbiw	r26, 0x0b	; 11
     bd6:	28 17       	cp	r18, r24
     bd8:	39 07       	cpc	r19, r25
     bda:	19 f4       	brne	.+6      	; 0xbe2 <processChords+0x14e>
	   stringState[2] == buttonStringPatterns[1][2] &&
	   stringState[3] == buttonStringPatterns[1][3] &&
	   stringState[4] == buttonStringPatterns[1][4] &&
	   stringState[5] == buttonStringPatterns[1][5]  ) 
		{
			data->redOn = 1;
     bdc:	81 e0       	ldi	r24, 0x01	; 1
     bde:	d8 01       	movw	r26, r16
     be0:	dd c0       	rjmp	.+442    	; 0xd9c <processChords+0x308>
  		}

	// yellow
	else if(stringState[0] == buttonStringPatterns[2][0] &&
     be2:	de 01       	movw	r26, r28
     be4:	58 96       	adiw	r26, 0x18	; 24
     be6:	88 8d       	ldd	r24, Y+24	; 0x18
     be8:	99 8d       	ldd	r25, Y+25	; 0x19
     bea:	48 17       	cp	r20, r24
     bec:	59 07       	cpc	r21, r25
     bee:	81 f5       	brne	.+96     	; 0xc50 <processChords+0x1bc>
     bf0:	22 81       	ldd	r18, Z+2	; 0x02
     bf2:	33 81       	ldd	r19, Z+3	; 0x03
     bf4:	12 96       	adiw	r26, 0x02	; 2
     bf6:	8d 91       	ld	r24, X+
     bf8:	9c 91       	ld	r25, X
     bfa:	13 97       	sbiw	r26, 0x03	; 3
     bfc:	28 17       	cp	r18, r24
     bfe:	39 07       	cpc	r19, r25
     c00:	39 f5       	brne	.+78     	; 0xc50 <processChords+0x1bc>
     c02:	24 81       	ldd	r18, Z+4	; 0x04
     c04:	35 81       	ldd	r19, Z+5	; 0x05
     c06:	14 96       	adiw	r26, 0x04	; 4
     c08:	8d 91       	ld	r24, X+
     c0a:	9c 91       	ld	r25, X
     c0c:	15 97       	sbiw	r26, 0x05	; 5
     c0e:	28 17       	cp	r18, r24
     c10:	39 07       	cpc	r19, r25
     c12:	f1 f4       	brne	.+60     	; 0xc50 <processChords+0x1bc>
     c14:	26 81       	ldd	r18, Z+6	; 0x06
     c16:	37 81       	ldd	r19, Z+7	; 0x07
     c18:	16 96       	adiw	r26, 0x06	; 6
     c1a:	8d 91       	ld	r24, X+
     c1c:	9c 91       	ld	r25, X
     c1e:	17 97       	sbiw	r26, 0x07	; 7
     c20:	28 17       	cp	r18, r24
     c22:	39 07       	cpc	r19, r25
     c24:	a9 f4       	brne	.+42     	; 0xc50 <processChords+0x1bc>
     c26:	20 85       	ldd	r18, Z+8	; 0x08
     c28:	31 85       	ldd	r19, Z+9	; 0x09
     c2a:	18 96       	adiw	r26, 0x08	; 8
     c2c:	8d 91       	ld	r24, X+
     c2e:	9c 91       	ld	r25, X
     c30:	19 97       	sbiw	r26, 0x09	; 9
     c32:	28 17       	cp	r18, r24
     c34:	39 07       	cpc	r19, r25
     c36:	61 f4       	brne	.+24     	; 0xc50 <processChords+0x1bc>
     c38:	22 85       	ldd	r18, Z+10	; 0x0a
     c3a:	33 85       	ldd	r19, Z+11	; 0x0b
     c3c:	1a 96       	adiw	r26, 0x0a	; 10
     c3e:	8d 91       	ld	r24, X+
     c40:	9c 91       	ld	r25, X
     c42:	1b 97       	sbiw	r26, 0x0b	; 11
     c44:	28 17       	cp	r18, r24
     c46:	39 07       	cpc	r19, r25
     c48:	19 f4       	brne	.+6      	; 0xc50 <processChords+0x1bc>
	   stringState[2] == buttonStringPatterns[2][2] &&
	   stringState[3] == buttonStringPatterns[2][3] &&
	   stringState[4] == buttonStringPatterns[2][4] &&
	   stringState[5] == buttonStringPatterns[2][5]  ) 
		{
			 data->yellowOn = 1;
     c4a:	81 e0       	ldi	r24, 0x01	; 1
     c4c:	f8 01       	movw	r30, r16
     c4e:	58 c1       	rjmp	.+688    	; 0xf00 <processChords+0x46c>
  		}
	// blue
	else if(stringState[0] == buttonStringPatterns[3][0] &&
     c50:	de 01       	movw	r26, r28
     c52:	94 96       	adiw	r26, 0x24	; 36
     c54:	8c a1       	ldd	r24, Y+36	; 0x24
     c56:	9d a1       	ldd	r25, Y+37	; 0x25
     c58:	48 17       	cp	r20, r24
     c5a:	59 07       	cpc	r21, r25
     c5c:	81 f5       	brne	.+96     	; 0xcbe <processChords+0x22a>
     c5e:	22 81       	ldd	r18, Z+2	; 0x02
     c60:	33 81       	ldd	r19, Z+3	; 0x03
     c62:	12 96       	adiw	r26, 0x02	; 2
     c64:	8d 91       	ld	r24, X+
     c66:	9c 91       	ld	r25, X
     c68:	13 97       	sbiw	r26, 0x03	; 3
     c6a:	28 17       	cp	r18, r24
     c6c:	39 07       	cpc	r19, r25
     c6e:	39 f5       	brne	.+78     	; 0xcbe <processChords+0x22a>
     c70:	24 81       	ldd	r18, Z+4	; 0x04
     c72:	35 81       	ldd	r19, Z+5	; 0x05
     c74:	14 96       	adiw	r26, 0x04	; 4
     c76:	8d 91       	ld	r24, X+
     c78:	9c 91       	ld	r25, X
     c7a:	15 97       	sbiw	r26, 0x05	; 5
     c7c:	28 17       	cp	r18, r24
     c7e:	39 07       	cpc	r19, r25
     c80:	f1 f4       	brne	.+60     	; 0xcbe <processChords+0x22a>
     c82:	26 81       	ldd	r18, Z+6	; 0x06
     c84:	37 81       	ldd	r19, Z+7	; 0x07
     c86:	16 96       	adiw	r26, 0x06	; 6
     c88:	8d 91       	ld	r24, X+
     c8a:	9c 91       	ld	r25, X
     c8c:	17 97       	sbiw	r26, 0x07	; 7
     c8e:	28 17       	cp	r18, r24
     c90:	39 07       	cpc	r19, r25
     c92:	a9 f4       	brne	.+42     	; 0xcbe <processChords+0x22a>
     c94:	20 85       	ldd	r18, Z+8	; 0x08
     c96:	31 85       	ldd	r19, Z+9	; 0x09
     c98:	18 96       	adiw	r26, 0x08	; 8
     c9a:	8d 91       	ld	r24, X+
     c9c:	9c 91       	ld	r25, X
     c9e:	19 97       	sbiw	r26, 0x09	; 9
     ca0:	28 17       	cp	r18, r24
     ca2:	39 07       	cpc	r19, r25
     ca4:	61 f4       	brne	.+24     	; 0xcbe <processChords+0x22a>
     ca6:	22 85       	ldd	r18, Z+10	; 0x0a
     ca8:	33 85       	ldd	r19, Z+11	; 0x0b
     caa:	1a 96       	adiw	r26, 0x0a	; 10
     cac:	8d 91       	ld	r24, X+
     cae:	9c 91       	ld	r25, X
     cb0:	1b 97       	sbiw	r26, 0x0b	; 11
     cb2:	28 17       	cp	r18, r24
     cb4:	39 07       	cpc	r19, r25
     cb6:	19 f4       	brne	.+6      	; 0xcbe <processChords+0x22a>
	   stringState[2] == buttonStringPatterns[3][2] &&
	   stringState[3] == buttonStringPatterns[3][3] &&
	   stringState[4] == buttonStringPatterns[3][4] &&
	   stringState[5] == buttonStringPatterns[3][5]  ) 
		{
			 data->blueOn = 1;
     cb8:	81 e0       	ldi	r24, 0x01	; 1
     cba:	d8 01       	movw	r26, r16
     cbc:	5e c1       	rjmp	.+700    	; 0xf7a <processChords+0x4e6>
  		}
	// orange
	else if(stringState[0] == buttonStringPatterns[4][0] &&
     cbe:	de 01       	movw	r26, r28
     cc0:	d0 96       	adiw	r26, 0x30	; 48
     cc2:	88 a9       	ldd	r24, Y+48	; 0x30
     cc4:	99 a9       	ldd	r25, Y+49	; 0x31
     cc6:	48 17       	cp	r20, r24
     cc8:	59 07       	cpc	r21, r25
     cca:	89 f5       	brne	.+98     	; 0xd2e <processChords+0x29a>
     ccc:	22 81       	ldd	r18, Z+2	; 0x02
     cce:	33 81       	ldd	r19, Z+3	; 0x03
     cd0:	12 96       	adiw	r26, 0x02	; 2
     cd2:	8d 91       	ld	r24, X+
     cd4:	9c 91       	ld	r25, X
     cd6:	13 97       	sbiw	r26, 0x03	; 3
     cd8:	28 17       	cp	r18, r24
     cda:	39 07       	cpc	r19, r25
     cdc:	41 f5       	brne	.+80     	; 0xd2e <processChords+0x29a>
     cde:	24 81       	ldd	r18, Z+4	; 0x04
     ce0:	35 81       	ldd	r19, Z+5	; 0x05
     ce2:	14 96       	adiw	r26, 0x04	; 4
     ce4:	8d 91       	ld	r24, X+
     ce6:	9c 91       	ld	r25, X
     ce8:	15 97       	sbiw	r26, 0x05	; 5
     cea:	28 17       	cp	r18, r24
     cec:	39 07       	cpc	r19, r25
     cee:	f9 f4       	brne	.+62     	; 0xd2e <processChords+0x29a>
     cf0:	26 81       	ldd	r18, Z+6	; 0x06
     cf2:	37 81       	ldd	r19, Z+7	; 0x07
     cf4:	16 96       	adiw	r26, 0x06	; 6
     cf6:	8d 91       	ld	r24, X+
     cf8:	9c 91       	ld	r25, X
     cfa:	17 97       	sbiw	r26, 0x07	; 7
     cfc:	28 17       	cp	r18, r24
     cfe:	39 07       	cpc	r19, r25
     d00:	b1 f4       	brne	.+44     	; 0xd2e <processChords+0x29a>
     d02:	20 85       	ldd	r18, Z+8	; 0x08
     d04:	31 85       	ldd	r19, Z+9	; 0x09
     d06:	18 96       	adiw	r26, 0x08	; 8
     d08:	8d 91       	ld	r24, X+
     d0a:	9c 91       	ld	r25, X
     d0c:	19 97       	sbiw	r26, 0x09	; 9
     d0e:	28 17       	cp	r18, r24
     d10:	39 07       	cpc	r19, r25
     d12:	69 f4       	brne	.+26     	; 0xd2e <processChords+0x29a>
     d14:	22 85       	ldd	r18, Z+10	; 0x0a
     d16:	33 85       	ldd	r19, Z+11	; 0x0b
     d18:	1a 96       	adiw	r26, 0x0a	; 10
     d1a:	8d 91       	ld	r24, X+
     d1c:	9c 91       	ld	r25, X
     d1e:	1b 97       	sbiw	r26, 0x0b	; 11
     d20:	28 17       	cp	r18, r24
     d22:	39 07       	cpc	r19, r25
     d24:	21 f4       	brne	.+8      	; 0xd2e <processChords+0x29a>
	   stringState[2] == buttonStringPatterns[4][2] &&
	   stringState[3] == buttonStringPatterns[4][3] &&
	   stringState[4] == buttonStringPatterns[4][4] &&
	   stringState[5] == buttonStringPatterns[4][5]  ) 
		{
			 data->orangeOn = 1;
     d26:	81 e0       	ldi	r24, 0x01	; 1
     d28:	f8 01       	movw	r30, r16
     d2a:	84 83       	std	Z+4, r24	; 0x04
     d2c:	28 c1       	rjmp	.+592    	; 0xf7e <processChords+0x4ea>
  		}
	//Green and Red
	else if(stringState[0] == buttonStringPatterns[5][0] &&
     d2e:	de 01       	movw	r26, r28
     d30:	dc 96       	adiw	r26, 0x3c	; 60
     d32:	8c ad       	ldd	r24, Y+60	; 0x3c
     d34:	9d ad       	ldd	r25, Y+61	; 0x3d
     d36:	48 17       	cp	r20, r24
     d38:	59 07       	cpc	r21, r25
     d3a:	99 f5       	brne	.+102    	; 0xda2 <processChords+0x30e>
     d3c:	22 81       	ldd	r18, Z+2	; 0x02
     d3e:	33 81       	ldd	r19, Z+3	; 0x03
     d40:	12 96       	adiw	r26, 0x02	; 2
     d42:	8d 91       	ld	r24, X+
     d44:	9c 91       	ld	r25, X
     d46:	13 97       	sbiw	r26, 0x03	; 3
     d48:	28 17       	cp	r18, r24
     d4a:	39 07       	cpc	r19, r25
     d4c:	51 f5       	brne	.+84     	; 0xda2 <processChords+0x30e>
     d4e:	24 81       	ldd	r18, Z+4	; 0x04
     d50:	35 81       	ldd	r19, Z+5	; 0x05
     d52:	14 96       	adiw	r26, 0x04	; 4
     d54:	8d 91       	ld	r24, X+
     d56:	9c 91       	ld	r25, X
     d58:	15 97       	sbiw	r26, 0x05	; 5
     d5a:	28 17       	cp	r18, r24
     d5c:	39 07       	cpc	r19, r25
     d5e:	09 f5       	brne	.+66     	; 0xda2 <processChords+0x30e>
     d60:	26 81       	ldd	r18, Z+6	; 0x06
     d62:	37 81       	ldd	r19, Z+7	; 0x07
     d64:	16 96       	adiw	r26, 0x06	; 6
     d66:	8d 91       	ld	r24, X+
     d68:	9c 91       	ld	r25, X
     d6a:	17 97       	sbiw	r26, 0x07	; 7
     d6c:	28 17       	cp	r18, r24
     d6e:	39 07       	cpc	r19, r25
     d70:	c1 f4       	brne	.+48     	; 0xda2 <processChords+0x30e>
     d72:	20 85       	ldd	r18, Z+8	; 0x08
     d74:	31 85       	ldd	r19, Z+9	; 0x09
     d76:	18 96       	adiw	r26, 0x08	; 8
     d78:	8d 91       	ld	r24, X+
     d7a:	9c 91       	ld	r25, X
     d7c:	19 97       	sbiw	r26, 0x09	; 9
     d7e:	28 17       	cp	r18, r24
     d80:	39 07       	cpc	r19, r25
     d82:	79 f4       	brne	.+30     	; 0xda2 <processChords+0x30e>
     d84:	22 85       	ldd	r18, Z+10	; 0x0a
     d86:	33 85       	ldd	r19, Z+11	; 0x0b
     d88:	1a 96       	adiw	r26, 0x0a	; 10
     d8a:	8d 91       	ld	r24, X+
     d8c:	9c 91       	ld	r25, X
     d8e:	1b 97       	sbiw	r26, 0x0b	; 11
     d90:	28 17       	cp	r18, r24
     d92:	39 07       	cpc	r19, r25
     d94:	31 f4       	brne	.+12     	; 0xda2 <processChords+0x30e>
	   stringState[2] == buttonStringPatterns[5][2] &&
	   stringState[3] == buttonStringPatterns[5][3] &&
	   stringState[4] == buttonStringPatterns[5][4] &&
	   stringState[5] == buttonStringPatterns[5][5]  ) 
		{
			data->greenOn = 1;
     d96:	81 e0       	ldi	r24, 0x01	; 1
     d98:	d8 01       	movw	r26, r16
     d9a:	8c 93       	st	X, r24
			data->redOn = 1;
     d9c:	11 96       	adiw	r26, 0x01	; 1
     d9e:	8c 93       	st	X, r24
     da0:	ee c0       	rjmp	.+476    	; 0xf7e <processChords+0x4ea>
  		}
	//Red and Yellow
	else if(stringState[0] == buttonStringPatterns[6][0] &&
     da2:	de 01       	movw	r26, r28
     da4:	a8 5b       	subi	r26, 0xB8	; 184
     da6:	bf 4f       	sbci	r27, 0xFF	; 255
     da8:	8d 91       	ld	r24, X+
     daa:	9c 91       	ld	r25, X
     dac:	11 97       	sbiw	r26, 0x01	; 1
     dae:	48 17       	cp	r20, r24
     db0:	59 07       	cpc	r21, r25
     db2:	89 f5       	brne	.+98     	; 0xe16 <processChords+0x382>
     db4:	22 81       	ldd	r18, Z+2	; 0x02
     db6:	33 81       	ldd	r19, Z+3	; 0x03
     db8:	12 96       	adiw	r26, 0x02	; 2
     dba:	8d 91       	ld	r24, X+
     dbc:	9c 91       	ld	r25, X
     dbe:	13 97       	sbiw	r26, 0x03	; 3
     dc0:	28 17       	cp	r18, r24
     dc2:	39 07       	cpc	r19, r25
     dc4:	41 f5       	brne	.+80     	; 0xe16 <processChords+0x382>
     dc6:	24 81       	ldd	r18, Z+4	; 0x04
     dc8:	35 81       	ldd	r19, Z+5	; 0x05
     dca:	14 96       	adiw	r26, 0x04	; 4
     dcc:	8d 91       	ld	r24, X+
     dce:	9c 91       	ld	r25, X
     dd0:	15 97       	sbiw	r26, 0x05	; 5
     dd2:	28 17       	cp	r18, r24
     dd4:	39 07       	cpc	r19, r25
     dd6:	f9 f4       	brne	.+62     	; 0xe16 <processChords+0x382>
     dd8:	26 81       	ldd	r18, Z+6	; 0x06
     dda:	37 81       	ldd	r19, Z+7	; 0x07
     ddc:	16 96       	adiw	r26, 0x06	; 6
     dde:	8d 91       	ld	r24, X+
     de0:	9c 91       	ld	r25, X
     de2:	17 97       	sbiw	r26, 0x07	; 7
     de4:	28 17       	cp	r18, r24
     de6:	39 07       	cpc	r19, r25
     de8:	b1 f4       	brne	.+44     	; 0xe16 <processChords+0x382>
     dea:	20 85       	ldd	r18, Z+8	; 0x08
     dec:	31 85       	ldd	r19, Z+9	; 0x09
     dee:	18 96       	adiw	r26, 0x08	; 8
     df0:	8d 91       	ld	r24, X+
     df2:	9c 91       	ld	r25, X
     df4:	19 97       	sbiw	r26, 0x09	; 9
     df6:	28 17       	cp	r18, r24
     df8:	39 07       	cpc	r19, r25
     dfa:	69 f4       	brne	.+26     	; 0xe16 <processChords+0x382>
     dfc:	22 85       	ldd	r18, Z+10	; 0x0a
     dfe:	33 85       	ldd	r19, Z+11	; 0x0b
     e00:	1a 96       	adiw	r26, 0x0a	; 10
     e02:	8d 91       	ld	r24, X+
     e04:	9c 91       	ld	r25, X
     e06:	1b 97       	sbiw	r26, 0x0b	; 11
     e08:	28 17       	cp	r18, r24
     e0a:	39 07       	cpc	r19, r25
     e0c:	21 f4       	brne	.+8      	; 0xe16 <processChords+0x382>
	   stringState[2] == buttonStringPatterns[6][2] &&
	   stringState[3] == buttonStringPatterns[6][3] &&
	   stringState[4] == buttonStringPatterns[6][4] &&
	   stringState[5] == buttonStringPatterns[6][5]  ) 
		{
			data->redOn = 1;
     e0e:	81 e0       	ldi	r24, 0x01	; 1
     e10:	f8 01       	movw	r30, r16
     e12:	81 83       	std	Z+1, r24	; 0x01
     e14:	75 c0       	rjmp	.+234    	; 0xf00 <processChords+0x46c>
			data->yellowOn = 1;
  		}
	// Yellow and Blue
	else if(stringState[0] == buttonStringPatterns[7][0] &&
     e16:	de 01       	movw	r26, r28
     e18:	ac 5a       	subi	r26, 0xAC	; 172
     e1a:	bf 4f       	sbci	r27, 0xFF	; 255
     e1c:	8d 91       	ld	r24, X+
     e1e:	9c 91       	ld	r25, X
     e20:	11 97       	sbiw	r26, 0x01	; 1
     e22:	48 17       	cp	r20, r24
     e24:	59 07       	cpc	r21, r25
     e26:	99 f5       	brne	.+102    	; 0xe8e <processChords+0x3fa>
     e28:	22 81       	ldd	r18, Z+2	; 0x02
     e2a:	33 81       	ldd	r19, Z+3	; 0x03
     e2c:	12 96       	adiw	r26, 0x02	; 2
     e2e:	8d 91       	ld	r24, X+
     e30:	9c 91       	ld	r25, X
     e32:	13 97       	sbiw	r26, 0x03	; 3
     e34:	28 17       	cp	r18, r24
     e36:	39 07       	cpc	r19, r25
     e38:	51 f5       	brne	.+84     	; 0xe8e <processChords+0x3fa>
     e3a:	24 81       	ldd	r18, Z+4	; 0x04
     e3c:	35 81       	ldd	r19, Z+5	; 0x05
     e3e:	14 96       	adiw	r26, 0x04	; 4
     e40:	8d 91       	ld	r24, X+
     e42:	9c 91       	ld	r25, X
     e44:	15 97       	sbiw	r26, 0x05	; 5
     e46:	28 17       	cp	r18, r24
     e48:	39 07       	cpc	r19, r25
     e4a:	09 f5       	brne	.+66     	; 0xe8e <processChords+0x3fa>
     e4c:	26 81       	ldd	r18, Z+6	; 0x06
     e4e:	37 81       	ldd	r19, Z+7	; 0x07
     e50:	16 96       	adiw	r26, 0x06	; 6
     e52:	8d 91       	ld	r24, X+
     e54:	9c 91       	ld	r25, X
     e56:	17 97       	sbiw	r26, 0x07	; 7
     e58:	28 17       	cp	r18, r24
     e5a:	39 07       	cpc	r19, r25
     e5c:	c1 f4       	brne	.+48     	; 0xe8e <processChords+0x3fa>
     e5e:	20 85       	ldd	r18, Z+8	; 0x08
     e60:	31 85       	ldd	r19, Z+9	; 0x09
     e62:	18 96       	adiw	r26, 0x08	; 8
     e64:	8d 91       	ld	r24, X+
     e66:	9c 91       	ld	r25, X
     e68:	19 97       	sbiw	r26, 0x09	; 9
     e6a:	28 17       	cp	r18, r24
     e6c:	39 07       	cpc	r19, r25
     e6e:	79 f4       	brne	.+30     	; 0xe8e <processChords+0x3fa>
     e70:	22 85       	ldd	r18, Z+10	; 0x0a
     e72:	33 85       	ldd	r19, Z+11	; 0x0b
     e74:	1a 96       	adiw	r26, 0x0a	; 10
     e76:	8d 91       	ld	r24, X+
     e78:	9c 91       	ld	r25, X
     e7a:	1b 97       	sbiw	r26, 0x0b	; 11
     e7c:	28 17       	cp	r18, r24
     e7e:	39 07       	cpc	r19, r25
     e80:	31 f4       	brne	.+12     	; 0xe8e <processChords+0x3fa>
	   stringState[2] == buttonStringPatterns[7][2] &&
	   stringState[3] == buttonStringPatterns[7][3] &&
	   stringState[4] == buttonStringPatterns[7][4] &&
	   stringState[5] == buttonStringPatterns[7][5]  ) 
		{
			 data->yellowOn = 1;
     e82:	81 e0       	ldi	r24, 0x01	; 1
     e84:	d8 01       	movw	r26, r16
     e86:	12 96       	adiw	r26, 0x02	; 2
     e88:	8c 93       	st	X, r24
     e8a:	12 97       	sbiw	r26, 0x02	; 2
     e8c:	76 c0       	rjmp	.+236    	; 0xf7a <processChords+0x4e6>
			 data->blueOn = 1;
  		}
	// Green and Yellow
	else if(stringState[0] == buttonStringPatterns[8][0] &&
     e8e:	de 01       	movw	r26, r28
     e90:	a0 5a       	subi	r26, 0xA0	; 160
     e92:	bf 4f       	sbci	r27, 0xFF	; 255
     e94:	8d 91       	ld	r24, X+
     e96:	9c 91       	ld	r25, X
     e98:	11 97       	sbiw	r26, 0x01	; 1
     e9a:	48 17       	cp	r20, r24
     e9c:	59 07       	cpc	r21, r25
     e9e:	91 f5       	brne	.+100    	; 0xf04 <processChords+0x470>
     ea0:	22 81       	ldd	r18, Z+2	; 0x02
     ea2:	33 81       	ldd	r19, Z+3	; 0x03
     ea4:	12 96       	adiw	r26, 0x02	; 2
     ea6:	8d 91       	ld	r24, X+
     ea8:	9c 91       	ld	r25, X
     eaa:	13 97       	sbiw	r26, 0x03	; 3
     eac:	28 17       	cp	r18, r24
     eae:	39 07       	cpc	r19, r25
     eb0:	49 f5       	brne	.+82     	; 0xf04 <processChords+0x470>
     eb2:	24 81       	ldd	r18, Z+4	; 0x04
     eb4:	35 81       	ldd	r19, Z+5	; 0x05
     eb6:	14 96       	adiw	r26, 0x04	; 4
     eb8:	8d 91       	ld	r24, X+
     eba:	9c 91       	ld	r25, X
     ebc:	15 97       	sbiw	r26, 0x05	; 5
     ebe:	28 17       	cp	r18, r24
     ec0:	39 07       	cpc	r19, r25
     ec2:	01 f5       	brne	.+64     	; 0xf04 <processChords+0x470>
     ec4:	26 81       	ldd	r18, Z+6	; 0x06
     ec6:	37 81       	ldd	r19, Z+7	; 0x07
     ec8:	16 96       	adiw	r26, 0x06	; 6
     eca:	8d 91       	ld	r24, X+
     ecc:	9c 91       	ld	r25, X
     ece:	17 97       	sbiw	r26, 0x07	; 7
     ed0:	28 17       	cp	r18, r24
     ed2:	39 07       	cpc	r19, r25
     ed4:	b9 f4       	brne	.+46     	; 0xf04 <processChords+0x470>
     ed6:	20 85       	ldd	r18, Z+8	; 0x08
     ed8:	31 85       	ldd	r19, Z+9	; 0x09
     eda:	18 96       	adiw	r26, 0x08	; 8
     edc:	8d 91       	ld	r24, X+
     ede:	9c 91       	ld	r25, X
     ee0:	19 97       	sbiw	r26, 0x09	; 9
     ee2:	28 17       	cp	r18, r24
     ee4:	39 07       	cpc	r19, r25
     ee6:	71 f4       	brne	.+28     	; 0xf04 <processChords+0x470>
     ee8:	22 85       	ldd	r18, Z+10	; 0x0a
     eea:	33 85       	ldd	r19, Z+11	; 0x0b
     eec:	1a 96       	adiw	r26, 0x0a	; 10
     eee:	8d 91       	ld	r24, X+
     ef0:	9c 91       	ld	r25, X
     ef2:	1b 97       	sbiw	r26, 0x0b	; 11
     ef4:	28 17       	cp	r18, r24
     ef6:	39 07       	cpc	r19, r25
     ef8:	29 f4       	brne	.+10     	; 0xf04 <processChords+0x470>
	   stringState[2] == buttonStringPatterns[8][2] &&
	   stringState[3] == buttonStringPatterns[8][3] &&
	   stringState[4] == buttonStringPatterns[8][4] &&
	   stringState[5] == buttonStringPatterns[8][5]  ) 
		{
			 data->greenOn = 1;
     efa:	81 e0       	ldi	r24, 0x01	; 1
     efc:	f8 01       	movw	r30, r16
     efe:	80 83       	st	Z, r24
			 data->yellowOn = 1;
     f00:	82 83       	std	Z+2, r24	; 0x02
     f02:	3d c0       	rjmp	.+122    	; 0xf7e <processChords+0x4ea>
  		}
	// Red and Blue
	else if(stringState[0] == buttonStringPatterns[9][0] &&
     f04:	de 01       	movw	r26, r28
     f06:	a4 59       	subi	r26, 0x94	; 148
     f08:	bf 4f       	sbci	r27, 0xFF	; 255
     f0a:	8d 91       	ld	r24, X+
     f0c:	9c 91       	ld	r25, X
     f0e:	11 97       	sbiw	r26, 0x01	; 1
     f10:	48 17       	cp	r20, r24
     f12:	59 07       	cpc	r21, r25
     f14:	a1 f5       	brne	.+104    	; 0xf7e <processChords+0x4ea>
     f16:	22 81       	ldd	r18, Z+2	; 0x02
     f18:	33 81       	ldd	r19, Z+3	; 0x03
     f1a:	12 96       	adiw	r26, 0x02	; 2
     f1c:	8d 91       	ld	r24, X+
     f1e:	9c 91       	ld	r25, X
     f20:	13 97       	sbiw	r26, 0x03	; 3
     f22:	28 17       	cp	r18, r24
     f24:	39 07       	cpc	r19, r25
     f26:	59 f5       	brne	.+86     	; 0xf7e <processChords+0x4ea>
     f28:	24 81       	ldd	r18, Z+4	; 0x04
     f2a:	35 81       	ldd	r19, Z+5	; 0x05
     f2c:	14 96       	adiw	r26, 0x04	; 4
     f2e:	8d 91       	ld	r24, X+
     f30:	9c 91       	ld	r25, X
     f32:	15 97       	sbiw	r26, 0x05	; 5
     f34:	28 17       	cp	r18, r24
     f36:	39 07       	cpc	r19, r25
     f38:	11 f5       	brne	.+68     	; 0xf7e <processChords+0x4ea>
     f3a:	26 81       	ldd	r18, Z+6	; 0x06
     f3c:	37 81       	ldd	r19, Z+7	; 0x07
     f3e:	16 96       	adiw	r26, 0x06	; 6
     f40:	8d 91       	ld	r24, X+
     f42:	9c 91       	ld	r25, X
     f44:	17 97       	sbiw	r26, 0x07	; 7
     f46:	28 17       	cp	r18, r24
     f48:	39 07       	cpc	r19, r25
     f4a:	c9 f4       	brne	.+50     	; 0xf7e <processChords+0x4ea>
     f4c:	20 85       	ldd	r18, Z+8	; 0x08
     f4e:	31 85       	ldd	r19, Z+9	; 0x09
     f50:	18 96       	adiw	r26, 0x08	; 8
     f52:	8d 91       	ld	r24, X+
     f54:	9c 91       	ld	r25, X
     f56:	19 97       	sbiw	r26, 0x09	; 9
     f58:	28 17       	cp	r18, r24
     f5a:	39 07       	cpc	r19, r25
     f5c:	81 f4       	brne	.+32     	; 0xf7e <processChords+0x4ea>
     f5e:	22 85       	ldd	r18, Z+10	; 0x0a
     f60:	33 85       	ldd	r19, Z+11	; 0x0b
     f62:	1a 96       	adiw	r26, 0x0a	; 10
     f64:	8d 91       	ld	r24, X+
     f66:	9c 91       	ld	r25, X
     f68:	1b 97       	sbiw	r26, 0x0b	; 11
     f6a:	28 17       	cp	r18, r24
     f6c:	39 07       	cpc	r19, r25
     f6e:	39 f4       	brne	.+14     	; 0xf7e <processChords+0x4ea>
	   stringState[2] == buttonStringPatterns[9][2] &&
	   stringState[3] == buttonStringPatterns[9][3] &&
	   stringState[4] == buttonStringPatterns[9][4] &&
	   stringState[5] == buttonStringPatterns[9][5]  ) 
		{
			 data->redOn = 1;
     f70:	81 e0       	ldi	r24, 0x01	; 1
     f72:	d8 01       	movw	r26, r16
     f74:	11 96       	adiw	r26, 0x01	; 1
     f76:	8c 93       	st	X, r24
     f78:	11 97       	sbiw	r26, 0x01	; 1
			 data->blueOn = 1;
     f7a:	13 96       	adiw	r26, 0x03	; 3
     f7c:	8c 93       	st	X, r24
  		}

	return;
}
     f7e:	df 91       	pop	r29
     f80:	cf 91       	pop	r28
     f82:	1f 91       	pop	r17
     f84:	0f 91       	pop	r16
     f86:	08 95       	ret

00000f88 <processNotes>:

void processNotes(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
     f88:	ef 92       	push	r14
     f8a:	ff 92       	push	r15
     f8c:	0f 93       	push	r16
     f8e:	1f 93       	push	r17
     f90:	cf 93       	push	r28
     f92:	df 93       	push	r29
     f94:	dc 01       	movw	r26, r24
     f96:	fb 01       	movw	r30, r22
	/* If we're playing with notes on a scale, then we have to figure out if the proper note is being
	   played, and also if we strummed the correct string.
	 */
	// First thing, we need to reset the strumming code, since we need to check and see if we 
	//  strummed on the correct string or not
	data->upOn = 0;
     f98:	15 96       	adiw	r26, 0x05	; 5
     f9a:	1c 92       	st	X, r1
     f9c:	15 97       	sbiw	r26, 0x05	; 5
	data->downOn = 0;
     f9e:	16 96       	adiw	r26, 0x06	; 6
     fa0:	1c 92       	st	X, r1
     fa2:	16 97       	sbiw	r26, 0x06	; 6
						// are numbered 0-5
	char buttonPressed = 0;
	char strumPressed  = 0;

	//We also hardcode in a down strum on the empty 6th string, for navigation
	if (stringState[0] & 1)
     fa4:	80 81       	ld	r24, Z
     fa6:	80 ff       	sbrs	r24, 0
     fa8:	04 c0       	rjmp	.+8      	; 0xfb2 <processNotes+0x2a>
	{
		data->downOn = 1;
     faa:	81 e0       	ldi	r24, 0x01	; 1
     fac:	16 96       	adiw	r26, 0x06	; 6
     fae:	8c 93       	st	X, r24
     fb0:	16 97       	sbiw	r26, 0x06	; 6
     fb2:	7a 01       	movw	r14, r20
     fb4:	ba 01       	movw	r22, r20
     fb6:	6c 5d       	subi	r22, 0xDC	; 220
     fb8:	7f 4f       	sbci	r23, 0xFF	; 255
     fba:	4f ef       	ldi	r20, 0xFF	; 255
     fbc:	00 e0       	ldi	r16, 0x00	; 0
     fbe:	50 e0       	ldi	r21, 0x00	; 0
					buttonPressed = 1;
					}				
				if (stringState[i] == buttonStringPatterns[4][i] && 
										buttonStringPatterns[4][i] != 0)
				{
					data->orangeOn =  1;
     fc0:	11 e0       	ldi	r17, 0x01	; 1
		data->downOn = 1;
	}

	for (int i = 0; i < 6; i++)
	{
		if (stringState[i] != 0) // Only look at strings that are being touched or strummed
     fc2:	80 81       	ld	r24, Z
     fc4:	91 81       	ldd	r25, Z+1	; 0x01
     fc6:	00 97       	sbiw	r24, 0x00	; 0
     fc8:	09 f4       	brne	.+2      	; 0xfcc <processNotes+0x44>
     fca:	82 c0       	rjmp	.+260    	; 0x10d0 <processNotes+0x148>
		{
			// Check for open strings being strummed first
			if (stringState[i] == 1) // This means we're strumming an open string
     fcc:	81 30       	cpi	r24, 0x01	; 1
     fce:	91 05       	cpc	r25, r1
     fd0:	c1 f5       	brne	.+112    	; 0x1042 <processNotes+0xba>
			{
				if (stringState[i] == buttonStringPatterns[0][i])
     fd2:	e7 01       	movw	r28, r14
     fd4:	88 81       	ld	r24, Y
     fd6:	99 81       	ldd	r25, Y+1	; 0x01
     fd8:	01 97       	sbiw	r24, 0x01	; 1
     fda:	11 f4       	brne	.+4      	; 0xfe0 <processNotes+0x58>
				{
					strumOn = i;
					data->greenOn =  1;	
     fdc:	1c 93       	st	X, r17
     fde:	45 2f       	mov	r20, r21
				}
				if (stringState[i] == buttonStringPatterns[1][i])
     fe0:	20 81       	ld	r18, Z
     fe2:	31 81       	ldd	r19, Z+1	; 0x01
     fe4:	e7 01       	movw	r28, r14
     fe6:	8c 85       	ldd	r24, Y+12	; 0x0c
     fe8:	9d 85       	ldd	r25, Y+13	; 0x0d
     fea:	28 17       	cp	r18, r24
     fec:	39 07       	cpc	r19, r25
     fee:	21 f4       	brne	.+8      	; 0xff8 <processNotes+0x70>
				{
					strumOn = i;
					data->redOn =  1;	
     ff0:	11 96       	adiw	r26, 0x01	; 1
     ff2:	1c 93       	st	X, r17
     ff4:	11 97       	sbiw	r26, 0x01	; 1
     ff6:	45 2f       	mov	r20, r21
				}
				if (stringState[i] == buttonStringPatterns[2][i])
     ff8:	20 81       	ld	r18, Z
     ffa:	31 81       	ldd	r19, Z+1	; 0x01
     ffc:	e7 01       	movw	r28, r14
     ffe:	88 8d       	ldd	r24, Y+24	; 0x18
    1000:	99 8d       	ldd	r25, Y+25	; 0x19
    1002:	28 17       	cp	r18, r24
    1004:	39 07       	cpc	r19, r25
    1006:	21 f4       	brne	.+8      	; 0x1010 <processNotes+0x88>
				{
					strumOn = i;
					data->yellowOn =  1;
    1008:	12 96       	adiw	r26, 0x02	; 2
    100a:	1c 93       	st	X, r17
    100c:	12 97       	sbiw	r26, 0x02	; 2
    100e:	45 2f       	mov	r20, r21
				}				
				if (stringState[i] == buttonStringPatterns[3][i])
    1010:	20 81       	ld	r18, Z
    1012:	31 81       	ldd	r19, Z+1	; 0x01
    1014:	eb 01       	movw	r28, r22
    1016:	88 81       	ld	r24, Y
    1018:	99 81       	ldd	r25, Y+1	; 0x01
    101a:	28 17       	cp	r18, r24
    101c:	39 07       	cpc	r19, r25
    101e:	21 f4       	brne	.+8      	; 0x1028 <processNotes+0xa0>
				{
					strumOn = i;
					data->blueOn =  1;
    1020:	13 96       	adiw	r26, 0x03	; 3
    1022:	1c 93       	st	X, r17
    1024:	13 97       	sbiw	r26, 0x03	; 3
    1026:	45 2f       	mov	r20, r21
				}				
				if (stringState[i] == buttonStringPatterns[4][i])
    1028:	20 81       	ld	r18, Z
    102a:	31 81       	ldd	r19, Z+1	; 0x01
    102c:	eb 01       	movw	r28, r22
    102e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1030:	9d 85       	ldd	r25, Y+13	; 0x0d
    1032:	28 17       	cp	r18, r24
    1034:	39 07       	cpc	r19, r25
    1036:	39 f4       	brne	.+14     	; 0x1046 <processNotes+0xbe>
				{
					strumOn = i;
					data->orangeOn =  1;				
    1038:	14 96       	adiw	r26, 0x04	; 4
    103a:	1c 93       	st	X, r17
    103c:	14 97       	sbiw	r26, 0x04	; 4
    103e:	45 2f       	mov	r20, r21
    1040:	02 c0       	rjmp	.+4      	; 0x1046 <processNotes+0xbe>
			}
			 // Now we have checked for strummed notes, we need to check for pressed notes
			 //  so that we can display them for reference as well as use them when strummed
			else
				// First see if we're strumming or not
				strumPressed = stringState[i] & 1;
    1042:	08 2f       	mov	r16, r24
    1044:	01 70       	andi	r16, 0x01	; 1
				// Now ensure the strum bit is zero
				stringState[i] &= (~1);
    1046:	20 81       	ld	r18, Z
    1048:	31 81       	ldd	r19, Z+1	; 0x01
    104a:	2e 7f       	andi	r18, 0xFE	; 254
    104c:	31 83       	std	Z+1, r19	; 0x01
    104e:	20 83       	st	Z, r18
				// Take care of displaying closed notes
				if (stringState[i] == buttonStringPatterns[0][i]&& 
    1050:	e7 01       	movw	r28, r14
    1052:	88 81       	ld	r24, Y
    1054:	99 81       	ldd	r25, Y+1	; 0x01
    1056:	28 17       	cp	r18, r24
    1058:	39 07       	cpc	r19, r25
    105a:	19 f4       	brne	.+6      	; 0x1062 <processNotes+0xda>
    105c:	23 2b       	or	r18, r19
    105e:	09 f0       	breq	.+2      	; 0x1062 <processNotes+0xda>
										buttonStringPatterns[0][i] != 0)
				{
					data->greenOn =  1;	
    1060:	1c 93       	st	X, r17
					buttonPressed = 1;
				}
				if (stringState[i] == buttonStringPatterns[1][i] && 
    1062:	20 81       	ld	r18, Z
    1064:	31 81       	ldd	r19, Z+1	; 0x01
    1066:	e7 01       	movw	r28, r14
    1068:	8c 85       	ldd	r24, Y+12	; 0x0c
    106a:	9d 85       	ldd	r25, Y+13	; 0x0d
    106c:	28 17       	cp	r18, r24
    106e:	39 07       	cpc	r19, r25
    1070:	29 f4       	brne	.+10     	; 0x107c <processNotes+0xf4>
    1072:	23 2b       	or	r18, r19
    1074:	19 f0       	breq	.+6      	; 0x107c <processNotes+0xf4>
										buttonStringPatterns[1][i] != 0)
				{
					data->redOn =  1;	
    1076:	11 96       	adiw	r26, 0x01	; 1
    1078:	1c 93       	st	X, r17
    107a:	11 97       	sbiw	r26, 0x01	; 1
					buttonPressed = 1;
				}
				if (stringState[i] == buttonStringPatterns[2][i] && 
    107c:	20 81       	ld	r18, Z
    107e:	31 81       	ldd	r19, Z+1	; 0x01
    1080:	e7 01       	movw	r28, r14
    1082:	88 8d       	ldd	r24, Y+24	; 0x18
    1084:	99 8d       	ldd	r25, Y+25	; 0x19
    1086:	28 17       	cp	r18, r24
    1088:	39 07       	cpc	r19, r25
    108a:	29 f4       	brne	.+10     	; 0x1096 <processNotes+0x10e>
    108c:	23 2b       	or	r18, r19
    108e:	19 f0       	breq	.+6      	; 0x1096 <processNotes+0x10e>
										buttonStringPatterns[2][i] != 0)
					{
					data->yellowOn =  1;
    1090:	12 96       	adiw	r26, 0x02	; 2
    1092:	1c 93       	st	X, r17
    1094:	12 97       	sbiw	r26, 0x02	; 2
					buttonPressed = 1;
				}
				if (stringState[i] == buttonStringPatterns[3][i] && 
    1096:	20 81       	ld	r18, Z
    1098:	31 81       	ldd	r19, Z+1	; 0x01
    109a:	eb 01       	movw	r28, r22
    109c:	88 81       	ld	r24, Y
    109e:	99 81       	ldd	r25, Y+1	; 0x01
    10a0:	28 17       	cp	r18, r24
    10a2:	39 07       	cpc	r19, r25
    10a4:	29 f4       	brne	.+10     	; 0x10b0 <processNotes+0x128>
    10a6:	23 2b       	or	r18, r19
    10a8:	19 f0       	breq	.+6      	; 0x10b0 <processNotes+0x128>
										buttonStringPatterns[3][i] != 0)
				{
					data->blueOn =  1;
    10aa:	13 96       	adiw	r26, 0x03	; 3
    10ac:	1c 93       	st	X, r17
    10ae:	13 97       	sbiw	r26, 0x03	; 3
					buttonPressed = 1;
					}				
				if (stringState[i] == buttonStringPatterns[4][i] && 
    10b0:	20 81       	ld	r18, Z
    10b2:	31 81       	ldd	r19, Z+1	; 0x01
    10b4:	eb 01       	movw	r28, r22
    10b6:	8c 85       	ldd	r24, Y+12	; 0x0c
    10b8:	9d 85       	ldd	r25, Y+13	; 0x0d
    10ba:	28 17       	cp	r18, r24
    10bc:	39 07       	cpc	r19, r25
    10be:	29 f4       	brne	.+10     	; 0x10ca <processNotes+0x142>
    10c0:	23 2b       	or	r18, r19
    10c2:	19 f0       	breq	.+6      	; 0x10ca <processNotes+0x142>
										buttonStringPatterns[4][i] != 0)
				{
					data->orangeOn =  1;
    10c4:	14 96       	adiw	r26, 0x04	; 4
    10c6:	1c 93       	st	X, r17
    10c8:	14 97       	sbiw	r26, 0x04	; 4
					buttonPressed = 1;									
				}
					// Now deal with strumming
				if ((buttonPressed = 1) && (strumPressed == 1))
    10ca:	01 30       	cpi	r16, 0x01	; 1
    10cc:	09 f4       	brne	.+2      	; 0x10d0 <processNotes+0x148>
    10ce:	45 2f       	mov	r20, r21
    10d0:	32 96       	adiw	r30, 0x02	; 2
    10d2:	5f 5f       	subi	r21, 0xFF	; 255
    10d4:	82 e0       	ldi	r24, 0x02	; 2
    10d6:	90 e0       	ldi	r25, 0x00	; 0
    10d8:	e8 0e       	add	r14, r24
    10da:	f9 1e       	adc	r15, r25
    10dc:	6e 5f       	subi	r22, 0xFE	; 254
    10de:	7f 4f       	sbci	r23, 0xFF	; 255
	if (stringState[0] & 1)
	{
		data->downOn = 1;
	}

	for (int i = 0; i < 6; i++)
    10e0:	56 30       	cpi	r21, 0x06	; 6
    10e2:	09 f0       	breq	.+2      	; 0x10e6 <processNotes+0x15e>
    10e4:	6e cf       	rjmp	.-292    	; 0xfc2 <processNotes+0x3a>
				}
			}
	}

	//Now set the strum buttons properly, so we can have both up and down if we're in this mode
	if ((strumOn >= 0) && (strumOn < 3))
    10e6:	43 30       	cpi	r20, 0x03	; 3
    10e8:	20 f4       	brcc	.+8      	; 0x10f2 <processNotes+0x16a>
	{
		data->downOn = 1;
    10ea:	81 e0       	ldi	r24, 0x01	; 1
    10ec:	16 96       	adiw	r26, 0x06	; 6
    10ee:	8c 93       	st	X, r24
    10f0:	0b c0       	rjmp	.+22     	; 0x1108 <processNotes+0x180>
	}
	else if ((strumOn >= 3) && (strumOn < 6 ) && (data->downOn != 1))
    10f2:	43 50       	subi	r20, 0x03	; 3
    10f4:	43 30       	cpi	r20, 0x03	; 3
    10f6:	40 f4       	brcc	.+16     	; 0x1108 <processNotes+0x180>
    10f8:	16 96       	adiw	r26, 0x06	; 6
    10fa:	8c 91       	ld	r24, X
    10fc:	16 97       	sbiw	r26, 0x06	; 6
    10fe:	81 30       	cpi	r24, 0x01	; 1
    1100:	19 f0       	breq	.+6      	; 0x1108 <processNotes+0x180>
	{
		data->upOn = 1;
    1102:	81 e0       	ldi	r24, 0x01	; 1
    1104:	15 96       	adiw	r26, 0x05	; 5
    1106:	8c 93       	st	X, r24
	}

	return;
}
    1108:	df 91       	pop	r29
    110a:	cf 91       	pop	r28
    110c:	1f 91       	pop	r17
    110e:	0f 91       	pop	r16
    1110:	ff 90       	pop	r15
    1112:	ef 90       	pop	r14
    1114:	08 95       	ret

00001116 <processFrets>:

void processFrets(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS], 
									int greenTimers[NUMBER_OF_STRINGS], int triedGreen[NUMBER_OF_STRINGS])
{
    1116:	af 92       	push	r10
    1118:	bf 92       	push	r11
    111a:	cf 92       	push	r12
    111c:	df 92       	push	r13
    111e:	ff 92       	push	r15
    1120:	0f 93       	push	r16
    1122:	1f 93       	push	r17
    1124:	cf 93       	push	r28
    1126:	df 93       	push	r29
    1128:	fc 01       	movw	r30, r24
    112a:	5b 01       	movw	r10, r22
    112c:	d8 01       	movw	r26, r16
    112e:	89 01       	movw	r16, r18
    1130:	60 e0       	ldi	r22, 0x00	; 0
    1132:	70 e0       	ldi	r23, 0x00	; 0
				// now we test to see if the counter has counted high enough, and
				// if it has, then we do record a green hit.
				int test = TCNT1 - greenTimers[guitarString];
		    	if (  (data->greenOn == 0) && (( test > GREEN_TIMER_WAIT) || (test <= 0)) )
		    	{
		        	data->greenOn = 1;
    1134:	ff 24       	eor	r15, r15
    1136:	f3 94       	inc	r15
		{
		    if (triedGreen[guitarString] == 0) // we didn't touch green last cycle
		    {        
				// so we start the counter and say we did touch it.
		      greenTimers[guitarString] = TCNT1;
		      triedGreen[guitarString] = 1;
    1138:	81 e0       	ldi	r24, 0x01	; 1
    113a:	c8 2e       	mov	r12, r24
    113c:	d1 2c       	mov	r13, r1
		counts up to the GREEN_TIMER_WAIT, red gets activated and green doesn't.
	 */
	for(int guitarString = 0; guitarString < NUMBER_OF_STRINGS; guitarString++)
	{
		//First, we'll see if we're pressing anything at all (ignores strumming)
		if (stringState[guitarString] > 1)
    113e:	e5 01       	movw	r28, r10
    1140:	88 81       	ld	r24, Y
    1142:	99 81       	ldd	r25, Y+1	; 0x01
    1144:	02 97       	sbiw	r24, 0x02	; 2
    1146:	1c f0       	brlt	.+6      	; 0x114e <processFrets+0x38>
			data->numberOfStringsPressed++;
    1148:	81 85       	ldd	r24, Z+9	; 0x09
    114a:	8f 5f       	subi	r24, 0xFF	; 255
    114c:	81 87       	std	Z+9, r24	; 0x09

		// find the proper value by masking the stringState variable for each fret
		char orange = (stringState[guitarString] & (1<<5));
    114e:	e5 01       	movw	r28, r10
    1150:	88 81       	ld	r24, Y
		char blue   = (stringState[guitarString] & (1<<4));
    1152:	98 2f       	mov	r25, r24
    1154:	90 71       	andi	r25, 0x10	; 16
		char yellow = (stringState[guitarString] & (1<<3));
    1156:	28 2f       	mov	r18, r24
    1158:	28 70       	andi	r18, 0x08	; 8
		char red    = (stringState[guitarString] & (1<<2));
    115a:	38 2f       	mov	r19, r24
    115c:	34 70       	andi	r19, 0x04	; 4
		char green  = (stringState[guitarString] & (1<<1));
    115e:	48 2f       	mov	r20, r24
    1160:	42 70       	andi	r20, 0x02	; 2
		if ((orange != 0) && (blue != 0) && (data->orangeOn == 0))
    1162:	85 ff       	sbrs	r24, 5
    1164:	07 c0       	rjmp	.+14     	; 0x1174 <processFrets+0x5e>
    1166:	99 23       	and	r25, r25
    1168:	71 f0       	breq	.+28     	; 0x1186 <processFrets+0x70>
    116a:	84 81       	ldd	r24, Z+4	; 0x04
    116c:	88 23       	and	r24, r24
    116e:	21 f4       	brne	.+8      	; 0x1178 <processFrets+0x62>
		{    
		    data->orangeOn = 1;
    1170:	f4 82       	std	Z+4, r15	; 0x04
    1172:	40 c0       	rjmp	.+128    	; 0x11f4 <processFrets+0xde>
		    triedGreen[guitarString] = 0;
		}
		else if ((blue != 0) && (yellow != 0) && (data->blueOn == 0))
    1174:	99 23       	and	r25, r25
    1176:	39 f0       	breq	.+14     	; 0x1186 <processFrets+0x70>
    1178:	22 23       	and	r18, r18
    117a:	71 f0       	breq	.+28     	; 0x1198 <processFrets+0x82>
    117c:	83 81       	ldd	r24, Z+3	; 0x03
    117e:	88 23       	and	r24, r24
    1180:	21 f4       	brne	.+8      	; 0x118a <processFrets+0x74>
		{
		    data->blueOn = 1;
    1182:	f3 82       	std	Z+3, r15	; 0x03
    1184:	37 c0       	rjmp	.+110    	; 0x11f4 <processFrets+0xde>
		    triedGreen[guitarString] = 0;
		}
		else if ((yellow != 0) && (red != 0) && (data->yellowOn == 0))
    1186:	22 23       	and	r18, r18
    1188:	39 f0       	breq	.+14     	; 0x1198 <processFrets+0x82>
    118a:	33 23       	and	r19, r19
    118c:	71 f0       	breq	.+28     	; 0x11aa <processFrets+0x94>
    118e:	82 81       	ldd	r24, Z+2	; 0x02
    1190:	88 23       	and	r24, r24
    1192:	21 f4       	brne	.+8      	; 0x119c <processFrets+0x86>
		{
		    data->yellowOn = 1;
    1194:	f2 82       	std	Z+2, r15	; 0x02
    1196:	2e c0       	rjmp	.+92     	; 0x11f4 <processFrets+0xde>
		    triedGreen[guitarString] = 0;
		}
		else if ((red != 0) && (green != 0) && (data->redOn == 0))
    1198:	33 23       	and	r19, r19
    119a:	39 f0       	breq	.+14     	; 0x11aa <processFrets+0x94>
    119c:	44 23       	and	r20, r20
    119e:	51 f1       	breq	.+84     	; 0x11f4 <processFrets+0xde>
    11a0:	81 81       	ldd	r24, Z+1	; 0x01
    11a2:	88 23       	and	r24, r24
    11a4:	21 f4       	brne	.+8      	; 0x11ae <processFrets+0x98>
		{
		    data->redOn = 1;
    11a6:	f1 82       	std	Z+1, r15	; 0x01
    11a8:	25 c0       	rjmp	.+74     	; 0x11f4 <processFrets+0xde>
		    triedGreen[guitarString] = 0;
		}
		else if (green != 0)
    11aa:	44 23       	and	r20, r20
    11ac:	19 f1       	breq	.+70     	; 0x11f4 <processFrets+0xde>
		{
		    if (triedGreen[guitarString] == 0) // we didn't touch green last cycle
    11ae:	8d 91       	ld	r24, X+
    11b0:	9c 91       	ld	r25, X
    11b2:	11 97       	sbiw	r26, 0x01	; 1
    11b4:	89 2b       	or	r24, r25
    11b6:	59 f4       	brne	.+22     	; 0x11ce <processFrets+0xb8>
		    {        
				// so we start the counter and say we did touch it.
		      greenTimers[guitarString] = TCNT1;
    11b8:	80 91 84 00 	lds	r24, 0x0084
    11bc:	90 91 85 00 	lds	r25, 0x0085
    11c0:	e8 01       	movw	r28, r16
    11c2:	99 83       	std	Y+1, r25	; 0x01
    11c4:	88 83       	st	Y, r24
		      triedGreen[guitarString] = 1;
    11c6:	11 96       	adiw	r26, 0x01	; 1
    11c8:	dc 92       	st	X, r13
    11ca:	ce 92       	st	-X, r12
    11cc:	16 c0       	rjmp	.+44     	; 0x11fa <processFrets+0xe4>
		    }
		    else //triedGreen == true
		    {
				// now we test to see if the counter has counted high enough, and
				// if it has, then we do record a green hit.
				int test = TCNT1 - greenTimers[guitarString];
    11ce:	20 91 84 00 	lds	r18, 0x0084
    11d2:	30 91 85 00 	lds	r19, 0x0085
    11d6:	e8 01       	movw	r28, r16
    11d8:	48 81       	ld	r20, Y
    11da:	59 81       	ldd	r21, Y+1	; 0x01
		    	if (  (data->greenOn == 0) && (( test > GREEN_TIMER_WAIT) || (test <= 0)) )
    11dc:	80 81       	ld	r24, Z
    11de:	88 23       	and	r24, r24
    11e0:	61 f4       	brne	.+24     	; 0x11fa <processFrets+0xe4>
    11e2:	21 50       	subi	r18, 0x01	; 1
    11e4:	30 40       	sbci	r19, 0x00	; 0
    11e6:	24 1b       	sub	r18, r20
    11e8:	35 0b       	sbc	r19, r21
    11ea:	24 36       	cpi	r18, 0x64	; 100
    11ec:	31 05       	cpc	r19, r1
    11ee:	28 f0       	brcs	.+10     	; 0x11fa <processFrets+0xe4>
		    	{
		        	data->greenOn = 1;
    11f0:	f0 82       	st	Z, r15
    11f2:	03 c0       	rjmp	.+6      	; 0x11fa <processFrets+0xe4>
		    	}
		    }
		}
	    else  //no buttons pressed
	    {
	        triedGreen[guitarString] = 0;
    11f4:	11 96       	adiw	r26, 0x01	; 1
    11f6:	1c 92       	st	X, r1
    11f8:	1e 92       	st	-X, r1
		the strum has a direction, so if you strum the
		top 3 strings, you strum down, and if you strum
		the bottom 3 strings, you're strumming up.
	*/
		// Check for strumming
		if (stringState[guitarString] & 1)
    11fa:	e5 01       	movw	r28, r10
    11fc:	88 81       	ld	r24, Y
    11fe:	80 ff       	sbrs	r24, 0
    1200:	08 c0       	rjmp	.+16     	; 0x1212 <processFrets+0xfc>
		{
			if (guitarString < 3)
    1202:	63 30       	cpi	r22, 0x03	; 3
    1204:	71 05       	cpc	r23, r1
    1206:	1c f4       	brge	.+6      	; 0x120e <processFrets+0xf8>
			{
				data->downOn = 1;
    1208:	f6 82       	std	Z+6, r15	; 0x06
				data->upOn   = 0;
    120a:	15 82       	std	Z+5, r1	; 0x05
    120c:	02 c0       	rjmp	.+4      	; 0x1212 <processFrets+0xfc>
			}
			else
			{
				data->upOn   = 1;
    120e:	f5 82       	std	Z+5, r15	; 0x05
				data->downOn = 0;
    1210:	16 82       	std	Z+6, r1	; 0x06
		you don't want that to register as a green button press.  So we do some
		timing on that one, so when you press just green, it starts counting
		instead of turing greenOn on, so if the red fret is turned on before it
		counts up to the GREEN_TIMER_WAIT, red gets activated and green doesn't.
	 */
	for(int guitarString = 0; guitarString < NUMBER_OF_STRINGS; guitarString++)
    1212:	6f 5f       	subi	r22, 0xFF	; 255
    1214:	7f 4f       	sbci	r23, 0xFF	; 255
    1216:	82 e0       	ldi	r24, 0x02	; 2
    1218:	90 e0       	ldi	r25, 0x00	; 0
    121a:	a8 0e       	add	r10, r24
    121c:	b9 1e       	adc	r11, r25
    121e:	12 96       	adiw	r26, 0x02	; 2
    1220:	0e 5f       	subi	r16, 0xFE	; 254
    1222:	1f 4f       	sbci	r17, 0xFF	; 255
    1224:	66 30       	cpi	r22, 0x06	; 6
    1226:	71 05       	cpc	r23, r1
    1228:	09 f0       	breq	.+2      	; 0x122c <processFrets+0x116>
    122a:	89 cf       	rjmp	.-238    	; 0x113e <processFrets+0x28>
	}	// end of for loop

	// Code for fixing some issues with gap chords (green/yellow, red/blue, etc.)
	// If we're not pressing all the strings, make sure that gap chords are only showing
	// when we press all strings
	if (data->numberOfStringsPressed < NUMBER_OF_STRINGS)
    122c:	81 85       	ldd	r24, Z+9	; 0x09
    122e:	86 30       	cpi	r24, 0x06	; 6
    1230:	48 f5       	brcc	.+82     	; 0x1284 <processFrets+0x16e>
	{
		if(data->blueOn   &&
    1232:	83 81       	ldd	r24, Z+3	; 0x03
    1234:	88 23       	and	r24, r24
    1236:	59 f0       	breq	.+22     	; 0x124e <processFrets+0x138>
    1238:	82 81       	ldd	r24, Z+2	; 0x02
    123a:	88 23       	and	r24, r24
    123c:	41 f0       	breq	.+16     	; 0x124e <processFrets+0x138>
    123e:	81 81       	ldd	r24, Z+1	; 0x01
    1240:	88 23       	and	r24, r24
    1242:	29 f0       	breq	.+10     	; 0x124e <processFrets+0x138>
    1244:	80 81       	ld	r24, Z
    1246:	88 23       	and	r24, r24
    1248:	11 f0       	breq	.+4      	; 0x124e <processFrets+0x138>
		   data->yellowOn &&
		   data->redOn    &&
		   data->greenOn)
		{
		   	data->yellowOn = 0;
    124a:	12 82       	std	Z+2, r1	; 0x02
			data->greenOn  = 0;
    124c:	10 82       	st	Z, r1
		}

		if(data->orangeOn  &&
    124e:	84 81       	ldd	r24, Z+4	; 0x04
    1250:	88 23       	and	r24, r24
    1252:	31 f0       	breq	.+12     	; 0x1260 <processFrets+0x14a>
    1254:	83 81       	ldd	r24, Z+3	; 0x03
    1256:	88 23       	and	r24, r24
    1258:	19 f0       	breq	.+6      	; 0x1260 <processFrets+0x14a>
    125a:	82 81       	ldd	r24, Z+2	; 0x02
    125c:	81 11       	cpse	r24, r1
		   data->blueOn   &&
		   data->yellowOn)
		   {data->blueOn = 0;}
    125e:	13 82       	std	Z+3, r1	; 0x03
		if(data->blueOn  &&
    1260:	83 81       	ldd	r24, Z+3	; 0x03
    1262:	88 23       	and	r24, r24
    1264:	31 f0       	breq	.+12     	; 0x1272 <processFrets+0x15c>
    1266:	82 81       	ldd	r24, Z+2	; 0x02
    1268:	88 23       	and	r24, r24
    126a:	19 f0       	breq	.+6      	; 0x1272 <processFrets+0x15c>
    126c:	81 81       	ldd	r24, Z+1	; 0x01
    126e:	81 11       	cpse	r24, r1
		   data->yellowOn   &&
		   data->redOn)
		   {data->yellowOn = 0;}
    1270:	12 82       	std	Z+2, r1	; 0x02
		if(data->yellowOn  &&
    1272:	82 81       	ldd	r24, Z+2	; 0x02
    1274:	88 23       	and	r24, r24
    1276:	31 f0       	breq	.+12     	; 0x1284 <processFrets+0x16e>
    1278:	81 81       	ldd	r24, Z+1	; 0x01
    127a:	88 23       	and	r24, r24
    127c:	19 f0       	breq	.+6      	; 0x1284 <processFrets+0x16e>
    127e:	80 81       	ld	r24, Z
    1280:	81 11       	cpse	r24, r1
		   data->redOn   &&
		   data->greenOn)
		   {data->redOn = 0;}
    1282:	11 82       	std	Z+1, r1	; 0x01

	}

	return;
}
    1284:	df 91       	pop	r29
    1286:	cf 91       	pop	r28
    1288:	1f 91       	pop	r17
    128a:	0f 91       	pop	r16
    128c:	ff 90       	pop	r15
    128e:	df 90       	pop	r13
    1290:	cf 90       	pop	r12
    1292:	bf 90       	pop	r11
    1294:	af 90       	pop	r10
    1296:	08 95       	ret

00001298 <processStringState>:

void processStringState(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS], char controllerMode, 
									int greenTimers[NUMBER_OF_STRINGS], int triedGreen[NUMBER_OF_STRINGS])
{
    1298:	ef 92       	push	r14
    129a:	ff 92       	push	r15
    129c:	0f 93       	push	r16
    129e:	1f 93       	push	r17
	if (controllerMode == CHORDS) // If we're playing with Chords - default is FRETS
    12a0:	24 30       	cpi	r18, 0x04	; 4
    12a2:	19 f4       	brne	.+6      	; 0x12aa <processStringState+0x12>
		processChords(data, stringState, buttonStringPatterns);
    12a4:	0e 94 4a 05 	call	0xa94	; 0xa94 <processChords>
    12a8:	09 c0       	rjmp	.+18     	; 0x12bc <processStringState+0x24>

	else if (controllerMode == NOTES) // We're playing with notes
    12aa:	22 30       	cpi	r18, 0x02	; 2
    12ac:	19 f4       	brne	.+6      	; 0x12b4 <processStringState+0x1c>
		processNotes(data, stringState, buttonStringPatterns);
    12ae:	0e 94 c4 07 	call	0xf88	; 0xf88 <processNotes>
    12b2:	04 c0       	rjmp	.+8      	; 0x12bc <processStringState+0x24>
	
	else // We're playing with frets
		processFrets(data, stringState,	buttonStringPatterns, greenTimers, triedGreen);
    12b4:	98 01       	movw	r18, r16
    12b6:	87 01       	movw	r16, r14
    12b8:	0e 94 8b 08 	call	0x1116	; 0x1116 <processFrets>

	return;	
}
    12bc:	1f 91       	pop	r17
    12be:	0f 91       	pop	r16
    12c0:	ff 90       	pop	r15
    12c2:	ef 90       	pop	r14
    12c4:	08 95       	ret

000012c6 <displayTransitionState>:

// This simple function takes in the controller mode and sets the
//  data struct to certain patterns to give the user feedback
//  as to what state is being pressed
void displayTransitionState(dataForController* data, int controllerMode)
{
    12c6:	fc 01       	movw	r30, r24
	if (controllerMode == FRETS_TO_NOTES)
    12c8:	61 30       	cpi	r22, 0x01	; 1
    12ca:	71 05       	cpc	r23, r1
    12cc:	21 f4       	brne	.+8      	; 0x12d6 <displayTransitionState+0x10>
	{
		data->blueOn = 1;
    12ce:	81 e0       	ldi	r24, 0x01	; 1
    12d0:	83 83       	std	Z+3, r24	; 0x03
		data->yellowOn = 1;
    12d2:	82 83       	std	Z+2, r24	; 0x02
    12d4:	08 95       	ret
	}
	else if (controllerMode == NOTES_TO_CHORDS)
    12d6:	63 30       	cpi	r22, 0x03	; 3
    12d8:	71 05       	cpc	r23, r1
    12da:	21 f4       	brne	.+8      	; 0x12e4 <displayTransitionState+0x1e>
	{
		data->blueOn = 1;
    12dc:	81 e0       	ldi	r24, 0x01	; 1
    12de:	83 83       	std	Z+3, r24	; 0x03
		data->orangeOn = 1;
    12e0:	84 83       	std	Z+4, r24	; 0x04
    12e2:	08 95       	ret
	}
	else if (controllerMode == CHORDS_TO_FRETS)
    12e4:	65 30       	cpi	r22, 0x05	; 5
    12e6:	71 05       	cpc	r23, r1
    12e8:	19 f4       	brne	.+6      	; 0x12f0 <displayTransitionState+0x2a>
	{
		data->yellowOn = 1;
    12ea:	81 e0       	ldi	r24, 0x01	; 1
    12ec:	82 83       	std	Z+2, r24	; 0x02
		data->orangeOn = 1;
    12ee:	84 83       	std	Z+4, r24	; 0x04
    12f0:	08 95       	ret

000012f2 <configSetButtonData>:
/* This function sets up the data struct when we're in config mode so that it shows
 *  the user which colors are currently being programmed.
 */
void configSetButtonData(dataForController* data, int* buttonToAssign, int buttonStringPatterns[][6], 
						int stringState[], char controllerMode, char* plusLock, char* previousPlusOn, int* debounceTimer)
{
    12f2:	af 92       	push	r10
    12f4:	bf 92       	push	r11
    12f6:	cf 92       	push	r12
    12f8:	df 92       	push	r13
    12fa:	ef 92       	push	r14
    12fc:	ff 92       	push	r15
    12fe:	0f 93       	push	r16
    1300:	cf 93       	push	r28
    1302:	df 93       	push	r29
    1304:	fc 01       	movw	r30, r24
    1306:	db 01       	movw	r26, r22
    1308:	b9 01       	movw	r22, r18
    130a:	95 01       	movw	r18, r10
	// Since 'colorOn' is 1 when a fret is pressed, we invert, shift, invert, and & it to set the
	// corresponding button bit to zero, which corresponds to a button press.
	if (*buttonToAssign == 0)
    130c:	8d 91       	ld	r24, X+
    130e:	9c 91       	ld	r25, X
    1310:	11 97       	sbiw	r26, 0x01	; 1
    1312:	00 97       	sbiw	r24, 0x00	; 0
    1314:	19 f4       	brne	.+6      	; 0x131c <configSetButtonData+0x2a>
		data->greenOn = 1;
    1316:	81 e0       	ldi	r24, 0x01	; 1
    1318:	80 83       	st	Z, r24
    131a:	34 c0       	rjmp	.+104    	; 0x1384 <configSetButtonData+0x92>
	else if(*buttonToAssign == 1)
    131c:	81 30       	cpi	r24, 0x01	; 1
    131e:	91 05       	cpc	r25, r1
    1320:	11 f4       	brne	.+4      	; 0x1326 <configSetButtonData+0x34>
		data->redOn = 1;
    1322:	81 e0       	ldi	r24, 0x01	; 1
    1324:	15 c0       	rjmp	.+42     	; 0x1350 <configSetButtonData+0x5e>
	else if(*buttonToAssign == 2)
    1326:	82 30       	cpi	r24, 0x02	; 2
    1328:	91 05       	cpc	r25, r1
    132a:	11 f4       	brne	.+4      	; 0x1330 <configSetButtonData+0x3e>
		data->yellowOn = 1;
    132c:	81 e0       	ldi	r24, 0x01	; 1
    132e:	23 c0       	rjmp	.+70     	; 0x1376 <configSetButtonData+0x84>
	else if(*buttonToAssign == 3)
    1330:	83 30       	cpi	r24, 0x03	; 3
    1332:	91 05       	cpc	r25, r1
    1334:	11 f4       	brne	.+4      	; 0x133a <configSetButtonData+0x48>
		data->blueOn = 1;
    1336:	81 e0       	ldi	r24, 0x01	; 1
    1338:	24 c0       	rjmp	.+72     	; 0x1382 <configSetButtonData+0x90>
	else if(*buttonToAssign == 4)
    133a:	84 30       	cpi	r24, 0x04	; 4
    133c:	91 05       	cpc	r25, r1
    133e:	19 f4       	brne	.+6      	; 0x1346 <configSetButtonData+0x54>
		data->orangeOn = 1;
    1340:	81 e0       	ldi	r24, 0x01	; 1
    1342:	84 83       	std	Z+4, r24	; 0x04
    1344:	1f c0       	rjmp	.+62     	; 0x1384 <configSetButtonData+0x92>
	else if(*buttonToAssign == 5)
    1346:	85 30       	cpi	r24, 0x05	; 5
    1348:	91 05       	cpc	r25, r1
    134a:	21 f4       	brne	.+8      	; 0x1354 <configSetButtonData+0x62>
	{
		data->greenOn = 1;
    134c:	81 e0       	ldi	r24, 0x01	; 1
    134e:	80 83       	st	Z, r24
		data->redOn = 1;
    1350:	81 83       	std	Z+1, r24	; 0x01
    1352:	18 c0       	rjmp	.+48     	; 0x1384 <configSetButtonData+0x92>
	}
	else if(*buttonToAssign == 6)
    1354:	86 30       	cpi	r24, 0x06	; 6
    1356:	91 05       	cpc	r25, r1
    1358:	19 f4       	brne	.+6      	; 0x1360 <configSetButtonData+0x6e>
	{
		data->redOn = 1;
    135a:	81 e0       	ldi	r24, 0x01	; 1
    135c:	81 83       	std	Z+1, r24	; 0x01
    135e:	0b c0       	rjmp	.+22     	; 0x1376 <configSetButtonData+0x84>
		data->yellowOn = 1;
	}
	else if(*buttonToAssign == 7)
    1360:	87 30       	cpi	r24, 0x07	; 7
    1362:	91 05       	cpc	r25, r1
    1364:	19 f4       	brne	.+6      	; 0x136c <configSetButtonData+0x7a>
	{
		data->yellowOn = 1;
    1366:	81 e0       	ldi	r24, 0x01	; 1
    1368:	82 83       	std	Z+2, r24	; 0x02
    136a:	0b c0       	rjmp	.+22     	; 0x1382 <configSetButtonData+0x90>
		data->blueOn = 1;
	}
	else if(*buttonToAssign == 8)
    136c:	88 30       	cpi	r24, 0x08	; 8
    136e:	91 05       	cpc	r25, r1
    1370:	21 f4       	brne	.+8      	; 0x137a <configSetButtonData+0x88>
	{
		data->greenOn = 1;
    1372:	81 e0       	ldi	r24, 0x01	; 1
    1374:	80 83       	st	Z, r24
		data->yellowOn = 1;
    1376:	82 83       	std	Z+2, r24	; 0x02
    1378:	05 c0       	rjmp	.+10     	; 0x1384 <configSetButtonData+0x92>
	}
	else if(*buttonToAssign == 9)
    137a:	09 97       	sbiw	r24, 0x09	; 9
    137c:	19 f4       	brne	.+6      	; 0x1384 <configSetButtonData+0x92>
	{
		data->redOn = 1;
    137e:	81 e0       	ldi	r24, 0x01	; 1
    1380:	81 83       	std	Z+1, r24	; 0x01
		data->blueOn = 1;
    1382:	83 83       	std	Z+3, r24	; 0x03
	}



	// Code to debounce our plus button, the current state of plusOn to it's recent history
	if (data->plusOn != 0)  // So we're pressing plus
    1384:	87 81       	ldd	r24, Z+7	; 0x07
    1386:	88 23       	and	r24, r24
    1388:	09 f1       	breq	.+66     	; 0x13cc <configSetButtonData+0xda>
	{ 
		if (*previousPlusOn == 0)  // If we weren't pressing plus last time through the main loop
    138a:	e6 01       	movw	r28, r12
    138c:	88 81       	ld	r24, Y
    138e:	88 23       	and	r24, r24
    1390:	59 f4       	brne	.+22     	; 0x13a8 <configSetButtonData+0xb6>
		{ 
			*debounceTimer = TCNT1;  // Set up a timer
    1392:	80 91 84 00 	lds	r24, 0x0084
    1396:	90 91 85 00 	lds	r25, 0x0085
    139a:	e9 01       	movw	r28, r18
    139c:	99 83       	std	Y+1, r25	; 0x01
    139e:	88 83       	st	Y, r24
			*previousPlusOn = 1;     // remember plus was pressed for the next iteration
    13a0:	81 e0       	ldi	r24, 0x01	; 1
    13a2:	e6 01       	movw	r28, r12
    13a4:	88 83       	st	Y, r24
    13a6:	10 c0       	rjmp	.+32     	; 0x13c8 <configSetButtonData+0xd6>
			data->plusOn = 0;        // but for now, consider plus not pressed.
		}
		else if ( (TCNT1 - *debounceTimer < DEBOUNCE_DELAY) && (TCNT1 - *debounceTimer >= 0))
    13a8:	80 91 84 00 	lds	r24, 0x0084
    13ac:	90 91 85 00 	lds	r25, 0x0085
    13b0:	e9 01       	movw	r28, r18
    13b2:	28 81       	ld	r18, Y
    13b4:	39 81       	ldd	r19, Y+1	; 0x01
    13b6:	82 1b       	sub	r24, r18
    13b8:	93 0b       	sbc	r25, r19
    13ba:	88 5e       	subi	r24, 0xE8	; 232
    13bc:	93 40       	sbci	r25, 0x03	; 3
    13be:	40 f4       	brcc	.+16     	; 0x13d0 <configSetButtonData+0xde>
    13c0:	80 91 84 00 	lds	r24, 0x0084
    13c4:	90 91 85 00 	lds	r25, 0x0085
		{
			data->plusOn = 0;  // This keeps telling us plus wasn't pressed until it's been held long enough
    13c8:	17 82       	std	Z+7, r1	; 0x07
    13ca:	02 c0       	rjmp	.+4      	; 0x13d0 <configSetButtonData+0xde>
		}		
	}
	else
	{
		*previousPlusOn = 0; // and if plus wasn't pressed, remember that for next time
    13cc:	e6 01       	movw	r28, r12
    13ce:	18 82       	st	Y, r1
	}

	// Now, if you press plus, it will lock in whatever string pattern
	// and advance to working on the next pattern.
	if((data->plusOn) && (*plusLock == 0))
    13d0:	87 81       	ldd	r24, Z+7	; 0x07
    13d2:	88 23       	and	r24, r24
    13d4:	09 f4       	brne	.+2      	; 0x13d8 <configSetButtonData+0xe6>
    13d6:	f7 c0       	rjmp	.+494    	; 0x15c6 <configSetButtonData+0x2d4>
    13d8:	f7 01       	movw	r30, r14
    13da:	80 81       	ld	r24, Z
    13dc:	88 23       	and	r24, r24
    13de:	09 f0       	breq	.+2      	; 0x13e2 <configSetButtonData+0xf0>
    13e0:	f4 c0       	rjmp	.+488    	; 0x15ca <configSetButtonData+0x2d8>
	{

		if (controllerMode == CHORDS) 
    13e2:	04 30       	cpi	r16, 0x04	; 4
    13e4:	09 f0       	breq	.+2      	; 0x13e8 <configSetButtonData+0xf6>
    13e6:	60 c0       	rjmp	.+192    	; 0x14a8 <configSetButtonData+0x1b6>
		{   // Set the pattern to nothing pressed
			buttonStringPatterns[*buttonToAssign][0] = 0;
    13e8:	8d 91       	ld	r24, X+
    13ea:	9c 91       	ld	r25, X
    13ec:	11 97       	sbiw	r26, 0x01	; 1
    13ee:	fc 01       	movw	r30, r24
    13f0:	ee 0f       	add	r30, r30
    13f2:	ff 1f       	adc	r31, r31
    13f4:	e8 0f       	add	r30, r24
    13f6:	f9 1f       	adc	r31, r25
    13f8:	ee 0f       	add	r30, r30
    13fa:	ff 1f       	adc	r31, r31
    13fc:	ee 0f       	add	r30, r30
    13fe:	ff 1f       	adc	r31, r31
    1400:	e4 0f       	add	r30, r20
    1402:	f5 1f       	adc	r31, r21
    1404:	11 82       	std	Z+1, r1	; 0x01
    1406:	10 82       	st	Z, r1
			buttonStringPatterns[*buttonToAssign][1] = 0;
    1408:	8d 91       	ld	r24, X+
    140a:	9c 91       	ld	r25, X
    140c:	11 97       	sbiw	r26, 0x01	; 1
    140e:	fc 01       	movw	r30, r24
    1410:	ee 0f       	add	r30, r30
    1412:	ff 1f       	adc	r31, r31
    1414:	e8 0f       	add	r30, r24
    1416:	f9 1f       	adc	r31, r25
    1418:	ee 0f       	add	r30, r30
    141a:	ff 1f       	adc	r31, r31
    141c:	ee 0f       	add	r30, r30
    141e:	ff 1f       	adc	r31, r31
    1420:	e4 0f       	add	r30, r20
    1422:	f5 1f       	adc	r31, r21
    1424:	13 82       	std	Z+3, r1	; 0x03
    1426:	12 82       	std	Z+2, r1	; 0x02
			buttonStringPatterns[*buttonToAssign][2] = 0;
    1428:	8d 91       	ld	r24, X+
    142a:	9c 91       	ld	r25, X
    142c:	11 97       	sbiw	r26, 0x01	; 1
    142e:	fc 01       	movw	r30, r24
    1430:	ee 0f       	add	r30, r30
    1432:	ff 1f       	adc	r31, r31
    1434:	e8 0f       	add	r30, r24
    1436:	f9 1f       	adc	r31, r25
    1438:	ee 0f       	add	r30, r30
    143a:	ff 1f       	adc	r31, r31
    143c:	ee 0f       	add	r30, r30
    143e:	ff 1f       	adc	r31, r31
    1440:	e4 0f       	add	r30, r20
    1442:	f5 1f       	adc	r31, r21
    1444:	15 82       	std	Z+5, r1	; 0x05
    1446:	14 82       	std	Z+4, r1	; 0x04
			buttonStringPatterns[*buttonToAssign][3] = 0;
    1448:	8d 91       	ld	r24, X+
    144a:	9c 91       	ld	r25, X
    144c:	11 97       	sbiw	r26, 0x01	; 1
    144e:	fc 01       	movw	r30, r24
    1450:	ee 0f       	add	r30, r30
    1452:	ff 1f       	adc	r31, r31
    1454:	e8 0f       	add	r30, r24
    1456:	f9 1f       	adc	r31, r25
    1458:	ee 0f       	add	r30, r30
    145a:	ff 1f       	adc	r31, r31
    145c:	ee 0f       	add	r30, r30
    145e:	ff 1f       	adc	r31, r31
    1460:	e4 0f       	add	r30, r20
    1462:	f5 1f       	adc	r31, r21
    1464:	17 82       	std	Z+7, r1	; 0x07
    1466:	16 82       	std	Z+6, r1	; 0x06
			buttonStringPatterns[*buttonToAssign][4] = 0;
    1468:	8d 91       	ld	r24, X+
    146a:	9c 91       	ld	r25, X
    146c:	11 97       	sbiw	r26, 0x01	; 1
    146e:	fc 01       	movw	r30, r24
    1470:	ee 0f       	add	r30, r30
    1472:	ff 1f       	adc	r31, r31
    1474:	e8 0f       	add	r30, r24
    1476:	f9 1f       	adc	r31, r25
    1478:	ee 0f       	add	r30, r30
    147a:	ff 1f       	adc	r31, r31
    147c:	ee 0f       	add	r30, r30
    147e:	ff 1f       	adc	r31, r31
    1480:	e4 0f       	add	r30, r20
    1482:	f5 1f       	adc	r31, r21
    1484:	11 86       	std	Z+9, r1	; 0x09
    1486:	10 86       	std	Z+8, r1	; 0x08
			buttonStringPatterns[*buttonToAssign][5] = 0;
    1488:	8d 91       	ld	r24, X+
    148a:	9c 91       	ld	r25, X
    148c:	11 97       	sbiw	r26, 0x01	; 1
    148e:	fc 01       	movw	r30, r24
    1490:	ee 0f       	add	r30, r30
    1492:	ff 1f       	adc	r31, r31
    1494:	e8 0f       	add	r30, r24
    1496:	f9 1f       	adc	r31, r25
    1498:	ee 0f       	add	r30, r30
    149a:	ff 1f       	adc	r31, r31
    149c:	ee 0f       	add	r30, r30
    149e:	ff 1f       	adc	r31, r31
    14a0:	e4 0f       	add	r30, r20
    14a2:	f5 1f       	adc	r31, r21
    14a4:	13 86       	std	Z+11, r1	; 0x0b
    14a6:	12 86       	std	Z+10, r1	; 0x0a
		}
			// Assign what's being pressed on the frets to what matches the current button press
		buttonStringPatterns[*buttonToAssign][0] |= stringState[0];
    14a8:	8d 91       	ld	r24, X+
    14aa:	9c 91       	ld	r25, X
    14ac:	11 97       	sbiw	r26, 0x01	; 1
    14ae:	fc 01       	movw	r30, r24
    14b0:	ee 0f       	add	r30, r30
    14b2:	ff 1f       	adc	r31, r31
    14b4:	e8 0f       	add	r30, r24
    14b6:	f9 1f       	adc	r31, r25
    14b8:	ee 0f       	add	r30, r30
    14ba:	ff 1f       	adc	r31, r31
    14bc:	ee 0f       	add	r30, r30
    14be:	ff 1f       	adc	r31, r31
    14c0:	e4 0f       	add	r30, r20
    14c2:	f5 1f       	adc	r31, r21
    14c4:	80 81       	ld	r24, Z
    14c6:	91 81       	ldd	r25, Z+1	; 0x01
    14c8:	eb 01       	movw	r28, r22
    14ca:	28 81       	ld	r18, Y
    14cc:	39 81       	ldd	r19, Y+1	; 0x01
    14ce:	82 2b       	or	r24, r18
    14d0:	93 2b       	or	r25, r19
    14d2:	91 83       	std	Z+1, r25	; 0x01
    14d4:	80 83       	st	Z, r24
		buttonStringPatterns[*buttonToAssign][1] |= stringState[1];
    14d6:	8d 91       	ld	r24, X+
    14d8:	9c 91       	ld	r25, X
    14da:	11 97       	sbiw	r26, 0x01	; 1
    14dc:	fc 01       	movw	r30, r24
    14de:	ee 0f       	add	r30, r30
    14e0:	ff 1f       	adc	r31, r31
    14e2:	e8 0f       	add	r30, r24
    14e4:	f9 1f       	adc	r31, r25
    14e6:	ee 0f       	add	r30, r30
    14e8:	ff 1f       	adc	r31, r31
    14ea:	ee 0f       	add	r30, r30
    14ec:	ff 1f       	adc	r31, r31
    14ee:	e4 0f       	add	r30, r20
    14f0:	f5 1f       	adc	r31, r21
    14f2:	82 81       	ldd	r24, Z+2	; 0x02
    14f4:	93 81       	ldd	r25, Z+3	; 0x03
    14f6:	2a 81       	ldd	r18, Y+2	; 0x02
    14f8:	3b 81       	ldd	r19, Y+3	; 0x03
    14fa:	82 2b       	or	r24, r18
    14fc:	93 2b       	or	r25, r19
    14fe:	93 83       	std	Z+3, r25	; 0x03
    1500:	82 83       	std	Z+2, r24	; 0x02
		buttonStringPatterns[*buttonToAssign][2] |= stringState[2];
    1502:	8d 91       	ld	r24, X+
    1504:	9c 91       	ld	r25, X
    1506:	11 97       	sbiw	r26, 0x01	; 1
    1508:	fc 01       	movw	r30, r24
    150a:	ee 0f       	add	r30, r30
    150c:	ff 1f       	adc	r31, r31
    150e:	e8 0f       	add	r30, r24
    1510:	f9 1f       	adc	r31, r25
    1512:	ee 0f       	add	r30, r30
    1514:	ff 1f       	adc	r31, r31
    1516:	ee 0f       	add	r30, r30
    1518:	ff 1f       	adc	r31, r31
    151a:	e4 0f       	add	r30, r20
    151c:	f5 1f       	adc	r31, r21
    151e:	84 81       	ldd	r24, Z+4	; 0x04
    1520:	95 81       	ldd	r25, Z+5	; 0x05
    1522:	2c 81       	ldd	r18, Y+4	; 0x04
    1524:	3d 81       	ldd	r19, Y+5	; 0x05
    1526:	82 2b       	or	r24, r18
    1528:	93 2b       	or	r25, r19
    152a:	95 83       	std	Z+5, r25	; 0x05
    152c:	84 83       	std	Z+4, r24	; 0x04
		buttonStringPatterns[*buttonToAssign][3] |= stringState[3];
    152e:	8d 91       	ld	r24, X+
    1530:	9c 91       	ld	r25, X
    1532:	11 97       	sbiw	r26, 0x01	; 1
    1534:	fc 01       	movw	r30, r24
    1536:	ee 0f       	add	r30, r30
    1538:	ff 1f       	adc	r31, r31
    153a:	e8 0f       	add	r30, r24
    153c:	f9 1f       	adc	r31, r25
    153e:	ee 0f       	add	r30, r30
    1540:	ff 1f       	adc	r31, r31
    1542:	ee 0f       	add	r30, r30
    1544:	ff 1f       	adc	r31, r31
    1546:	e4 0f       	add	r30, r20
    1548:	f5 1f       	adc	r31, r21
    154a:	86 81       	ldd	r24, Z+6	; 0x06
    154c:	97 81       	ldd	r25, Z+7	; 0x07
    154e:	2e 81       	ldd	r18, Y+6	; 0x06
    1550:	3f 81       	ldd	r19, Y+7	; 0x07
    1552:	82 2b       	or	r24, r18
    1554:	93 2b       	or	r25, r19
    1556:	97 83       	std	Z+7, r25	; 0x07
    1558:	86 83       	std	Z+6, r24	; 0x06
		buttonStringPatterns[*buttonToAssign][4] |= stringState[4];
    155a:	8d 91       	ld	r24, X+
    155c:	9c 91       	ld	r25, X
    155e:	11 97       	sbiw	r26, 0x01	; 1
    1560:	fc 01       	movw	r30, r24
    1562:	ee 0f       	add	r30, r30
    1564:	ff 1f       	adc	r31, r31
    1566:	e8 0f       	add	r30, r24
    1568:	f9 1f       	adc	r31, r25
    156a:	ee 0f       	add	r30, r30
    156c:	ff 1f       	adc	r31, r31
    156e:	ee 0f       	add	r30, r30
    1570:	ff 1f       	adc	r31, r31
    1572:	e4 0f       	add	r30, r20
    1574:	f5 1f       	adc	r31, r21
    1576:	80 85       	ldd	r24, Z+8	; 0x08
    1578:	91 85       	ldd	r25, Z+9	; 0x09
    157a:	28 85       	ldd	r18, Y+8	; 0x08
    157c:	39 85       	ldd	r19, Y+9	; 0x09
    157e:	82 2b       	or	r24, r18
    1580:	93 2b       	or	r25, r19
    1582:	91 87       	std	Z+9, r25	; 0x09
    1584:	80 87       	std	Z+8, r24	; 0x08
		buttonStringPatterns[*buttonToAssign][5] |= stringState[5];
    1586:	8d 91       	ld	r24, X+
    1588:	9c 91       	ld	r25, X
    158a:	11 97       	sbiw	r26, 0x01	; 1
    158c:	fc 01       	movw	r30, r24
    158e:	ee 0f       	add	r30, r30
    1590:	ff 1f       	adc	r31, r31
    1592:	e8 0f       	add	r30, r24
    1594:	f9 1f       	adc	r31, r25
    1596:	ee 0f       	add	r30, r30
    1598:	ff 1f       	adc	r31, r31
    159a:	ee 0f       	add	r30, r30
    159c:	ff 1f       	adc	r31, r31
    159e:	e4 0f       	add	r30, r20
    15a0:	f5 1f       	adc	r31, r21
    15a2:	82 85       	ldd	r24, Z+10	; 0x0a
    15a4:	93 85       	ldd	r25, Z+11	; 0x0b
    15a6:	2a 85       	ldd	r18, Y+10	; 0x0a
    15a8:	3b 85       	ldd	r19, Y+11	; 0x0b
    15aa:	82 2b       	or	r24, r18
    15ac:	93 2b       	or	r25, r19
    15ae:	93 87       	std	Z+11, r25	; 0x0b
    15b0:	82 87       	std	Z+10, r24	; 0x0a

		*plusLock = 1;  // we set up a lock, so we don't assign all the buttons at once
    15b2:	81 e0       	ldi	r24, 0x01	; 1
    15b4:	f7 01       	movw	r30, r14
    15b6:	80 83       	st	Z, r24
		*buttonToAssign += 1;
    15b8:	8d 91       	ld	r24, X+
    15ba:	9c 91       	ld	r25, X
    15bc:	11 97       	sbiw	r26, 0x01	; 1
    15be:	01 96       	adiw	r24, 0x01	; 1
    15c0:	8d 93       	st	X+, r24
    15c2:	9c 93       	st	X, r25
    15c4:	02 c0       	rjmp	.+4      	; 0x15ca <configSetButtonData+0x2d8>
	}
	else if(data->plusOn == 0)
	{
		*plusLock = 0;
    15c6:	e7 01       	movw	r28, r14
    15c8:	18 82       	st	Y, r1
	}
	return;
}
    15ca:	df 91       	pop	r29
    15cc:	cf 91       	pop	r28
    15ce:	0f 91       	pop	r16
    15d0:	ff 90       	pop	r15
    15d2:	ef 90       	pop	r14
    15d4:	df 90       	pop	r13
    15d6:	cf 90       	pop	r12
    15d8:	bf 90       	pop	r11
    15da:	af 90       	pop	r10
    15dc:	08 95       	ret

000015de <usbFunctionSetup>:

/* ------------------------------------------------------------------------- */

usbMsgLen_t usbFunctionSetup(uchar data[8])
{
usbRequest_t    *rq = (void *)data;
    15de:	fc 01       	movw	r30, r24

    /* The following requests are never used. But since they are required by
     * the specification, we implement them in this example.
     */
    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* class request type */
    15e0:	80 81       	ld	r24, Z
    15e2:	80 76       	andi	r24, 0x60	; 96
    15e4:	80 32       	cpi	r24, 0x20	; 32
    15e6:	e1 f4       	brne	.+56     	; 0x1620 <usbFunctionSetup+0x42>
        //DBG1(0x50, &rq->bRequest, 1);   /* debug output: print our request */
        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
    15e8:	81 81       	ldd	r24, Z+1	; 0x01
    15ea:	81 30       	cpi	r24, 0x01	; 1
    15ec:	41 f4       	brne	.+16     	; 0x15fe <usbFunctionSetup+0x20>
            /* we only have one report type, so don't look at wValue */
            usbMsgPtr = (void *)&reportBuffer;
    15ee:	84 e0       	ldi	r24, 0x04	; 4
    15f0:	91 e0       	ldi	r25, 0x01	; 1
    15f2:	90 93 26 01 	sts	0x0126, r25
    15f6:	80 93 25 01 	sts	0x0125, r24
    15fa:	87 e0       	ldi	r24, 0x07	; 7
    15fc:	08 95       	ret
            return sizeof(reportBuffer);
        }else if(rq->bRequest == USBRQ_HID_GET_IDLE){
    15fe:	82 30       	cpi	r24, 0x02	; 2
    1600:	41 f4       	brne	.+16     	; 0x1612 <usbFunctionSetup+0x34>
            usbMsgPtr = &idleRate;
    1602:	82 e0       	ldi	r24, 0x02	; 2
    1604:	91 e0       	ldi	r25, 0x01	; 1
    1606:	90 93 26 01 	sts	0x0126, r25
    160a:	80 93 25 01 	sts	0x0125, r24
    160e:	81 e0       	ldi	r24, 0x01	; 1
    1610:	08 95       	ret
            return 1;
        }else if(rq->bRequest == USBRQ_HID_SET_IDLE){
    1612:	8a 30       	cpi	r24, 0x0A	; 10
    1614:	29 f4       	brne	.+10     	; 0x1620 <usbFunctionSetup+0x42>
            idleRate = rq->wValue.bytes[1];
    1616:	83 81       	ldd	r24, Z+3	; 0x03
    1618:	80 93 02 01 	sts	0x0102, r24
    161c:	80 e0       	ldi	r24, 0x00	; 0
    161e:	08 95       	ret
    1620:	80 e0       	ldi	r24, 0x00	; 0
        }
    }else{
        /* no vendor specific requests implemented */
    }
    return 0;   /* default for not implemented requests: return no data back to host */
}
    1622:	08 95       	ret

00001624 <sendData>:
	usbPoll();
}


void sendData(dataForController data)
{
    1624:	0f 93       	push	r16
    1626:	1f 93       	push	r17
    1628:	df 93       	push	r29
    162a:	cf 93       	push	r28
    162c:	cd b7       	in	r28, 0x3d	; 61
    162e:	de b7       	in	r29, 0x3e	; 62
    1630:	2a 97       	sbiw	r28, 0x0a	; 10
    1632:	0f b6       	in	r0, 0x3f	; 63
    1634:	f8 94       	cli
    1636:	de bf       	out	0x3e, r29	; 62
    1638:	0f be       	out	0x3f, r0	; 63
    163a:	cd bf       	out	0x3d, r28	; 61
    163c:	e0 2f       	mov	r30, r16
    163e:	09 83       	std	Y+1, r16	; 0x01
    1640:	a1 2f       	mov	r26, r17
    1642:	1a 83       	std	Y+2, r17	; 0x02
    1644:	f2 2f       	mov	r31, r18
    1646:	2b 83       	std	Y+3, r18	; 0x03
    1648:	b3 2f       	mov	r27, r19
    164a:	3c 83       	std	Y+4, r19	; 0x04
    164c:	24 2f       	mov	r18, r20
    164e:	4d 83       	std	Y+5, r20	; 0x05
    1650:	5e 83       	std	Y+6, r21	; 0x06
    1652:	46 2f       	mov	r20, r22
    1654:	6f 83       	std	Y+7, r22	; 0x07
    1656:	37 2f       	mov	r19, r23
    1658:	78 87       	std	Y+8, r23	; 0x08
    165a:	89 87       	std	Y+9, r24	; 0x09
    165c:	9a 87       	std	Y+10, r25	; 0x0a
    165e:	98 2f       	mov	r25, r24

       //set the buttons to all at default positions
        reportBuffer[0] = 0b00000000;
        reportBuffer[1] = 0b00000000;
    1660:	10 92 05 01 	sts	0x0105, r1
        reportBuffer[2] = 0b00001000;
    1664:	88 e0       	ldi	r24, 0x08	; 8
    1666:	80 93 06 01 	sts	0x0106, r24
        reportBuffer[3] = 0b10000000;
    166a:	80 e8       	ldi	r24, 0x80	; 128
    166c:	80 93 07 01 	sts	0x0107, r24
        reportBuffer[4] = 0b10000000;
    1670:	80 93 08 01 	sts	0x0108, r24
        reportBuffer[5] = 0b10000000;
    1674:	80 93 09 01 	sts	0x0109, r24
        reportBuffer[6] = 0b00000000;
    1678:	10 92 0a 01 	sts	0x010A, r1


        // Since 'colorOn' is 1 when a fret is pressed, we shift it to the proper place and | it to set the
        // corresponding button bit to one, which corresponds to a button press.
        reportBuffer[0] |= (data.orangeOn << ORANGE_BIT);
        reportBuffer[0] |= (data.blueOn << BLUE_BIT);
    167c:	22 95       	swap	r18
    167e:	20 7f       	andi	r18, 0xF0	; 240
    1680:	2b 2b       	or	r18, r27
        reportBuffer[0] |= (data.yellowOn << YELLOW_BIT);
        reportBuffer[0] |= (data.redOn << RED_BIT);
        reportBuffer[0] |= (data.greenOn << GREEN_BIT);
    1682:	aa 0f       	add	r26, r26
    1684:	aa 0f       	add	r26, r26
    1686:	ff 0f       	add	r31, r31
    1688:	ff 0f       	add	r31, r31
    168a:	ff 0f       	add	r31, r31
    168c:	fa 2b       	or	r31, r26
    168e:	ee 0f       	add	r30, r30
    1690:	ef 2b       	or	r30, r31
    1692:	e2 2b       	or	r30, r18
    1694:	e0 93 04 01 	sts	0x0104, r30

        // On the PS3, the strumming shows up as a hat switch, so we have to use conditionals for this..
        if (data.upOn)
    1698:	55 23       	and	r21, r21
    169a:	11 f0       	breq	.+4      	; 0x16a0 <sendData+0x7c>
                reportBuffer[2] = 0b00000000;
    169c:	10 92 06 01 	sts	0x0106, r1
        if (data.downOn)
    16a0:	44 23       	and	r20, r20
    16a2:	19 f0       	breq	.+6      	; 0x16aa <sendData+0x86>
                reportBuffer[2] = 0b00000100;
    16a4:	84 e0       	ldi	r24, 0x04	; 4
    16a6:	80 93 06 01 	sts	0x0106, r24

        reportBuffer[1] |= (data.plusOn << PLUS_BIT);
    16aa:	33 0f       	add	r19, r19
    16ac:	80 91 05 01 	lds	r24, 0x0105
    16b0:	83 2b       	or	r24, r19
    16b2:	80 93 05 01 	sts	0x0105, r24
        reportBuffer[0] |= (data.minusOn << MINUS_BIT);
    16b6:	92 95       	swap	r25
    16b8:	99 0f       	add	r25, r25
    16ba:	90 7e       	andi	r25, 0xE0	; 224
    16bc:	80 91 04 01 	lds	r24, 0x0104
    16c0:	89 2b       	or	r24, r25
    16c2:	80 93 04 01 	sts	0x0104, r24

        //Then we finish off some USB stuff.
        wdt_reset();  //Reset the watchdog timer
    16c6:	a8 95       	wdr
        usbPoll();    //USB poll - must be called at least once per 10ms
    16c8:	0e 94 a8 0b 	call	0x1750	; 0x1750 <usbPoll>

        // Now, regardless of mode, we have to send the data to the 
        // USB controlling library from the buffer we've been building
        if(usbInterruptIsReady())
    16cc:	80 91 16 01 	lds	r24, 0x0116
    16d0:	84 ff       	sbrs	r24, 4
    16d2:	05 c0       	rjmp	.+10     	; 0x16de <sendData+0xba>
        {
            /* called after every poll of the interrupt endpoint */
            usbSetInterrupt((void *)&reportBuffer, sizeof(reportBuffer));
    16d4:	84 e0       	ldi	r24, 0x04	; 4
    16d6:	91 e0       	ldi	r25, 0x01	; 1
    16d8:	67 e0       	ldi	r22, 0x07	; 7
    16da:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <usbSetInterrupt>
        }
                

}
    16de:	2a 96       	adiw	r28, 0x0a	; 10
    16e0:	0f b6       	in	r0, 0x3f	; 63
    16e2:	f8 94       	cli
    16e4:	de bf       	out	0x3e, r29	; 62
    16e6:	0f be       	out	0x3f, r0	; 63
    16e8:	cd bf       	out	0x3d, r28	; 61
    16ea:	cf 91       	pop	r28
    16ec:	df 91       	pop	r29
    16ee:	1f 91       	pop	r17
    16f0:	0f 91       	pop	r16
    16f2:	08 95       	ret

000016f4 <startCommunication>:
	reportBuffer[5] = 0b10000000;
	reportBuffer[6] = 0b00000000;
*/

    // First, set up all the USB communication stuff
    wdt_enable(WDTO_1S);
    16f4:	2e e0       	ldi	r18, 0x0E	; 14
    16f6:	88 e1       	ldi	r24, 0x18	; 24
    16f8:	90 e0       	ldi	r25, 0x00	; 0
    16fa:	0f b6       	in	r0, 0x3f	; 63
    16fc:	f8 94       	cli
    16fe:	a8 95       	wdr
    1700:	80 93 60 00 	sts	0x0060, r24
    1704:	0f be       	out	0x3f, r0	; 63
    1706:	20 93 60 00 	sts	0x0060, r18
     * RESET status: all port bits are inputs without pull-up.
     * That's the way we need D+ and D-. Therefore we don't need any
     * additional hardware initialization.
     */

    usbInit();
    170a:	0e 94 97 0b 	call	0x172e	; 0x172e <usbInit>
    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
    170e:	54 9a       	sbi	0x0a, 4	; 10
    1710:	20 e0       	ldi	r18, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1712:	48 eb       	ldi	r20, 0xB8	; 184
    1714:	5b e0       	ldi	r21, 0x0B	; 11
    1716:	04 c0       	rjmp	.+8      	; 0x1720 <startCommunication+0x2c>
    uchar i = 0;
    while(--i){             /* fake USB disconnect for > 250 ms */
        wdt_reset();
    1718:	a8 95       	wdr
    171a:	ca 01       	movw	r24, r20
    171c:	01 97       	sbiw	r24, 0x01	; 1
    171e:	f1 f7       	brne	.-4      	; 0x171c <startCommunication+0x28>
     */

    usbInit();
    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
    uchar i = 0;
    while(--i){             /* fake USB disconnect for > 250 ms */
    1720:	21 50       	subi	r18, 0x01	; 1
    1722:	d1 f7       	brne	.-12     	; 0x1718 <startCommunication+0x24>
        wdt_reset();
        _delay_ms(1);
    }
    usbDeviceConnect();
    1724:	54 98       	cbi	0x0a, 4	; 10
    sei();
    1726:	78 94       	sei
	usbPoll();
    1728:	0e 94 a8 0b 	call	0x1750	; 0x1750 <usbPoll>
}
    172c:	08 95       	ret

0000172e <usbInit>:
/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbInit(void)
{
#if USB_INTR_CFG_SET != 0
    USB_INTR_CFG |= USB_INTR_CFG_SET;
    172e:	e9 e6       	ldi	r30, 0x69	; 105
    1730:	f0 e0       	ldi	r31, 0x00	; 0
    1732:	80 81       	ld	r24, Z
    1734:	8c 60       	ori	r24, 0x0C	; 12
    1736:	80 83       	st	Z, r24
#endif
#if USB_INTR_CFG_CLR != 0
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
    1738:	e9 9a       	sbi	0x1d, 1	; 29
/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    173a:	8b e4       	ldi	r24, 0x4B	; 75
    173c:	80 93 17 01 	sts	0x0117, r24
#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    1740:	80 93 42 01 	sts	0x0142, r24
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
    usbResetDataToggling();
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    usbTxLen1 = USBPID_NAK;
    1744:	8a e5       	ldi	r24, 0x5A	; 90
    1746:	80 93 16 01 	sts	0x0116, r24
#if USB_CFG_HAVE_INTRIN_ENDPOINT3
    usbTxLen3 = USBPID_NAK;
    174a:	80 93 41 01 	sts	0x0141, r24
#endif
#endif
}
    174e:	08 95       	ret

00001750 <usbPoll>:
}

/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbPoll(void)
{
    1750:	1f 93       	push	r17
    1752:	cf 93       	push	r28
    1754:	df 93       	push	r29
schar   len;
uchar   i;

    len = usbRxLen - 3;
    1756:	90 91 27 01 	lds	r25, 0x0127
    175a:	93 50       	subi	r25, 0x03	; 3
    if(len >= 0){
    175c:	97 fd       	sbrc	r25, 7
    175e:	a8 c0       	rjmp	.+336    	; 0x18b0 <usbPoll+0x160>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
    1760:	20 91 24 01 	lds	r18, 0x0124
    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
        usbFunctionWriteOut(data, len);
        return;
    }
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
    1764:	80 91 23 01 	lds	r24, 0x0123
    1768:	8d 32       	cpi	r24, 0x2D	; 45
    176a:	09 f0       	breq	.+2      	; 0x176e <usbPoll+0x1e>
    176c:	9f c0       	rjmp	.+318    	; 0x18ac <usbPoll+0x15c>
        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
    176e:	98 30       	cpi	r25, 0x08	; 8
    1770:	09 f0       	breq	.+2      	; 0x1774 <usbPoll+0x24>
    1772:	9c c0       	rjmp	.+312    	; 0x18ac <usbPoll+0x15c>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
    1774:	cc e0       	ldi	r28, 0x0C	; 12
    1776:	d0 e0       	ldi	r29, 0x00	; 0
    1778:	c2 1b       	sub	r28, r18
    177a:	d1 09       	sbc	r29, r1
    177c:	c5 5d       	subi	r28, 0xD5	; 213
    177e:	de 4f       	sbci	r29, 0xFE	; 254
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
            return;
        usbMsgLen_t replyLen;
        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
    1780:	83 ec       	ldi	r24, 0xC3	; 195
    1782:	80 93 0b 01 	sts	0x010B, r24
        usbTxLen = USBPID_NAK;              /* abort pending transmit */
    1786:	8a e5       	ldi	r24, 0x5A	; 90
    1788:	80 93 00 01 	sts	0x0100, r24
        usbMsgFlags = 0;
    178c:	10 92 03 01 	sts	0x0103, r1
        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
    1790:	88 81       	ld	r24, Y
    1792:	80 76       	andi	r24, 0x60	; 96
    1794:	29 f0       	breq	.+10     	; 0x17a0 <usbPoll+0x50>
            replyLen = usbFunctionSetup(data);
    1796:	ce 01       	movw	r24, r28
    1798:	0e 94 ef 0a 	call	0x15de	; 0x15de <usbFunctionSetup>
    179c:	28 2f       	mov	r18, r24
    179e:	7d c0       	rjmp	.+250    	; 0x189a <usbPoll+0x14a>
 * standard requests instead of class and custom requests.
 */
static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
{
uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffer */
uchar   value = rq->wValue.bytes[0];
    17a0:	9a 81       	ldd	r25, Y+2	; 0x02
#if USB_CFG_IMPLEMENT_HALT
uchar   index = rq->wIndex.bytes[0];
#endif

    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
    17a2:	10 92 14 01 	sts	0x0114, r1
    SWITCH_START(rq->bRequest)
    17a6:	89 81       	ldd	r24, Y+1	; 0x01
    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
    17a8:	88 23       	and	r24, r24
    17aa:	21 f4       	brne	.+8      	; 0x17b4 <usbPoll+0x64>
            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
#if USB_CFG_IMPLEMENT_HALT
        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
            dataPtr[0] = usbTxLen1 == USBPID_STALL;
#endif
        dataPtr[1] = 0;
    17ac:	10 92 15 01 	sts	0x0115, r1
    17b0:	22 e0       	ldi	r18, 0x02	; 2
    17b2:	6d c0       	rjmp	.+218    	; 0x188e <usbPoll+0x13e>
        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
            usbResetDataToggling();
        }
#endif
    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
    17b4:	85 30       	cpi	r24, 0x05	; 5
    17b6:	19 f4       	brne	.+6      	; 0x17be <usbPoll+0x6e>
        usbNewDeviceAddr = value;
    17b8:	90 93 28 01 	sts	0x0128, r25
    17bc:	67 c0       	rjmp	.+206    	; 0x188c <usbPoll+0x13c>
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
    17be:	86 30       	cpi	r24, 0x06	; 6
    17c0:	09 f0       	breq	.+2      	; 0x17c4 <usbPoll+0x74>
    17c2:	4e c0       	rjmp	.+156    	; 0x1860 <usbPoll+0x110>
static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
{
usbMsgLen_t len = 0;
uchar       flags = USB_FLG_MSGPTR_IS_ROM;

    SWITCH_START(rq->wValue.bytes[1])
    17c4:	8b 81       	ldd	r24, Y+3	; 0x03
    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
    17c6:	81 30       	cpi	r24, 0x01	; 1
    17c8:	41 f4       	brne	.+16     	; 0x17da <usbPoll+0x8a>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
    17ca:	86 ee       	ldi	r24, 0xE6	; 230
    17cc:	90 e0       	ldi	r25, 0x00	; 0
    17ce:	90 93 26 01 	sts	0x0126, r25
    17d2:	80 93 25 01 	sts	0x0125, r24
    17d6:	22 e1       	ldi	r18, 0x12	; 18
    17d8:	3f c0       	rjmp	.+126    	; 0x1858 <usbPoll+0x108>
    SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
    17da:	82 30       	cpi	r24, 0x02	; 2
    17dc:	41 f4       	brne	.+16     	; 0x17ee <usbPoll+0x9e>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
    17de:	88 ef       	ldi	r24, 0xF8	; 248
    17e0:	90 e0       	ldi	r25, 0x00	; 0
    17e2:	90 93 26 01 	sts	0x0126, r25
    17e6:	80 93 25 01 	sts	0x0125, r24
    17ea:	29 e2       	ldi	r18, 0x29	; 41
    17ec:	35 c0       	rjmp	.+106    	; 0x1858 <usbPoll+0x108>
    SWITCH_CASE(USBDESCR_STRING)    /* 3 */
    17ee:	83 30       	cpi	r24, 0x03	; 3
    17f0:	f1 f4       	brne	.+60     	; 0x182e <usbPoll+0xde>
        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
            flags = 0;
        len = usbFunctionDescriptor(rq);
#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
        SWITCH_START(rq->wValue.bytes[0])
        SWITCH_CASE(0)
    17f2:	99 23       	and	r25, r25
    17f4:	41 f4       	brne	.+16     	; 0x1806 <usbPoll+0xb6>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
    17f6:	82 eb       	ldi	r24, 0xB2	; 178
    17f8:	90 e0       	ldi	r25, 0x00	; 0
    17fa:	90 93 26 01 	sts	0x0126, r25
    17fe:	80 93 25 01 	sts	0x0125, r24
    1802:	24 e0       	ldi	r18, 0x04	; 4
    1804:	29 c0       	rjmp	.+82     	; 0x1858 <usbPoll+0x108>
        SWITCH_CASE(1)
    1806:	91 30       	cpi	r25, 0x01	; 1
    1808:	41 f4       	brne	.+16     	; 0x181a <usbPoll+0xca>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
    180a:	86 eb       	ldi	r24, 0xB6	; 182
    180c:	90 e0       	ldi	r25, 0x00	; 0
    180e:	90 93 26 01 	sts	0x0126, r25
    1812:	80 93 25 01 	sts	0x0125, r24
    1816:	2c e1       	ldi	r18, 0x1C	; 28
    1818:	1f c0       	rjmp	.+62     	; 0x1858 <usbPoll+0x108>
        SWITCH_CASE(2)
    181a:	92 30       	cpi	r25, 0x02	; 2
    181c:	e1 f4       	brne	.+56     	; 0x1856 <usbPoll+0x106>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
    181e:	82 ed       	ldi	r24, 0xD2	; 210
    1820:	90 e0       	ldi	r25, 0x00	; 0
    1822:	90 93 26 01 	sts	0x0126, r25
    1826:	80 93 25 01 	sts	0x0125, r24
    182a:	24 e1       	ldi	r18, 0x14	; 20
    182c:	15 c0       	rjmp	.+42     	; 0x1858 <usbPoll+0x108>
                len = usbFunctionDescriptor(rq);
            }
        SWITCH_END
#endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
#if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
    SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
    182e:	81 32       	cpi	r24, 0x21	; 33
    1830:	41 f4       	brne	.+16     	; 0x1842 <usbPoll+0xf2>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
    1832:	8a e0       	ldi	r24, 0x0A	; 10
    1834:	91 e0       	ldi	r25, 0x01	; 1
    1836:	90 93 26 01 	sts	0x0126, r25
    183a:	80 93 25 01 	sts	0x0125, r24
    183e:	29 e0       	ldi	r18, 0x09	; 9
    1840:	0b c0       	rjmp	.+22     	; 0x1858 <usbPoll+0x108>
    SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
    1842:	82 32       	cpi	r24, 0x22	; 34
    1844:	41 f4       	brne	.+16     	; 0x1856 <usbPoll+0x106>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
    1846:	88 e6       	ldi	r24, 0x68	; 104
    1848:	90 e0       	ldi	r25, 0x00	; 0
    184a:	90 93 26 01 	sts	0x0126, r25
    184e:	80 93 25 01 	sts	0x0125, r24
    1852:	2a e4       	ldi	r18, 0x4A	; 74
    1854:	01 c0       	rjmp	.+2      	; 0x1858 <usbPoll+0x108>
    1856:	20 e0       	ldi	r18, 0x00	; 0
    SWITCH_DEFAULT
        if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
            len = usbFunctionDescriptor(rq);
        }
    SWITCH_END
    usbMsgFlags = flags;
    1858:	80 e4       	ldi	r24, 0x40	; 64
    185a:	80 93 03 01 	sts	0x0103, r24
    185e:	1d c0       	rjmp	.+58     	; 0x189a <usbPoll+0x14a>
        usbNewDeviceAddr = value;
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
        len = usbDriverDescriptor(rq);
        goto skipMsgPtrAssignment;
    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
    1860:	88 30       	cpi	r24, 0x08	; 8
    1862:	21 f4       	brne	.+8      	; 0x186c <usbPoll+0x11c>
    1864:	21 e0       	ldi	r18, 0x01	; 1
    1866:	8a e2       	ldi	r24, 0x2A	; 42
    1868:	91 e0       	ldi	r25, 0x01	; 1
    186a:	13 c0       	rjmp	.+38     	; 0x1892 <usbPoll+0x142>
        dataPtr = &usbConfiguration;  /* send current configuration value */
        len = 1;
    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
    186c:	89 30       	cpi	r24, 0x09	; 9
    186e:	19 f4       	brne	.+6      	; 0x1876 <usbPoll+0x126>
        usbConfiguration = value;
    1870:	90 93 2a 01 	sts	0x012A, r25
    1874:	0b c0       	rjmp	.+22     	; 0x188c <usbPoll+0x13c>
        usbResetStall();
    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
    1876:	8a 30       	cpi	r24, 0x0A	; 10
    1878:	11 f4       	brne	.+4      	; 0x187e <usbPoll+0x12e>
    187a:	21 e0       	ldi	r18, 0x01	; 1
    187c:	08 c0       	rjmp	.+16     	; 0x188e <usbPoll+0x13e>
        len = 1;
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
    187e:	8b 30       	cpi	r24, 0x0B	; 11
    1880:	29 f4       	brne	.+10     	; 0x188c <usbPoll+0x13c>
/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    1882:	8b e4       	ldi	r24, 0x4B	; 75
    1884:	80 93 17 01 	sts	0x0117, r24
#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    1888:	80 93 42 01 	sts	0x0142, r24
    188c:	20 e0       	ldi	r18, 0x00	; 0
    188e:	84 e1       	ldi	r24, 0x14	; 20
    1890:	91 e0       	ldi	r25, 0x01	; 1
        usbResetStall();
#endif
    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
        /* Should we add an optional hook here? */
    SWITCH_END
    usbMsgPtr = dataPtr;
    1892:	90 93 26 01 	sts	0x0126, r25
    1896:	80 93 25 01 	sts	0x0125, r24
            }
            usbMsgFlags = USB_FLG_USE_USER_RW;
        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */
#endif
        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */
    189a:	8f 81       	ldd	r24, Y+7	; 0x07
    189c:	88 23       	and	r24, r24
    189e:	21 f4       	brne	.+8      	; 0x18a8 <usbPoll+0x158>
    18a0:	8e 81       	ldd	r24, Y+6	; 0x06
    18a2:	82 17       	cp	r24, r18
    18a4:	08 f4       	brcc	.+2      	; 0x18a8 <usbPoll+0x158>
    18a6:	28 2f       	mov	r18, r24
                replyLen = rq->wLength.bytes[0];
        }else{
            if(replyLen > rq->wLength.word)     /* limit length to max */
                replyLen = rq->wLength.word;
        }
        usbMsgLen = replyLen;
    18a8:	20 93 01 01 	sts	0x0101, r18
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
#if USB_CFG_HAVE_FLOWCONTROL
        if(usbRxLen > 0)    /* only mark as available if not inactivated */
            usbRxLen = 0;
#else
        usbRxLen = 0;       /* mark rx buffer as available */
    18ac:	10 92 27 01 	sts	0x0127, r1
#endif
    }
    if(usbTxLen & 0x10){    /* transmit system idle */
    18b0:	80 91 00 01 	lds	r24, 0x0100
    18b4:	84 ff       	sbrs	r24, 4
    18b6:	4a c0       	rjmp	.+148    	; 0x194c <usbPoll+0x1fc>
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
    18b8:	80 91 01 01 	lds	r24, 0x0101
    18bc:	8f 3f       	cpi	r24, 0xFF	; 255
    18be:	09 f4       	brne	.+2      	; 0x18c2 <usbPoll+0x172>
    18c0:	45 c0       	rjmp	.+138    	; 0x194c <usbPoll+0x1fc>
    18c2:	18 2f       	mov	r17, r24
    18c4:	89 30       	cpi	r24, 0x09	; 9
    18c6:	08 f0       	brcs	.+2      	; 0x18ca <usbPoll+0x17a>
    18c8:	18 e0       	ldi	r17, 0x08	; 8
uchar       len;

    wantLen = usbMsgLen;
    if(wantLen > 8)
        wantLen = 8;
    usbMsgLen -= wantLen;
    18ca:	81 1b       	sub	r24, r17
    18cc:	80 93 01 01 	sts	0x0101, r24
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    18d0:	80 91 0b 01 	lds	r24, 0x010B
    18d4:	98 e8       	ldi	r25, 0x88	; 136
    18d6:	89 27       	eor	r24, r25
    18d8:	80 93 0b 01 	sts	0x010B, r24
/* This function is similar to usbFunctionRead(), but it's also called for
 * data handled automatically by the driver (e.g. descriptor reads).
 */
static uchar usbDeviceRead(uchar *data, uchar len)
{
    if(len > 0){    /* don't bother app with 0 sized reads */
    18dc:	11 23       	and	r17, r17
    18de:	41 f1       	breq	.+80     	; 0x1930 <usbPoll+0x1e0>
        if(usbMsgFlags & USB_FLG_USE_USER_RW){
            len = usbFunctionRead(data, len);
        }else
#endif
        {
            uchar i = len, *r = usbMsgPtr;
    18e0:	20 91 25 01 	lds	r18, 0x0125
    18e4:	30 91 26 01 	lds	r19, 0x0126
            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
    18e8:	80 91 03 01 	lds	r24, 0x0103
    18ec:	86 ff       	sbrs	r24, 6
    18ee:	0d c0       	rjmp	.+26     	; 0x190a <usbPoll+0x1ba>
    18f0:	ac e0       	ldi	r26, 0x0C	; 12
    18f2:	b1 e0       	ldi	r27, 0x01	; 1
    18f4:	80 e0       	ldi	r24, 0x00	; 0
    18f6:	90 e0       	ldi	r25, 0x00	; 0
                do{
                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */
    18f8:	f9 01       	movw	r30, r18
    18fa:	e8 0f       	add	r30, r24
    18fc:	f9 1f       	adc	r31, r25
    18fe:	e4 91       	lpm	r30, Z+
                    *data++ = c;
    1900:	ed 93       	st	X+, r30
    1902:	01 96       	adiw	r24, 0x01	; 1
                    r++;
                }while(--i);
    1904:	18 17       	cp	r17, r24
    1906:	c1 f7       	brne	.-16     	; 0x18f8 <usbPoll+0x1a8>
    1908:	08 c0       	rjmp	.+16     	; 0x191a <usbPoll+0x1ca>
    190a:	d9 01       	movw	r26, r18
    190c:	91 2f       	mov	r25, r17
    190e:	ec e0       	ldi	r30, 0x0C	; 12
    1910:	f1 e0       	ldi	r31, 0x01	; 1
            }else{  /* RAM data */
                do{
                    *data++ = *r++;
    1912:	8d 91       	ld	r24, X+
    1914:	81 93       	st	Z+, r24
                }while(--i);
    1916:	91 50       	subi	r25, 0x01	; 1
    1918:	e1 f7       	brne	.-8      	; 0x1912 <usbPoll+0x1c2>
    191a:	11 50       	subi	r17, 0x01	; 1
    191c:	81 2f       	mov	r24, r17
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	1f 5f       	subi	r17, 0xFF	; 255
    1922:	01 96       	adiw	r24, 0x01	; 1
    1924:	82 0f       	add	r24, r18
    1926:	93 1f       	adc	r25, r19
            }
            usbMsgPtr = r;
    1928:	90 93 26 01 	sts	0x0126, r25
    192c:	80 93 25 01 	sts	0x0125, r24
        wantLen = 8;
    usbMsgLen -= wantLen;
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    len = usbDeviceRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
        usbCrc16Append(&usbTxBuf[1], len);
    1930:	8c e0       	ldi	r24, 0x0C	; 12
    1932:	91 e0       	ldi	r25, 0x01	; 1
    1934:	61 2f       	mov	r22, r17
    1936:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <usbCrc16Append>
        len += 4;           /* length including sync byte */
    193a:	61 2f       	mov	r22, r17
    193c:	6c 5f       	subi	r22, 0xFC	; 252
        if(len < 12)        /* a partial package identifies end of message */
    193e:	6c 30       	cpi	r22, 0x0C	; 12
    1940:	19 f0       	breq	.+6      	; 0x1948 <usbPoll+0x1f8>
            usbMsgLen = USB_NO_MSG;
    1942:	8f ef       	ldi	r24, 0xFF	; 255
    1944:	80 93 01 01 	sts	0x0101, r24
    }else{
        len = USBPID_STALL;   /* stall the endpoint */
        usbMsgLen = USB_NO_MSG;
    }
    usbTxLen = len;
    1948:	60 93 00 01 	sts	0x0100, r22
    194c:	94 e1       	ldi	r25, 0x14	; 20
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 20; i > 0; i--){
        uchar usbLineStatus = USBIN & USBMASK;
    194e:	89 b1       	in	r24, 0x09	; 9
        if(usbLineStatus != 0)  /* SE0 has ended */
    1950:	88 71       	andi	r24, 0x18	; 24
    1952:	31 f4       	brne	.+12     	; 0x1960 <usbPoll+0x210>
    if(usbTxLen & 0x10){    /* transmit system idle */
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 20; i > 0; i--){
    1954:	91 50       	subi	r25, 0x01	; 1
    1956:	d9 f7       	brne	.-10     	; 0x194e <usbPoll+0x1fe>
        uchar usbLineStatus = USBIN & USBMASK;
        if(usbLineStatus != 0)  /* SE0 has ended */
            goto isNotReset;
    }
    /* RESET condition, called multiple times during reset */
    usbNewDeviceAddr = 0;
    1958:	10 92 28 01 	sts	0x0128, r1
    usbDeviceAddr = 0;
    195c:	10 92 22 01 	sts	0x0122, r1
    usbResetStall();
    DBG1(0xff, 0, 0);
isNotReset:
    usbHandleResetHook(i);
}
    1960:	df 91       	pop	r29
    1962:	cf 91       	pop	r28
    1964:	1f 91       	pop	r17
    1966:	08 95       	ret

00001968 <usbSetInterrupt3>:
}
#endif

#if USB_CFG_HAVE_INTRIN_ENDPOINT3
USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
{
    1968:	1f 93       	push	r17
    196a:	dc 01       	movw	r26, r24
    196c:	16 2f       	mov	r17, r22

#if USB_CFG_IMPLEMENT_HALT
    if(usbTxLen1 == USBPID_STALL)
        return;
#endif
    if(txStatus->len & 0x10){   /* packet buffer was empty */
    196e:	80 91 41 01 	lds	r24, 0x0141
    1972:	84 ff       	sbrs	r24, 4
    1974:	07 c0       	rjmp	.+14     	; 0x1984 <usbSetInterrupt3+0x1c>
        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
    1976:	80 91 42 01 	lds	r24, 0x0142
    197a:	98 e8       	ldi	r25, 0x88	; 136
    197c:	89 27       	eor	r24, r25
    197e:	80 93 42 01 	sts	0x0142, r24
    1982:	03 c0       	rjmp	.+6      	; 0x198a <usbSetInterrupt3+0x22>
    }else{
        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
    1984:	8a e5       	ldi	r24, 0x5A	; 90
    1986:	80 93 41 01 	sts	0x0141, r24
    198a:	91 2f       	mov	r25, r17
    198c:	e3 e4       	ldi	r30, 0x43	; 67
    198e:	f1 e0       	ldi	r31, 0x01	; 1
    }
    p = txStatus->buffer + 1;
    i = len;
    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
        *p++ = *data++;
    1990:	8d 91       	ld	r24, X+
    1992:	81 93       	st	Z+, r24
    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
    1994:	91 50       	subi	r25, 0x01	; 1
    1996:	e1 f7       	brne	.-8      	; 0x1990 <usbSetInterrupt3+0x28>
    usbCrc16Append(&txStatus->buffer[1], len);
    1998:	83 e4       	ldi	r24, 0x43	; 67
    199a:	91 e0       	ldi	r25, 0x01	; 1
    199c:	61 2f       	mov	r22, r17
    199e:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <usbCrc16Append>
    txStatus->len = len + 4;    /* len must be given including sync byte */
    19a2:	1c 5f       	subi	r17, 0xFC	; 252
    19a4:	10 93 41 01 	sts	0x0141, r17

#if USB_CFG_HAVE_INTRIN_ENDPOINT3
USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
{
    usbGenericSetInterrupt(data, len, &usbTxStatus3);
}
    19a8:	1f 91       	pop	r17
    19aa:	08 95       	ret

000019ac <usbSetInterrupt>:
    txStatus->len = len + 4;    /* len must be given including sync byte */
    DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
}

USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
{
    19ac:	1f 93       	push	r17
    19ae:	dc 01       	movw	r26, r24
    19b0:	16 2f       	mov	r17, r22

#if USB_CFG_IMPLEMENT_HALT
    if(usbTxLen1 == USBPID_STALL)
        return;
#endif
    if(txStatus->len & 0x10){   /* packet buffer was empty */
    19b2:	80 91 16 01 	lds	r24, 0x0116
    19b6:	84 ff       	sbrs	r24, 4
    19b8:	07 c0       	rjmp	.+14     	; 0x19c8 <usbSetInterrupt+0x1c>
        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
    19ba:	80 91 17 01 	lds	r24, 0x0117
    19be:	98 e8       	ldi	r25, 0x88	; 136
    19c0:	89 27       	eor	r24, r25
    19c2:	80 93 17 01 	sts	0x0117, r24
    19c6:	03 c0       	rjmp	.+6      	; 0x19ce <usbSetInterrupt+0x22>
    }else{
        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
    19c8:	8a e5       	ldi	r24, 0x5A	; 90
    19ca:	80 93 16 01 	sts	0x0116, r24
    19ce:	91 2f       	mov	r25, r17
    19d0:	e8 e1       	ldi	r30, 0x18	; 24
    19d2:	f1 e0       	ldi	r31, 0x01	; 1
    }
    p = txStatus->buffer + 1;
    i = len;
    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
        *p++ = *data++;
    19d4:	8d 91       	ld	r24, X+
    19d6:	81 93       	st	Z+, r24
    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
    19d8:	91 50       	subi	r25, 0x01	; 1
    19da:	e1 f7       	brne	.-8      	; 0x19d4 <usbSetInterrupt+0x28>
    usbCrc16Append(&txStatus->buffer[1], len);
    19dc:	88 e1       	ldi	r24, 0x18	; 24
    19de:	91 e0       	ldi	r25, 0x01	; 1
    19e0:	61 2f       	mov	r22, r17
    19e2:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <usbCrc16Append>
    txStatus->len = len + 4;    /* len must be given including sync byte */
    19e6:	1c 5f       	subi	r17, 0xFC	; 252
    19e8:	10 93 16 01 	sts	0x0116, r17
}

USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
{
    usbGenericSetInterrupt(data, len, &usbTxStatus1);
}
    19ec:	1f 91       	pop	r17
    19ee:	08 95       	ret

000019f0 <usbCrc16>:
    19f0:	a8 2f       	mov	r26, r24
    19f2:	b9 2f       	mov	r27, r25
    19f4:	80 e0       	ldi	r24, 0x00	; 0
    19f6:	90 e0       	ldi	r25, 0x00	; 0
    19f8:	41 e0       	ldi	r20, 0x01	; 1
    19fa:	50 ea       	ldi	r21, 0xA0	; 160
    19fc:	60 95       	com	r22
    19fe:	30 e0       	ldi	r19, 0x00	; 0
    1a00:	09 c0       	rjmp	.+18     	; 0x1a14 <usbCrcLoopEntry>

00001a02 <usbCrcByteLoop>:
    1a02:	2d 91       	ld	r18, X+
    1a04:	82 27       	eor	r24, r18

00001a06 <usbCrcBitLoop>:
    1a06:	97 95       	ror	r25
    1a08:	87 95       	ror	r24
    1a0a:	10 f0       	brcs	.+4      	; 0x1a10 <usbCrcNoXor>
    1a0c:	84 27       	eor	r24, r20
    1a0e:	95 27       	eor	r25, r21

00001a10 <usbCrcNoXor>:
    1a10:	30 5e       	subi	r19, 0xE0	; 224
    1a12:	c8 f3       	brcs	.-14     	; 0x1a06 <usbCrcBitLoop>

00001a14 <usbCrcLoopEntry>:
    1a14:	6f 5f       	subi	r22, 0xFF	; 255
    1a16:	a8 f3       	brcs	.-22     	; 0x1a02 <usbCrcByteLoop>

00001a18 <usbCrcReady>:
    1a18:	08 95       	ret

00001a1a <usbCrc16Append>:
    1a1a:	ea df       	rcall	.-44     	; 0x19f0 <usbCrc16>
    1a1c:	8d 93       	st	X+, r24
    1a1e:	9d 93       	st	X+, r25
    1a20:	08 95       	ret

00001a22 <__vector_2>:
    1a22:	cf 93       	push	r28
    1a24:	cf b7       	in	r28, 0x3f	; 63
    1a26:	cf 93       	push	r28

00001a28 <waitForJ>:
    1a28:	c3 95       	inc	r28
    1a2a:	4c 9b       	sbis	0x09, 4	; 9
    1a2c:	e9 f7       	brne	.-6      	; 0x1a28 <waitForJ>

00001a2e <waitForK>:
    1a2e:	4c 9b       	sbis	0x09, 4	; 9
    1a30:	09 c0       	rjmp	.+18     	; 0x1a44 <foundK>
    1a32:	4c 9b       	sbis	0x09, 4	; 9
    1a34:	07 c0       	rjmp	.+14     	; 0x1a44 <foundK>
    1a36:	4c 9b       	sbis	0x09, 4	; 9
    1a38:	05 c0       	rjmp	.+10     	; 0x1a44 <foundK>
    1a3a:	4c 9b       	sbis	0x09, 4	; 9
    1a3c:	03 c0       	rjmp	.+6      	; 0x1a44 <foundK>
    1a3e:	4c 9b       	sbis	0x09, 4	; 9
    1a40:	01 c0       	rjmp	.+2      	; 0x1a44 <foundK>
    1a42:	a3 c0       	rjmp	.+326    	; 0x1b8a <sofError>

00001a44 <foundK>:
    1a44:	df 93       	push	r29
    1a46:	c0 91 24 01 	lds	r28, 0x0124
    1a4a:	dd 27       	eor	r29, r29
    1a4c:	c5 5d       	subi	r28, 0xD5	; 213
    1a4e:	de 4f       	sbci	r29, 0xFE	; 254
    1a50:	4c 9b       	sbis	0x09, 4	; 9
    1a52:	02 c0       	rjmp	.+4      	; 0x1a58 <haveTwoBitsK>
    1a54:	df 91       	pop	r29
    1a56:	eb cf       	rjmp	.-42     	; 0x1a2e <waitForK>

00001a58 <haveTwoBitsK>:
    1a58:	2f 93       	push	r18
    1a5a:	0f 93       	push	r16
    1a5c:	1f 93       	push	r17
    1a5e:	09 b1       	in	r16, 0x09	; 9
    1a60:	2f ef       	ldi	r18, 0xFF	; 255
    1a62:	04 fb       	bst	r16, 4
    1a64:	20 f9       	bld	r18, 0
    1a66:	4f 93       	push	r20
    1a68:	3f 93       	push	r19
    1a6a:	19 b1       	in	r17, 0x09	; 9
    1a6c:	4f ef       	ldi	r20, 0xFF	; 255
    1a6e:	01 27       	eor	r16, r17
    1a70:	04 fb       	bst	r16, 4
    1a72:	21 f9       	bld	r18, 1
    1a74:	3b e0       	ldi	r19, 0x0B	; 11
    1a76:	31 c0       	rjmp	.+98     	; 0x1ada <rxbit2>

00001a78 <unstuff0>:
    1a78:	4e 7f       	andi	r20, 0xFE	; 254
    1a7a:	01 2f       	mov	r16, r17
    1a7c:	19 b1       	in	r17, 0x09	; 9
    1a7e:	21 60       	ori	r18, 0x01	; 1
    1a80:	28 c0       	rjmp	.+80     	; 0x1ad2 <didUnstuff0>

00001a82 <unstuff1>:
    1a82:	10 2f       	mov	r17, r16
    1a84:	4d 7f       	andi	r20, 0xFD	; 253
    1a86:	22 60       	ori	r18, 0x02	; 2
    1a88:	00 00       	nop
    1a8a:	09 b1       	in	r16, 0x09	; 9
    1a8c:	29 c0       	rjmp	.+82     	; 0x1ae0 <didUnstuff1>

00001a8e <unstuff2>:
    1a8e:	4b 7f       	andi	r20, 0xFB	; 251
    1a90:	24 60       	ori	r18, 0x04	; 4
    1a92:	01 2f       	mov	r16, r17
    1a94:	00 00       	nop
    1a96:	19 b1       	in	r17, 0x09	; 9
    1a98:	2b c0       	rjmp	.+86     	; 0x1af0 <didUnstuff2>

00001a9a <unstuff3>:
    1a9a:	19 b1       	in	r17, 0x09	; 9
    1a9c:	47 7f       	andi	r20, 0xF7	; 247
    1a9e:	28 60       	ori	r18, 0x08	; 8
    1aa0:	2a c0       	rjmp	.+84     	; 0x1af6 <didUnstuff3>

00001aa2 <unstuff4>:
    1aa2:	4f 7e       	andi	r20, 0xEF	; 239
    1aa4:	09 b1       	in	r16, 0x09	; 9
    1aa6:	20 61       	ori	r18, 0x10	; 16
    1aa8:	2c c0       	rjmp	.+88     	; 0x1b02 <didUnstuff4>

00001aaa <unstuff5>:
    1aaa:	4f 7d       	andi	r20, 0xDF	; 223
    1aac:	19 b1       	in	r17, 0x09	; 9
    1aae:	20 62       	ori	r18, 0x20	; 32
    1ab0:	2f c0       	rjmp	.+94     	; 0x1b10 <didUnstuff5>

00001ab2 <unstuff6>:
    1ab2:	4f 7b       	andi	r20, 0xBF	; 191
    1ab4:	09 b1       	in	r16, 0x09	; 9
    1ab6:	20 64       	ori	r18, 0x40	; 64
    1ab8:	32 c0       	rjmp	.+100    	; 0x1b1e <didUnstuff6>

00001aba <rxLoop>:
    1aba:	42 27       	eor	r20, r18
    1abc:	09 b1       	in	r16, 0x09	; 9
    1abe:	49 93       	st	Y+, r20
    1ac0:	4f ef       	ldi	r20, 0xFF	; 255
    1ac2:	00 00       	nop
    1ac4:	10 27       	eor	r17, r16
    1ac6:	14 fb       	bst	r17, 4
    1ac8:	20 f9       	bld	r18, 0
    1aca:	19 b1       	in	r17, 0x09	; 9
    1acc:	18 71       	andi	r17, 0x18	; 24
    1ace:	c9 f1       	breq	.+114    	; 0x1b42 <se0>
    1ad0:	29 7f       	andi	r18, 0xF9	; 249

00001ad2 <didUnstuff0>:
    1ad2:	91 f2       	breq	.-92     	; 0x1a78 <unstuff0>
    1ad4:	01 27       	eor	r16, r17
    1ad6:	04 fb       	bst	r16, 4
    1ad8:	21 f9       	bld	r18, 1

00001ada <rxbit2>:
    1ada:	09 b1       	in	r16, 0x09	; 9
    1adc:	23 7f       	andi	r18, 0xF3	; 243
    1ade:	89 f2       	breq	.-94     	; 0x1a82 <unstuff1>

00001ae0 <didUnstuff1>:
    1ae0:	31 50       	subi	r19, 0x01	; 1
    1ae2:	58 f1       	brcs	.+86     	; 0x1b3a <overflow>
    1ae4:	10 27       	eor	r17, r16
    1ae6:	14 fb       	bst	r17, 4
    1ae8:	22 f9       	bld	r18, 2
    1aea:	19 b1       	in	r17, 0x09	; 9
    1aec:	27 7e       	andi	r18, 0xE7	; 231
    1aee:	79 f2       	breq	.-98     	; 0x1a8e <unstuff2>

00001af0 <didUnstuff2>:
    1af0:	01 27       	eor	r16, r17
    1af2:	04 fb       	bst	r16, 4
    1af4:	23 f9       	bld	r18, 3

00001af6 <didUnstuff3>:
    1af6:	2f 7c       	andi	r18, 0xCF	; 207
    1af8:	81 f2       	breq	.-96     	; 0x1a9a <unstuff3>
    1afa:	09 b1       	in	r16, 0x09	; 9
    1afc:	10 27       	eor	r17, r16
    1afe:	14 fb       	bst	r17, 4
    1b00:	24 f9       	bld	r18, 4

00001b02 <didUnstuff4>:
    1b02:	2f 79       	andi	r18, 0x9F	; 159
    1b04:	71 f2       	breq	.-100    	; 0x1aa2 <unstuff4>
    1b06:	00 c0       	rjmp	.+0      	; 0x1b08 <didUnstuff4+0x6>
    1b08:	19 b1       	in	r17, 0x09	; 9
    1b0a:	01 27       	eor	r16, r17
    1b0c:	04 fb       	bst	r16, 4
    1b0e:	25 f9       	bld	r18, 5

00001b10 <didUnstuff5>:
    1b10:	2f 73       	andi	r18, 0x3F	; 63
    1b12:	59 f2       	breq	.-106    	; 0x1aaa <unstuff5>
    1b14:	00 c0       	rjmp	.+0      	; 0x1b16 <didUnstuff5+0x6>
    1b16:	09 b1       	in	r16, 0x09	; 9
    1b18:	10 27       	eor	r17, r16
    1b1a:	14 fb       	bst	r17, 4
    1b1c:	26 f9       	bld	r18, 6

00001b1e <didUnstuff6>:
    1b1e:	22 30       	cpi	r18, 0x02	; 2
    1b20:	40 f2       	brcs	.-112    	; 0x1ab2 <unstuff6>
    1b22:	00 c0       	rjmp	.+0      	; 0x1b24 <didUnstuff6+0x6>
    1b24:	19 b1       	in	r17, 0x09	; 9
    1b26:	01 27       	eor	r16, r17
    1b28:	04 fb       	bst	r16, 4
    1b2a:	27 f9       	bld	r18, 7

00001b2c <didUnstuff7>:
    1b2c:	24 30       	cpi	r18, 0x04	; 4
    1b2e:	28 f6       	brcc	.-118    	; 0x1aba <rxLoop>

00001b30 <unstuff7>:
    1b30:	4f 77       	andi	r20, 0x7F	; 127
    1b32:	20 68       	ori	r18, 0x80	; 128
    1b34:	19 b1       	in	r17, 0x09	; 9
    1b36:	00 00       	nop
    1b38:	f9 cf       	rjmp	.-14     	; 0x1b2c <didUnstuff7>

00001b3a <overflow>:
    1b3a:	12 e0       	ldi	r17, 0x02	; 2
    1b3c:	1c bb       	out	0x1c, r17	; 28

00001b3e <ignorePacket>:
    1b3e:	00 27       	eor	r16, r16
    1b40:	19 c0       	rjmp	.+50     	; 0x1b74 <handleSetupOrOut>

00001b42 <se0>:
    1b42:	3b 50       	subi	r19, 0x0B	; 11
    1b44:	31 95       	neg	r19
    1b46:	c3 1b       	sub	r28, r19
    1b48:	d0 40       	sbci	r29, 0x00	; 0
    1b4a:	12 e0       	ldi	r17, 0x02	; 2
    1b4c:	1c bb       	out	0x1c, r17	; 28
    1b4e:	08 81       	ld	r16, Y
    1b50:	03 3c       	cpi	r16, 0xC3	; 195
    1b52:	f9 f0       	breq	.+62     	; 0x1b92 <handleData>
    1b54:	0b 34       	cpi	r16, 0x4B	; 75
    1b56:	e9 f0       	breq	.+58     	; 0x1b92 <handleData>
    1b58:	20 91 22 01 	lds	r18, 0x0122
    1b5c:	19 81       	ldd	r17, Y+1	; 0x01
    1b5e:	11 0f       	add	r17, r17
    1b60:	12 13       	cpse	r17, r18
    1b62:	ed cf       	rjmp	.-38     	; 0x1b3e <ignorePacket>
    1b64:	4a 81       	ldd	r20, Y+2	; 0x02
    1b66:	44 1f       	adc	r20, r20
    1b68:	09 36       	cpi	r16, 0x69	; 105
    1b6a:	41 f1       	breq	.+80     	; 0x1bbc <handleIn>
    1b6c:	0d 32       	cpi	r16, 0x2D	; 45
    1b6e:	11 f0       	breq	.+4      	; 0x1b74 <handleSetupOrOut>
    1b70:	01 3e       	cpi	r16, 0xE1	; 225
    1b72:	29 f7       	brne	.-54     	; 0x1b3e <ignorePacket>

00001b74 <handleSetupOrOut>:
    1b74:	00 93 29 01 	sts	0x0129, r16

00001b78 <doReturn>:
    1b78:	3f 91       	pop	r19
    1b7a:	4f 91       	pop	r20
    1b7c:	1f 91       	pop	r17
    1b7e:	0f 91       	pop	r16
    1b80:	2f 91       	pop	r18
    1b82:	df 91       	pop	r29
    1b84:	cc b3       	in	r28, 0x1c	; 28
    1b86:	c1 fd       	sbrc	r28, 1
    1b88:	4f cf       	rjmp	.-354    	; 0x1a28 <waitForJ>

00001b8a <sofError>:
    1b8a:	cf 91       	pop	r28
    1b8c:	cf bf       	out	0x3f, r28	; 63
    1b8e:	cf 91       	pop	r28
    1b90:	18 95       	reti

00001b92 <handleData>:
    1b92:	20 91 29 01 	lds	r18, 0x0129
    1b96:	22 23       	and	r18, r18
    1b98:	79 f3       	breq	.-34     	; 0x1b78 <doReturn>
    1b9a:	10 91 27 01 	lds	r17, 0x0127
    1b9e:	11 23       	and	r17, r17
    1ba0:	c1 f5       	brne	.+112    	; 0x1c12 <sendNakAndReti>
    1ba2:	34 30       	cpi	r19, 0x04	; 4
    1ba4:	c2 f1       	brmi	.+112    	; 0x1c16 <sendAckAndReti>
    1ba6:	30 93 27 01 	sts	0x0127, r19
    1baa:	20 93 23 01 	sts	0x0123, r18
    1bae:	10 91 24 01 	lds	r17, 0x0124
    1bb2:	3b e0       	ldi	r19, 0x0B	; 11
    1bb4:	31 1b       	sub	r19, r17
    1bb6:	30 93 24 01 	sts	0x0124, r19
    1bba:	2d c0       	rjmp	.+90     	; 0x1c16 <sendAckAndReti>

00001bbc <handleIn>:
    1bbc:	00 91 27 01 	lds	r16, 0x0127
    1bc0:	01 30       	cpi	r16, 0x01	; 1
    1bc2:	3c f5       	brge	.+78     	; 0x1c12 <sendNakAndReti>
    1bc4:	0a e5       	ldi	r16, 0x5A	; 90
    1bc6:	4f 70       	andi	r20, 0x0F	; 15
    1bc8:	49 f4       	brne	.+18     	; 0x1bdc <handleIn1>
    1bca:	30 91 00 01 	lds	r19, 0x0100
    1bce:	34 fd       	sbrc	r19, 4
    1bd0:	24 c0       	rjmp	.+72     	; 0x1c1a <sendCntAndReti>
    1bd2:	00 93 00 01 	sts	0x0100, r16
    1bd6:	cb e0       	ldi	r28, 0x0B	; 11
    1bd8:	d1 e0       	ldi	r29, 0x01	; 1
    1bda:	23 c0       	rjmp	.+70     	; 0x1c22 <usbSendAndReti>

00001bdc <handleIn1>:
    1bdc:	41 35       	cpi	r20, 0x51	; 81
    1bde:	49 f0       	breq	.+18     	; 0x1bf2 <handleIn3>
    1be0:	30 91 16 01 	lds	r19, 0x0116
    1be4:	34 fd       	sbrc	r19, 4
    1be6:	19 c0       	rjmp	.+50     	; 0x1c1a <sendCntAndReti>
    1be8:	00 93 16 01 	sts	0x0116, r16
    1bec:	c7 e1       	ldi	r28, 0x17	; 23
    1bee:	d1 e0       	ldi	r29, 0x01	; 1
    1bf0:	18 c0       	rjmp	.+48     	; 0x1c22 <usbSendAndReti>

00001bf2 <handleIn3>:
    1bf2:	30 91 41 01 	lds	r19, 0x0141
    1bf6:	34 fd       	sbrc	r19, 4
    1bf8:	10 c0       	rjmp	.+32     	; 0x1c1a <sendCntAndReti>
    1bfa:	00 93 41 01 	sts	0x0141, r16
    1bfe:	c2 e4       	ldi	r28, 0x42	; 66
    1c00:	d1 e0       	ldi	r29, 0x01	; 1
    1c02:	0f c0       	rjmp	.+30     	; 0x1c22 <usbSendAndReti>

00001c04 <stuffN1Delay>:
    1c04:	27 95       	ror	r18
    1c06:	a8 f4       	brcc	.+42     	; 0x1c32 <doExorN1>
    1c08:	51 50       	subi	r21, 0x01	; 1
    1c0a:	a9 f4       	brne	.+42     	; 0x1c36 <commonN1>
    1c0c:	22 0f       	add	r18, r18
    1c0e:	00 00       	nop
    1c10:	f9 cf       	rjmp	.-14     	; 0x1c04 <stuffN1Delay>

00001c12 <sendNakAndReti>:
    1c12:	4a e5       	ldi	r20, 0x5A	; 90
    1c14:	03 c0       	rjmp	.+6      	; 0x1c1c <usbSendX3>

00001c16 <sendAckAndReti>:
    1c16:	42 ed       	ldi	r20, 0xD2	; 210
    1c18:	01 c0       	rjmp	.+2      	; 0x1c1c <usbSendX3>

00001c1a <sendCntAndReti>:
    1c1a:	43 2f       	mov	r20, r19

00001c1c <usbSendX3>:
    1c1c:	c4 e1       	ldi	r28, 0x14	; 20
    1c1e:	d0 e0       	ldi	r29, 0x00	; 0
    1c20:	32 e0       	ldi	r19, 0x02	; 2

00001c22 <usbSendAndReti>:
    1c22:	1a b1       	in	r17, 0x0a	; 10
    1c24:	18 61       	ori	r17, 0x18	; 24
    1c26:	5c 9a       	sbi	0x0b, 4	; 11
    1c28:	1a b9       	out	0x0a, r17	; 10
    1c2a:	0b b1       	in	r16, 0x0b	; 11
    1c2c:	20 e4       	ldi	r18, 0x40	; 64
    1c2e:	18 e1       	ldi	r17, 0x18	; 24
    1c30:	5f 93       	push	r21

00001c32 <doExorN1>:
    1c32:	01 27       	eor	r16, r17
    1c34:	56 e0       	ldi	r21, 0x06	; 6

00001c36 <commonN1>:
    1c36:	0b b9       	out	0x0b, r16	; 11
    1c38:	27 95       	ror	r18
    1c3a:	20 f4       	brcc	.+8      	; 0x1c44 <doExorN2>
    1c3c:	51 50       	subi	r21, 0x01	; 1
    1c3e:	21 f4       	brne	.+8      	; 0x1c48 <commonN2>
    1c40:	22 0f       	add	r18, r18
    1c42:	f9 cf       	rjmp	.-14     	; 0x1c36 <commonN1>

00001c44 <doExorN2>:
    1c44:	01 27       	eor	r16, r17
    1c46:	56 e0       	ldi	r21, 0x06	; 6

00001c48 <commonN2>:
    1c48:	00 00       	nop
    1c4a:	3b 5a       	subi	r19, 0xAB	; 171
    1c4c:	0b b9       	out	0x0b, r16	; 11
    1c4e:	d0 f2       	brcs	.-76     	; 0x1c04 <stuffN1Delay>

00001c50 <stuff6Delay>:
    1c50:	27 95       	ror	r18
    1c52:	28 f4       	brcc	.+10     	; 0x1c5e <doExor6>
    1c54:	51 50       	subi	r21, 0x01	; 1
    1c56:	29 f4       	brne	.+10     	; 0x1c62 <common6>
    1c58:	22 0f       	add	r18, r18
    1c5a:	00 00       	nop
    1c5c:	f9 cf       	rjmp	.-14     	; 0x1c50 <stuff6Delay>

00001c5e <doExor6>:
    1c5e:	01 27       	eor	r16, r17
    1c60:	56 e0       	ldi	r21, 0x06	; 6

00001c62 <common6>:
    1c62:	27 95       	ror	r18
    1c64:	0b b9       	out	0x0b, r16	; 11
    1c66:	20 f4       	brcc	.+8      	; 0x1c70 <doExor7>
    1c68:	51 50       	subi	r21, 0x01	; 1
    1c6a:	21 f4       	brne	.+8      	; 0x1c74 <common7>
    1c6c:	22 0f       	add	r18, r18
    1c6e:	f9 cf       	rjmp	.-14     	; 0x1c62 <common6>

00001c70 <doExor7>:
    1c70:	01 27       	eor	r16, r17
    1c72:	56 e0       	ldi	r21, 0x06	; 6

00001c74 <common7>:
    1c74:	29 91       	ld	r18, Y+
    1c76:	33 23       	and	r19, r19
    1c78:	0b b9       	out	0x0b, r16	; 11
    1c7a:	21 f6       	brne	.-120    	; 0x1c04 <stuffN1Delay>
    1c7c:	07 7e       	andi	r16, 0xE7	; 231
    1c7e:	10 91 28 01 	lds	r17, 0x0128
    1c82:	11 0f       	add	r17, r17
    1c84:	c6 51       	subi	r28, 0x16	; 22
    1c86:	d0 40       	sbci	r29, 0x00	; 0
    1c88:	0b b9       	out	0x0b, r16	; 11
    1c8a:	11 f0       	breq	.+4      	; 0x1c90 <skipAddrAssign>
    1c8c:	10 93 22 01 	sts	0x0122, r17

00001c90 <skipAddrAssign>:
    1c90:	12 e0       	ldi	r17, 0x02	; 2
    1c92:	1c bb       	out	0x1c, r17	; 28
    1c94:	00 61       	ori	r16, 0x10	; 16
    1c96:	1a b1       	in	r17, 0x0a	; 10
    1c98:	17 7e       	andi	r17, 0xE7	; 231
    1c9a:	40 2f       	mov	r20, r16
    1c9c:	47 7e       	andi	r20, 0xE7	; 231
    1c9e:	5f 91       	pop	r21
    1ca0:	00 c0       	rjmp	.+0      	; 0x1ca2 <skipAddrAssign+0x12>
    1ca2:	00 c0       	rjmp	.+0      	; 0x1ca4 <skipAddrAssign+0x14>
    1ca4:	0b b9       	out	0x0b, r16	; 11
    1ca6:	1a b9       	out	0x0a, r17	; 10
    1ca8:	4b b9       	out	0x0b, r20	; 11
    1caa:	66 cf       	rjmp	.-308    	; 0x1b78 <doReturn>

00001cac <__eerd_block>:
    1cac:	a0 e0       	ldi	r26, 0x00	; 0
    1cae:	b0 e0       	ldi	r27, 0x00	; 0
    1cb0:	ec e5       	ldi	r30, 0x5C	; 92
    1cb2:	fe e0       	ldi	r31, 0x0E	; 14
    1cb4:	0c 94 98 0e 	jmp	0x1d30	; 0x1d30 <__prologue_saves__+0x14>
    1cb8:	7c 01       	movw	r14, r24
    1cba:	eb 01       	movw	r28, r22
    1cbc:	8a 01       	movw	r16, r20
    1cbe:	69 01       	movw	r12, r18
    1cc0:	09 c0       	rjmp	.+18     	; 0x1cd4 <__eerd_block+0x28>
    1cc2:	ce 01       	movw	r24, r28
    1cc4:	21 96       	adiw	r28, 0x01	; 1
    1cc6:	f6 01       	movw	r30, r12
    1cc8:	09 95       	icall
    1cca:	f7 01       	movw	r30, r14
    1ccc:	81 93       	st	Z+, r24
    1cce:	7f 01       	movw	r14, r30
    1cd0:	01 50       	subi	r16, 0x01	; 1
    1cd2:	10 40       	sbci	r17, 0x00	; 0
    1cd4:	01 15       	cp	r16, r1
    1cd6:	11 05       	cpc	r17, r1
    1cd8:	a1 f7       	brne	.-24     	; 0x1cc2 <__eerd_block+0x16>
    1cda:	cd b7       	in	r28, 0x3d	; 61
    1cdc:	de b7       	in	r29, 0x3e	; 62
    1cde:	e8 e0       	ldi	r30, 0x08	; 8
    1ce0:	0c 94 b4 0e 	jmp	0x1d68	; 0x1d68 <__epilogue_restores__+0x14>

00001ce4 <__eewr_block>:
    1ce4:	a0 e0       	ldi	r26, 0x00	; 0
    1ce6:	b0 e0       	ldi	r27, 0x00	; 0
    1ce8:	e8 e7       	ldi	r30, 0x78	; 120
    1cea:	fe e0       	ldi	r31, 0x0E	; 14
    1cec:	0c 94 98 0e 	jmp	0x1d30	; 0x1d30 <__prologue_saves__+0x14>
    1cf0:	ec 01       	movw	r28, r24
    1cf2:	7b 01       	movw	r14, r22
    1cf4:	8a 01       	movw	r16, r20
    1cf6:	69 01       	movw	r12, r18
    1cf8:	09 c0       	rjmp	.+18     	; 0x1d0c <__eewr_block+0x28>
    1cfa:	ce 01       	movw	r24, r28
    1cfc:	21 96       	adiw	r28, 0x01	; 1
    1cfe:	f7 01       	movw	r30, r14
    1d00:	61 91       	ld	r22, Z+
    1d02:	7f 01       	movw	r14, r30
    1d04:	f6 01       	movw	r30, r12
    1d06:	09 95       	icall
    1d08:	01 50       	subi	r16, 0x01	; 1
    1d0a:	10 40       	sbci	r17, 0x00	; 0
    1d0c:	01 15       	cp	r16, r1
    1d0e:	11 05       	cpc	r17, r1
    1d10:	a1 f7       	brne	.-24     	; 0x1cfa <__eewr_block+0x16>
    1d12:	cd b7       	in	r28, 0x3d	; 61
    1d14:	de b7       	in	r29, 0x3e	; 62
    1d16:	e8 e0       	ldi	r30, 0x08	; 8
    1d18:	0c 94 b4 0e 	jmp	0x1d68	; 0x1d68 <__epilogue_restores__+0x14>

00001d1c <__prologue_saves__>:
    1d1c:	2f 92       	push	r2
    1d1e:	3f 92       	push	r3
    1d20:	4f 92       	push	r4
    1d22:	5f 92       	push	r5
    1d24:	6f 92       	push	r6
    1d26:	7f 92       	push	r7
    1d28:	8f 92       	push	r8
    1d2a:	9f 92       	push	r9
    1d2c:	af 92       	push	r10
    1d2e:	bf 92       	push	r11
    1d30:	cf 92       	push	r12
    1d32:	df 92       	push	r13
    1d34:	ef 92       	push	r14
    1d36:	ff 92       	push	r15
    1d38:	0f 93       	push	r16
    1d3a:	1f 93       	push	r17
    1d3c:	cf 93       	push	r28
    1d3e:	df 93       	push	r29
    1d40:	cd b7       	in	r28, 0x3d	; 61
    1d42:	de b7       	in	r29, 0x3e	; 62
    1d44:	ca 1b       	sub	r28, r26
    1d46:	db 0b       	sbc	r29, r27
    1d48:	0f b6       	in	r0, 0x3f	; 63
    1d4a:	f8 94       	cli
    1d4c:	de bf       	out	0x3e, r29	; 62
    1d4e:	0f be       	out	0x3f, r0	; 63
    1d50:	cd bf       	out	0x3d, r28	; 61
    1d52:	09 94       	ijmp

00001d54 <__epilogue_restores__>:
    1d54:	2a 88       	ldd	r2, Y+18	; 0x12
    1d56:	39 88       	ldd	r3, Y+17	; 0x11
    1d58:	48 88       	ldd	r4, Y+16	; 0x10
    1d5a:	5f 84       	ldd	r5, Y+15	; 0x0f
    1d5c:	6e 84       	ldd	r6, Y+14	; 0x0e
    1d5e:	7d 84       	ldd	r7, Y+13	; 0x0d
    1d60:	8c 84       	ldd	r8, Y+12	; 0x0c
    1d62:	9b 84       	ldd	r9, Y+11	; 0x0b
    1d64:	aa 84       	ldd	r10, Y+10	; 0x0a
    1d66:	b9 84       	ldd	r11, Y+9	; 0x09
    1d68:	c8 84       	ldd	r12, Y+8	; 0x08
    1d6a:	df 80       	ldd	r13, Y+7	; 0x07
    1d6c:	ee 80       	ldd	r14, Y+6	; 0x06
    1d6e:	fd 80       	ldd	r15, Y+5	; 0x05
    1d70:	0c 81       	ldd	r16, Y+4	; 0x04
    1d72:	1b 81       	ldd	r17, Y+3	; 0x03
    1d74:	aa 81       	ldd	r26, Y+2	; 0x02
    1d76:	b9 81       	ldd	r27, Y+1	; 0x01
    1d78:	ce 0f       	add	r28, r30
    1d7a:	d1 1d       	adc	r29, r1
    1d7c:	0f b6       	in	r0, 0x3f	; 63
    1d7e:	f8 94       	cli
    1d80:	de bf       	out	0x3e, r29	; 62
    1d82:	0f be       	out	0x3f, r0	; 63
    1d84:	cd bf       	out	0x3d, r28	; 61
    1d86:	ed 01       	movw	r28, r26
    1d88:	08 95       	ret

00001d8a <_exit>:
    1d8a:	f8 94       	cli

00001d8c <__stop_program>:
    1d8c:	ff cf       	rjmp	.-2      	; 0x1d8c <__stop_program>
