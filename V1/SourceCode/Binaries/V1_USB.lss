
V1_USB.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  00001bb8  00001c6c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001bb8  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000004b  00800102  00800102  00001c6e  2**0
                  ALLOC
  3 .eeprom       00000172  00810000  00810000  00001c6e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 000000a0  00000000  00000000  00001de0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000035f  00000000  00000000  00001e80  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001a3e  00000000  00000000  000021df  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008eb  00000000  00000000  00003c1d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000161a  00000000  00000000  00004508  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000180  00000000  00000000  00005b24  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000815  00000000  00000000  00005ca4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000ae9  00000000  00000000  000064b9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000100  00000000  00000000  00006fa2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 91 00 	jmp	0x122	; 0x122 <__ctors_end>
       4:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
       8:	0c 94 3f 0c 	jmp	0x187e	; 0x187e <__vector_2>
       c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      10:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      14:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      18:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      1c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      20:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      24:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      28:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      2c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      30:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      34:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      38:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      3c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      40:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      44:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      48:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      4c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      50:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      54:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      58:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      5c:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      60:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>
      64:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__bad_interrupt>

00000068 <usbDescriptorHidReport>:
      68:	05 01 09 05 a1 01 15 00 25 01 35 00 45 01 75 01     ........%.5.E.u.
      78:	95 0d 05 09 19 01 29 0d 81 02 95 03 81 01 05 01     ......).........
      88:	25 07 46 3b 01 75 04 95 01 65 14 09 39 81 42 65     %.F;.u...e..9.Be
      98:	00 95 01 81 01 26 ff 00 46 ff 00 09 30 09 31 09     .....&..F...0.1.
      a8:	32 09 35 75 08 95 04 81 02 c0                       2.5u......

000000b2 <usbDescriptorString0>:
      b2:	04 03 09 04                                         ....

000000b6 <usbDescriptorStringVendor>:
      b6:	1c 03 4f 00 70 00 65 00 6e 00 43 00 68 00 6f 00     ..O.p.e.n.C.h.o.
      c6:	72 00 64 00 2e 00 6f 00 72 00 67 00                 r.d...o.r.g.

000000d2 <usbDescriptorStringDevice>:
      d2:	14 03 56 00 31 00 20 00 47 00 75 00 69 00 74 00     ..V.1. .G.u.i.t.
      e2:	61 00 72 00                                         a.r.

000000e6 <usbDescriptorDevice>:
      e6:	12 01 10 01 00 00 00 08 ba 12 00 02 00 01 01 02     ................
      f6:	00 01                                               ..

000000f8 <usbDescriptorConfiguration>:
      f8:	09 02 29 00 01 01 00 80 32 09 04 00 00 02 03 00     ..).....2.......
     108:	00 00 09 21 01 01 00 01 22 4a 00 07 05 81 03 08     ...!...."J......
     118:	00 0a 07 05 83 03 08 00 0a 00                       ..........

00000122 <__ctors_end>:
     122:	11 24       	eor	r1, r1
     124:	1f be       	out	0x3f, r1	; 63
     126:	cf ef       	ldi	r28, 0xFF	; 255
     128:	d4 e0       	ldi	r29, 0x04	; 4
     12a:	de bf       	out	0x3e, r29	; 62
     12c:	cd bf       	out	0x3d, r28	; 61

0000012e <__do_copy_data>:
     12e:	11 e0       	ldi	r17, 0x01	; 1
     130:	a0 e0       	ldi	r26, 0x00	; 0
     132:	b1 e0       	ldi	r27, 0x01	; 1
     134:	e8 eb       	ldi	r30, 0xB8	; 184
     136:	fb e1       	ldi	r31, 0x1B	; 27
     138:	02 c0       	rjmp	.+4      	; 0x13e <.do_copy_data_start>

0000013a <.do_copy_data_loop>:
     13a:	05 90       	lpm	r0, Z+
     13c:	0d 92       	st	X+, r0

0000013e <.do_copy_data_start>:
     13e:	a2 30       	cpi	r26, 0x02	; 2
     140:	b1 07       	cpc	r27, r17
     142:	d9 f7       	brne	.-10     	; 0x13a <.do_copy_data_loop>

00000144 <__do_clear_bss>:
     144:	11 e0       	ldi	r17, 0x01	; 1
     146:	a2 e0       	ldi	r26, 0x02	; 2
     148:	b1 e0       	ldi	r27, 0x01	; 1
     14a:	01 c0       	rjmp	.+2      	; 0x14e <.do_clear_bss_start>

0000014c <.do_clear_bss_loop>:
     14c:	1d 92       	st	X+, r1

0000014e <.do_clear_bss_start>:
     14e:	ad 34       	cpi	r26, 0x4D	; 77
     150:	b1 07       	cpc	r27, r17
     152:	e1 f7       	brne	.-8      	; 0x14c <.do_clear_bss_loop>
     154:	0e 94 20 01 	call	0x240	; 0x240 <main>
     158:	0c 94 da 0d 	jmp	0x1bb4	; 0x1bb4 <_exit>

0000015c <__bad_interrupt>:
     15c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000160 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
     160:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     162:	f9 99       	sbic	0x1f, 1	; 31
     164:	fe cf       	rjmp	.-4      	; 0x162 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     166:	32 bd       	out	0x22, r19	; 34
     168:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     16a:	f8 9a       	sbi	0x1f, 0	; 31
     16c:	80 b5       	in	r24, 0x20	; 32
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
     16e:	08 95       	ret

00000170 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
     170:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     172:	f9 99       	sbic	0x1f, 1	; 31
     174:	fe cf       	rjmp	.-4      	; 0x172 <eeprom_write_byte+0x2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     176:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     178:	32 bd       	out	0x22, r19	; 34
     17a:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
     17c:	60 bd       	out	0x20, r22	; 32

    __asm__ __volatile__ (
     17e:	0f b6       	in	r0, 0x3f	; 63
     180:	f8 94       	cli
     182:	fa 9a       	sbi	0x1f, 2	; 31
     184:	f9 9a       	sbi	0x1f, 1	; 31
     186:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
     188:	08 95       	ret

0000018a <readFrets>:
};

//readF reads the frets for a single string, and returns an int acting as a boolean array
//  telling which frets are being touched by the string.
int readFrets(int guitarString)
{
     18a:	1f 93       	push	r17
     18c:	cf 93       	push	r28
     18e:	df 93       	push	r29
  	string_port &= ~(1<<guitarString);  // Set the string LOW
     190:	9b b1       	in	r25, 0x0b	; 11
     192:	21 e0       	ldi	r18, 0x01	; 1
     194:	30 e0       	ldi	r19, 0x00	; 0
     196:	02 c0       	rjmp	.+4      	; 0x19c <readFrets+0x12>
     198:	22 0f       	add	r18, r18
     19a:	33 1f       	adc	r19, r19
     19c:	8a 95       	dec	r24
     19e:	e2 f7       	brpl	.-8      	; 0x198 <readFrets+0xe>
     1a0:	12 2f       	mov	r17, r18
     1a2:	82 2f       	mov	r24, r18
     1a4:	80 95       	com	r24
     1a6:	89 23       	and	r24, r25
     1a8:	8b b9       	out	0x0b, r24	; 11
     1aa:	84 e1       	ldi	r24, 0x14	; 20
     1ac:	90 e0       	ldi	r25, 0x00	; 0
	// Macro to as many NOPs as we want
	inline void doXnops(int x)
	{
		while (x >= 0)
		{
			nop();
     1ae:	00 00       	nop
			x--;
     1b0:	01 97       	sbiw	r24, 0x01	; 1
	#define nop() asm volatile("nop")

	// Macro to as many NOPs as we want
	inline void doXnops(int x)
	{
		while (x >= 0)
     1b2:	2f ef       	ldi	r18, 0xFF	; 255
     1b4:	8f 3f       	cpi	r24, 0xFF	; 255
     1b6:	92 07       	cpc	r25, r18
     1b8:	d1 f7       	brne	.-12     	; 0x1ae <readFrets+0x24>

	// Then we have to delay for a while, since right after the switch, the pin values
	// jump around a bit
	doXnops(20);	
	// Read the values on the frets
  	int i = fret_pin;               
     1ba:	83 b1       	in	r24, 0x03	; 3
	i = fret_pin;
     1bc:	83 b1       	in	r24, 0x03	; 3
	i = fret_pin;		// More delay funcitonality... without these delays, there is some bouncing
     1be:	83 b1       	in	r24, 0x03	; 3
	i = fret_pin;		// on the pins, so the read screws up.
     1c0:	83 b1       	in	r24, 0x03	; 3
	// Next, since the fret pin is zero if the a fret is grounded, we do a mask to isolate each pin from 
	//  the port, which will return a zero if pressed and non-zero if unpressed. So we ! that to get a 1 if
	//  the string touches that fret and a zero if it doesn't touch, which we then load into our storage 
	//  integer.

 	stringState |= ( (!(i & (1<<green_pin))) << 1); //green fret
     1c2:	81 fd       	sbrc	r24, 1
     1c4:	03 c0       	rjmp	.+6      	; 0x1cc <readFrets+0x42>
     1c6:	c2 e0       	ldi	r28, 0x02	; 2
     1c8:	d0 e0       	ldi	r29, 0x00	; 0
     1ca:	02 c0       	rjmp	.+4      	; 0x1d0 <readFrets+0x46>
     1cc:	c0 e0       	ldi	r28, 0x00	; 0
     1ce:	d0 e0       	ldi	r29, 0x00	; 0
 	stringState |= ( (!(i & (1<<red_pin))) << 2); //red fret
     1d0:	82 fd       	sbrc	r24, 2
     1d2:	03 c0       	rjmp	.+6      	; 0x1da <readFrets+0x50>
     1d4:	a4 e0       	ldi	r26, 0x04	; 4
     1d6:	b0 e0       	ldi	r27, 0x00	; 0
     1d8:	02 c0       	rjmp	.+4      	; 0x1de <readFrets+0x54>
     1da:	a0 e0       	ldi	r26, 0x00	; 0
     1dc:	b0 e0       	ldi	r27, 0x00	; 0
 	stringState |= ( (!(i & (1<<yellow_pin))) << 3); //yellow fret
     1de:	83 fd       	sbrc	r24, 3
     1e0:	03 c0       	rjmp	.+6      	; 0x1e8 <readFrets+0x5e>
     1e2:	e8 e0       	ldi	r30, 0x08	; 8
     1e4:	f0 e0       	ldi	r31, 0x00	; 0
     1e6:	02 c0       	rjmp	.+4      	; 0x1ec <readFrets+0x62>
     1e8:	e0 e0       	ldi	r30, 0x00	; 0
     1ea:	f0 e0       	ldi	r31, 0x00	; 0
 	stringState |= ( (!(i & (1<<blue_pin))) << 4); //blue fret
     1ec:	84 fd       	sbrc	r24, 4
     1ee:	03 c0       	rjmp	.+6      	; 0x1f6 <readFrets+0x6c>
     1f0:	60 e1       	ldi	r22, 0x10	; 16
     1f2:	70 e0       	ldi	r23, 0x00	; 0
     1f4:	02 c0       	rjmp	.+4      	; 0x1fa <readFrets+0x70>
     1f6:	60 e0       	ldi	r22, 0x00	; 0
     1f8:	70 e0       	ldi	r23, 0x00	; 0
 	stringState |= ( (!(i & (1<<orange_pin))) << 5); //orange fret
     1fa:	85 fd       	sbrc	r24, 5
     1fc:	03 c0       	rjmp	.+6      	; 0x204 <readFrets+0x7a>
     1fe:	40 e2       	ldi	r20, 0x20	; 32
     200:	50 e0       	ldi	r21, 0x00	; 0
     202:	02 c0       	rjmp	.+4      	; 0x208 <readFrets+0x7e>
     204:	40 e0       	ldi	r20, 0x00	; 0
     206:	50 e0       	ldi	r21, 0x00	; 0

	// Also, if we strummed a string, hold that in the 'zeroth' fret
	i = pick_pin;
     208:	26 b1       	in	r18, 0x06	; 6
	//  the port, which will return a zero if pressed and non-zero if unpressed. So we ! that to get a 1 if
	//  the string touches that fret and a zero if it doesn't touch, which we then load into our storage 
	//  integer.

 	stringState |= ( (!(i & (1<<green_pin))) << 1); //green fret
 	stringState |= ( (!(i & (1<<red_pin))) << 2); //red fret
     20a:	30 e0       	ldi	r19, 0x00	; 0
     20c:	36 95       	lsr	r19
     20e:	27 95       	ror	r18
     210:	36 95       	lsr	r19
     212:	27 95       	ror	r18
     214:	20 95       	com	r18
     216:	30 95       	com	r19
     218:	21 70       	andi	r18, 0x01	; 1
     21a:	30 70       	andi	r19, 0x00	; 0
     21c:	2c 2b       	or	r18, r28
     21e:	3d 2b       	or	r19, r29
 	stringState |= ( (!(i & (1<<yellow_pin))) << 3); //yellow fret
     220:	2a 2b       	or	r18, r26
     222:	3b 2b       	or	r19, r27
 	stringState |= ( (!(i & (1<<blue_pin))) << 4); //blue fret
     224:	2e 2b       	or	r18, r30
     226:	3f 2b       	or	r19, r31
 	stringState |= ( (!(i & (1<<orange_pin))) << 5); //orange fret
     228:	26 2b       	or	r18, r22
     22a:	37 2b       	or	r19, r23
	// Also, if we strummed a string, hold that in the 'zeroth' fret
	i = pick_pin;
 	stringState |= ( (!(i & (1<<strum_pin))) << 0); //pick touching the string

	//Turn the string back HIGH and return
	string_port |= (1<<guitarString); 
     22c:	8b b1       	in	r24, 0x0b	; 11
     22e:	18 2b       	or	r17, r24
     230:	1b b9       	out	0x0b, r17	; 11
     232:	24 2b       	or	r18, r20
     234:	35 2b       	or	r19, r21
	return stringState;
}
     236:	c9 01       	movw	r24, r18
     238:	df 91       	pop	r29
     23a:	cf 91       	pop	r28
     23c:	1f 91       	pop	r17
     23e:	08 95       	ret

00000240 <main>:
	 -Under config mode, the loop reads in the values of the strings and frets, assigns that current
	  string-fret combination to correspond to a button press, then locks that combination in when 
	  'Plus' is pressed and moves on to changing the next button.  It also sets the button data structure
	  to display the current controller button being programmed, and then sends that data to the controller.
*/ 
{
     240:	2f 92       	push	r2
     242:	3f 92       	push	r3
     244:	4f 92       	push	r4
     246:	5f 92       	push	r5
     248:	6f 92       	push	r6
     24a:	7f 92       	push	r7
     24c:	8f 92       	push	r8
     24e:	9f 92       	push	r9
     250:	af 92       	push	r10
     252:	bf 92       	push	r11
     254:	cf 92       	push	r12
     256:	df 92       	push	r13
     258:	ef 92       	push	r14
     25a:	ff 92       	push	r15
     25c:	0f 93       	push	r16
     25e:	1f 93       	push	r17
     260:	df 93       	push	r29
     262:	cf 93       	push	r28
     264:	cd b7       	in	r28, 0x3d	; 61
     266:	de b7       	in	r29, 0x3e	; 62
     268:	c5 52       	subi	r28, 0x25	; 37
     26a:	d1 40       	sbci	r29, 0x01	; 1
     26c:	0f b6       	in	r0, 0x3f	; 63
     26e:	f8 94       	cli
     270:	de bf       	out	0x3e, r29	; 62
     272:	0f be       	out	0x3f, r0	; 63
     274:	cd bf       	out	0x3d, r28	; 61
  // Now set up all the communication stuff - initialization routines
  //  set specially in the interface functions - see ps3interface.h, wiiinterface.h, etc.
  startCommunication();
     276:	0e 94 a8 0a 	call	0x1550	; 0x1550 <startCommunication>

	//Debug stuff - the following goes before the while loop in main()
	int timer;
    DDRB |= 1;
     27a:	20 9a       	sbi	0x04, 0	; 4
  // set PORTB for output
  
  uint8_t string[1];
  uint8_t x = 10;
     27c:	8a e0       	ldi	r24, 0x0A	; 10
     27e:	8a 83       	std	Y+2, r24	; 0x02
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
     280:	ce 01       	movw	r24, r28
     282:	01 96       	adiw	r24, 0x01	; 1
     284:	68 e6       	ldi	r22, 0x68	; 104
     286:	71 e0       	ldi	r23, 0x01	; 1
     288:	41 e0       	ldi	r20, 0x01	; 1
     28a:	50 e0       	ldi	r21, 0x00	; 0
     28c:	20 eb       	ldi	r18, 0xB0	; 176
     28e:	30 e0       	ldi	r19, 0x00	; 0
     290:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <__eerd_block>

  eeprom_read_block( (void*)&string, (void*)&nonvolitileString, 1);
  if (string[0] == 50)
     294:	89 81       	ldd	r24, Y+1	; 0x01
     296:	be 01       	movw	r22, r28
     298:	6e 5f       	subi	r22, 0xFE	; 254
     29a:	7f 4f       	sbci	r23, 0xFF	; 255
     29c:	82 33       	cpi	r24, 0x32	; 50
     29e:	11 f4       	brne	.+4      	; 0x2a4 <main+0x64>
  {
  	  x = 250;
     2a0:	8a ef       	ldi	r24, 0xFA	; 250
     2a2:	01 c0       	rjmp	.+2      	; 0x2a6 <main+0x66>
  	  eeprom_write_block( (void*)&x, (void*)&nonvolitileString, 1);
  }
  else
  {
  	  x = 50;
     2a4:	82 e3       	ldi	r24, 0x32	; 50
     2a6:	8a 83       	std	Y+2, r24	; 0x02
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
     2a8:	88 e6       	ldi	r24, 0x68	; 104
     2aa:	91 e0       	ldi	r25, 0x01	; 1
     2ac:	41 e0       	ldi	r20, 0x01	; 1
     2ae:	50 e0       	ldi	r21, 0x00	; 0
     2b0:	28 eb       	ldi	r18, 0xB8	; 184
     2b2:	30 e0       	ldi	r19, 0x00	; 0
     2b4:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <__eewr_block>
  	  eeprom_write_block( (void*)&x, (void*)&nonvolitileString, 1);
  }
  timer = x;

	// First, set up the guitar stuff - These functions are stored in guitarInitFunctions.h/.c
	setPins();
     2b8:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <setPins>
	setTimer();	
     2bc:	0e 94 89 04 	call	0x912	; 0x912 <setTimer>

    // Declaration of variables used in Main()
	int greenTimers[NUMBER_OF_STRINGS] = {0,0,0,0,0,0}; //These give timing to properly read green buttons on each string.
     2c0:	8c e0       	ldi	r24, 0x0C	; 12
     2c2:	fe 01       	movw	r30, r28
     2c4:	72 96       	adiw	r30, 0x12	; 18
     2c6:	df 01       	movw	r26, r30
     2c8:	98 2f       	mov	r25, r24
     2ca:	1d 92       	st	X+, r1
     2cc:	9a 95       	dec	r25
     2ce:	e9 f7       	brne	.-6      	; 0x2ca <main+0x8a>
	int triedGreen[NUMBER_OF_STRINGS] = {0,0,0,0,0,0};  // Also used for the green button timing thing
     2d0:	fe 01       	movw	r30, r28
     2d2:	7e 96       	adiw	r30, 0x1e	; 30
     2d4:	df 01       	movw	r26, r30
     2d6:	98 2f       	mov	r25, r24
     2d8:	1d 92       	st	X+, r1
     2da:	9a 95       	dec	r25
     2dc:	e9 f7       	brne	.-6      	; 0x2d8 <main+0x98>
	int stringState[6] = {0,0,0,0,0,0}; // This stores an int for each string,
     2de:	fe 01       	movw	r30, r28
     2e0:	ba 96       	adiw	r30, 0x2a	; 42
     2e2:	df 01       	movw	r26, r30
     2e4:	1d 92       	st	X+, r1
     2e6:	8a 95       	dec	r24
     2e8:	e9 f7       	brne	.-6      	; 0x2e4 <main+0xa4>
																	 // controller compares the string presses
																	 // to in order to judge if a button is being
																	 // pressed. It's the size of all the chord combinations,
																	 // but in Note Mode, only the first 5 blocks get looked at. 
	char configMode = 0; // Start in normal mode
	int buttonToAssign = 0; // declare some variables
     2ea:	1e 82       	std	Y+6, r1	; 0x06
     2ec:	1d 82       	std	Y+5, r1	; 0x05
	char plusLock = 0;
     2ee:	1b 82       	std	Y+3, r1	; 0x03
	char previousPlusOn = 0; // This is used as a lock so we don't program all the buttons at once
     2f0:	1c 82       	std	Y+4, r1	; 0x04
	int debounceTimer = 0; // This is used as a global timer for debouncing buttons
     2f2:	18 86       	std	Y+8, r1	; 0x08
     2f4:	1f 82       	std	Y+7, r1	; 0x07
		char minusOn;
	} dataForController;

	inline void clearData(dataForController* data)
	{
		data->orangeOn = 0;
     2f6:	1d 86       	std	Y+13, r1	; 0x0d
		data->blueOn   = 0;
     2f8:	1c 86       	std	Y+12, r1	; 0x0c
		data->yellowOn = 0;
     2fa:	1b 86       	std	Y+11, r1	; 0x0b
		data->redOn    = 0;
     2fc:	1a 86       	std	Y+10, r1	; 0x0a
		data->greenOn  = 0;
     2fe:	19 86       	std	Y+9, r1	; 0x09
		data->upOn     = 0;
     300:	1e 86       	std	Y+14, r1	; 0x0e
		data->downOn   = 0;
     302:	1f 86       	std	Y+15, r1	; 0x0f
		data->plusOn   = 0;
     304:	18 8a       	std	Y+16, r1	; 0x10
		data->minusOn  = 0;
     306:	19 8a       	std	Y+17, r1	; 0x11
	
	dataForController data;
	clearData(&data); //This function is contained in V1Typedefs.h

	//Debug Stuff - it's complementary code is in ps3interface.h and .c
	DDRC &= ~(1<<5); //Turn 5 on Port C to inputs
     308:	3d 98       	cbi	0x07, 5	; 7
	PORTC |= (1<<5); //Turn off the internal pullup resistor on pin 5
     30a:	45 9a       	sbi	0x08, 5	; 8
     30c:	66 24       	eor	r6, r6
     30e:	77 24       	eor	r7, r7
	// array as something big enough for all 21 chord mode combinations, but we
	// only write the first 5 patterns when we write these ones to EEPROM
	int buttonStringPatterns[NUM_CHORDS_BUTTONS][NUMBER_OF_STRINGS];

    buttonStringPatterns[0][0] = 0b0000000; // [0][0] through [0][5] - green button
    buttonStringPatterns[0][0] = 0x0000000; // [0][0] through [0][5] - green button
     310:	ee ea       	ldi	r30, 0xAE	; 174
     312:	8e 2e       	mov	r8, r30
     314:	91 2c       	mov	r9, r1
     316:	8c 0e       	add	r8, r28
     318:	9d 1e       	adc	r9, r29
	buttonStringPatterns[2][4] = 0;	buttonStringPatterns[2][5] = 0;
	buttonStringPatterns[3][0] = 0;	buttonStringPatterns[3][1] = 0;
	buttonStringPatterns[3][2] = 0;	buttonStringPatterns[3][3] = 0;
	buttonStringPatterns[3][4] = 0;	buttonStringPatterns[3][5] = 0;
	buttonStringPatterns[4][0] = 0;	buttonStringPatterns[4][1] = 0;
	buttonStringPatterns[4][2] = 0;	buttonStringPatterns[4][3] = 0;
     31a:	7c e6       	ldi	r23, 0x6C	; 108
     31c:	27 2e       	mov	r2, r23
     31e:	31 2c       	mov	r3, r1
     320:	2c 0e       	add	r2, r28
     322:	3d 1e       	adc	r3, r29
    while(1){  
	              /* main event loop */
		
		// We first read all the strings for button hits and store them into
		//  our stringState array.  Strum processing is also handled here for now.
        stringState[0] = readFrets(first_string);
     324:	87 e0       	ldi	r24, 0x07	; 7
     326:	90 e0       	ldi	r25, 0x00	; 0
     328:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     32c:	9b a7       	std	Y+43, r25	; 0x2b
     32e:	8a a7       	std	Y+42, r24	; 0x2a
		stringState[1] = readFrets(second_string);
     330:	86 e0       	ldi	r24, 0x06	; 6
     332:	90 e0       	ldi	r25, 0x00	; 0
     334:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     338:	9d a7       	std	Y+45, r25	; 0x2d
     33a:	8c a7       	std	Y+44, r24	; 0x2c
		stringState[2] = readFrets(third_string);
     33c:	85 e0       	ldi	r24, 0x05	; 5
     33e:	90 e0       	ldi	r25, 0x00	; 0
     340:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     344:	9f a7       	std	Y+47, r25	; 0x2f
     346:	8e a7       	std	Y+46, r24	; 0x2e
		stringState[3] = readFrets(fourth_string);
     348:	82 e0       	ldi	r24, 0x02	; 2
     34a:	90 e0       	ldi	r25, 0x00	; 0
     34c:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     350:	99 ab       	std	Y+49, r25	; 0x31
     352:	88 ab       	std	Y+48, r24	; 0x30
		stringState[4] = readFrets(fifth_string);
     354:	81 e0       	ldi	r24, 0x01	; 1
     356:	90 e0       	ldi	r25, 0x00	; 0
     358:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     35c:	9b ab       	std	Y+51, r25	; 0x33
     35e:	8a ab       	std	Y+50, r24	; 0x32
		stringState[5] = readFrets(sixth_string);
     360:	80 e0       	ldi	r24, 0x00	; 0
     362:	90 e0       	ldi	r25, 0x00	; 0
     364:	0e 94 c5 00 	call	0x18a	; 0x18a <readFrets>
     368:	9c 01       	movw	r18, r24
     36a:	9d ab       	std	Y+53, r25	; 0x35
     36c:	8c ab       	std	Y+52, r24	; 0x34
		char minusOn;
	} dataForController;

	inline void clearData(dataForController* data)
	{
		data->orangeOn = 0;
     36e:	1d 86       	std	Y+13, r1	; 0x0d
		data->blueOn   = 0;
     370:	1c 86       	std	Y+12, r1	; 0x0c
		data->yellowOn = 0;
     372:	1b 86       	std	Y+11, r1	; 0x0b
		data->redOn    = 0;
     374:	1a 86       	std	Y+10, r1	; 0x0a
		data->greenOn  = 0;
     376:	19 86       	std	Y+9, r1	; 0x09
		data->upOn     = 0;
     378:	1e 86       	std	Y+14, r1	; 0x0e
		data->downOn   = 0;
     37a:	1f 86       	std	Y+15, r1	; 0x0f
		data->plusOn   = 0;
     37c:	18 8a       	std	Y+16, r1	; 0x10
		data->minusOn  = 0;
     37e:	19 8a       	std	Y+17, r1	; 0x11
		return 0;
}

inline int testForResetButtonPatterns(int stringState[])
{
	if ((stringState[0] == 0b00000010) &&
     380:	8a a5       	ldd	r24, Y+42	; 0x2a
     382:	9b a5       	ldd	r25, Y+43	; 0x2b
     384:	02 97       	sbiw	r24, 0x02	; 2
     386:	09 f0       	breq	.+2      	; 0x38a <main+0x14a>
     388:	e7 c0       	rjmp	.+462    	; 0x558 <__stack+0x59>
     38a:	8c a5       	ldd	r24, Y+44	; 0x2c
     38c:	9d a5       	ldd	r25, Y+45	; 0x2d
     38e:	0c 97       	sbiw	r24, 0x0c	; 12
     390:	09 f0       	breq	.+2      	; 0x394 <main+0x154>
     392:	e2 c0       	rjmp	.+452    	; 0x558 <__stack+0x59>
     394:	8e a5       	ldd	r24, Y+46	; 0x2e
     396:	9f a5       	ldd	r25, Y+47	; 0x2f
     398:	02 97       	sbiw	r24, 0x02	; 2
     39a:	09 f0       	breq	.+2      	; 0x39e <main+0x15e>
     39c:	dd c0       	rjmp	.+442    	; 0x558 <__stack+0x59>
     39e:	88 a9       	ldd	r24, Y+48	; 0x30
     3a0:	99 a9       	ldd	r25, Y+49	; 0x31
     3a2:	0c 97       	sbiw	r24, 0x0c	; 12
     3a4:	09 f0       	breq	.+2      	; 0x3a8 <main+0x168>
     3a6:	d8 c0       	rjmp	.+432    	; 0x558 <__stack+0x59>
     3a8:	4a a9       	ldd	r20, Y+50	; 0x32
     3aa:	5b a9       	ldd	r21, Y+51	; 0x33
     3ac:	42 30       	cpi	r20, 0x02	; 2
     3ae:	51 05       	cpc	r21, r1
     3b0:	09 f0       	breq	.+2      	; 0x3b4 <main+0x174>
     3b2:	d2 c0       	rjmp	.+420    	; 0x558 <__stack+0x59>
     3b4:	2c 30       	cpi	r18, 0x0C	; 12
     3b6:	31 05       	cpc	r19, r1
     3b8:	09 f0       	breq	.+2      	; 0x3bc <main+0x17c>
     3ba:	ce c0       	rjmp	.+412    	; 0x558 <__stack+0x59>
     3bc:	f4 01       	movw	r30, r8
     3be:	11 82       	std	Z+1, r1	; 0x01
     3c0:	10 82       	st	Z, r1
	buttonStringPatterns[0][1] = 0b0001100; 
     3c2:	33 83       	std	Z+3, r19	; 0x03
     3c4:	22 83       	std	Z+2, r18	; 0x02
	buttonStringPatterns[0][2] = 0b0000000;	
     3c6:	15 82       	std	Z+5, r1	; 0x05
     3c8:	14 82       	std	Z+4, r1	; 0x04
	buttonStringPatterns[0][3] = 0b0000110;
     3ca:	06 e0       	ldi	r16, 0x06	; 6
     3cc:	10 e0       	ldi	r17, 0x00	; 0
     3ce:	17 83       	std	Z+7, r17	; 0x07
     3d0:	06 83       	std	Z+6, r16	; 0x06
	buttonStringPatterns[0][4] = 0b0000000;
     3d2:	11 86       	std	Z+9, r1	; 0x09
     3d4:	10 86       	std	Z+8, r1	; 0x08
	buttonStringPatterns[0][5] = 0b0000010;
     3d6:	53 87       	std	Z+11, r21	; 0x0b
     3d8:	42 87       	std	Z+10, r20	; 0x0a

	buttonStringPatterns[1][0] = 0b0000010; // [1][0] through [1][5] - red button
     3da:	55 87       	std	Z+13, r21	; 0x0d
     3dc:	44 87       	std	Z+12, r20	; 0x0c
	buttonStringPatterns[1][1] = 0b0000000; 
     3de:	17 86       	std	Z+15, r1	; 0x0f
     3e0:	16 86       	std	Z+14, r1	; 0x0e
	buttonStringPatterns[1][2] = 0b0000001;
     3e2:	81 e0       	ldi	r24, 0x01	; 1
     3e4:	90 e0       	ldi	r25, 0x00	; 0
     3e6:	91 8b       	std	Z+17, r25	; 0x11
     3e8:	80 8b       	std	Z+16, r24	; 0x10
	buttonStringPatterns[1][3] = 0b0000000;
     3ea:	13 8a       	std	Z+19, r1	; 0x13
     3ec:	12 8a       	std	Z+18, r1	; 0x12
	buttonStringPatterns[1][4] = 0b0000001;
     3ee:	95 8b       	std	Z+21, r25	; 0x15
     3f0:	84 8b       	std	Z+20, r24	; 0x14
	buttonStringPatterns[1][5] = 0b0001100;
     3f2:	37 8b       	std	Z+23, r19	; 0x17
     3f4:	26 8b       	std	Z+22, r18	; 0x16

	buttonStringPatterns[2][0] = 0b0001100; // [2][0] through [2][5] - yellow button
     3f6:	31 8f       	std	Z+25, r19	; 0x19
     3f8:	20 8f       	std	Z+24, r18	; 0x18
	buttonStringPatterns[2][1] = 0b0000000; // This is an A chord.
     3fa:	13 8e       	std	Z+27, r1	; 0x1b
     3fc:	12 8e       	std	Z+26, r1	; 0x1a
	buttonStringPatterns[2][2] = 0b0000110;
     3fe:	15 8f       	std	Z+29, r17	; 0x1d
     400:	04 8f       	std	Z+28, r16	; 0x1c
	buttonStringPatterns[2][3] = 0b0000000;
     402:	17 8e       	std	Z+31, r1	; 0x1f
     404:	16 8e       	std	Z+30, r1	; 0x1e
	buttonStringPatterns[2][4] = 0b0000010;
     406:	51 a3       	std	Z+33, r21	; 0x21
     408:	40 a3       	std	Z+32, r20	; 0x20
	buttonStringPatterns[2][5] = 0b0000000;
     40a:	13 a2       	std	Z+35, r1	; 0x23
     40c:	12 a2       	std	Z+34, r1	; 0x22
							  
	buttonStringPatterns[3][0] = 0b0000000; // [3][0] through [3][5] - blue button
     40e:	15 a2       	std	Z+37, r1	; 0x25
     410:	14 a2       	std	Z+36, r1	; 0x24
	buttonStringPatterns[3][1] = 0b0000001; 
     412:	97 a3       	std	Z+39, r25	; 0x27
     414:	86 a3       	std	Z+38, r24	; 0x26
	buttonStringPatterns[3][2] = 0b0001100;
     416:	31 a7       	std	Z+41, r19	; 0x29
     418:	20 a7       	std	Z+40, r18	; 0x28
	buttonStringPatterns[3][3] = 0b0000000;
     41a:	13 a6       	std	Z+43, r1	; 0x2b
     41c:	12 a6       	std	Z+42, r1	; 0x2a
	buttonStringPatterns[3][4] = 0b0001100;
     41e:	35 a7       	std	Z+45, r19	; 0x2d
     420:	24 a7       	std	Z+44, r18	; 0x2c
	buttonStringPatterns[3][5] = 0b0000000;
     422:	17 a6       	std	Z+47, r1	; 0x2f
     424:	16 a6       	std	Z+46, r1	; 0x2e

	buttonStringPatterns[4][0] = 0b0000000; // [4][0] through [4][5] - orange button
     426:	11 aa       	std	Z+49, r1	; 0x31
     428:	10 aa       	std	Z+48, r1	; 0x30
	buttonStringPatterns[4][1] = 0b0000110; 
     42a:	13 ab       	std	Z+51, r17	; 0x33
     42c:	02 ab       	std	Z+50, r16	; 0x32
	buttonStringPatterns[4][2] = 0b0000000;
     42e:	15 aa       	std	Z+53, r1	; 0x35
     430:	14 aa       	std	Z+52, r1	; 0x34
	buttonStringPatterns[4][3] = 0b0000001;
     432:	97 ab       	std	Z+55, r25	; 0x37
     434:	86 ab       	std	Z+54, r24	; 0x36
	buttonStringPatterns[4][4] = 0b0000000;
     436:	11 ae       	std	Z+57, r1	; 0x39
     438:	10 ae       	std	Z+56, r1	; 0x38
	buttonStringPatterns[4][5] = 0b0000001;
     43a:	93 af       	std	Z+59, r25	; 0x3b
     43c:	82 af       	std	Z+58, r24	; 0x3a
     43e:	80 e0       	ldi	r24, 0x00	; 0
     440:	90 e0       	ldi	r25, 0x00	; 0
     442:	b4 01       	movw	r22, r8
     444:	4c e3       	ldi	r20, 0x3C	; 60
     446:	50 e0       	ldi	r21, 0x00	; 0
     448:	28 eb       	ldi	r18, 0xB8	; 184
     44a:	30 e0       	ldi	r19, 0x00	; 0
     44c:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <__eewr_block>

	eeprom_write_block( (void*)&buttonStringPatterns, notesAddress, EEPROM_NOTES_BLOCK_SIZE);


	// Now write the default chord mapping
	buttonStringPatterns[0][0] = 0b0001110; // [0][0] through [0][5] - green button
     450:	8e e0       	ldi	r24, 0x0E	; 14
     452:	90 e0       	ldi	r25, 0x00	; 0
     454:	d4 01       	movw	r26, r8
     456:	11 96       	adiw	r26, 0x01	; 1
     458:	9c 93       	st	X, r25
     45a:	8e 93       	st	-X, r24
	buttonStringPatterns[0][1] = 0b0001110; // This is a G Chord
     45c:	13 96       	adiw	r26, 0x03	; 3
     45e:	9c 93       	st	X, r25
     460:	8e 93       	st	-X, r24
     462:	12 97       	sbiw	r26, 0x02	; 2
	buttonStringPatterns[0][2] = 0b0000000;	
     464:	15 96       	adiw	r26, 0x05	; 5
     466:	1c 92       	st	X, r1
     468:	1e 92       	st	-X, r1
     46a:	14 97       	sbiw	r26, 0x04	; 4
	buttonStringPatterns[0][3] = 0b0000000;
     46c:	17 96       	adiw	r26, 0x07	; 7
     46e:	1c 92       	st	X, r1
     470:	1e 92       	st	-X, r1
     472:	16 97       	sbiw	r26, 0x06	; 6
	buttonStringPatterns[0][4] = 0b0000000;
     474:	19 96       	adiw	r26, 0x09	; 9
     476:	1c 92       	st	X, r1
     478:	1e 92       	st	-X, r1
     47a:	18 97       	sbiw	r26, 0x08	; 8
	buttonStringPatterns[0][5] = 0b0001110;
     47c:	1b 96       	adiw	r26, 0x0b	; 11
     47e:	9c 93       	st	X, r25
     480:	8e 93       	st	-X, r24
     482:	1a 97       	sbiw	r26, 0x0a	; 10

	buttonStringPatterns[1][0] = 0b0000000; // [1][0] through [1][5] - red button
     484:	1d 96       	adiw	r26, 0x0d	; 13
     486:	1c 92       	st	X, r1
     488:	1e 92       	st	-X, r1
     48a:	1c 97       	sbiw	r26, 0x0c	; 12
	buttonStringPatterns[1][1] = 0b0001110; // This is a C chord
     48c:	1f 96       	adiw	r26, 0x0f	; 15
     48e:	9c 93       	st	X, r25
     490:	8e 93       	st	-X, r24
     492:	1e 97       	sbiw	r26, 0x0e	; 14
	buttonStringPatterns[1][2] = 0b0001110;
     494:	51 96       	adiw	r26, 0x11	; 17
     496:	9c 93       	st	X, r25
     498:	8e 93       	st	-X, r24
     49a:	50 97       	sbiw	r26, 0x10	; 16
	buttonStringPatterns[1][3] = 0b0000000;
     49c:	53 96       	adiw	r26, 0x13	; 19
     49e:	1c 92       	st	X, r1
     4a0:	1e 92       	st	-X, r1
     4a2:	52 97       	sbiw	r26, 0x12	; 18
	buttonStringPatterns[1][4] = 0b0001110;
     4a4:	55 96       	adiw	r26, 0x15	; 21
     4a6:	9c 93       	st	X, r25
     4a8:	8e 93       	st	-X, r24
     4aa:	54 97       	sbiw	r26, 0x14	; 20
	buttonStringPatterns[1][5] = 0b0000000;
     4ac:	57 96       	adiw	r26, 0x17	; 23
     4ae:	1c 92       	st	X, r1
     4b0:	1e 92       	st	-X, r1
     4b2:	56 97       	sbiw	r26, 0x16	; 22

	buttonStringPatterns[2][0] = 0b0000000; // [2][0] through [2][5] - yellow button
     4b4:	59 96       	adiw	r26, 0x19	; 25
     4b6:	1c 92       	st	X, r1
     4b8:	1e 92       	st	-X, r1
     4ba:	58 97       	sbiw	r26, 0x18	; 24
	buttonStringPatterns[2][1] = 0b0000110; // This is an E chord.
     4bc:	5b 96       	adiw	r26, 0x1b	; 27
     4be:	1c 93       	st	X, r17
     4c0:	0e 93       	st	-X, r16
     4c2:	5a 97       	sbiw	r26, 0x1a	; 26
	buttonStringPatterns[2][2] = 0b0000110;
     4c4:	5d 96       	adiw	r26, 0x1d	; 29
     4c6:	1c 93       	st	X, r17
     4c8:	0e 93       	st	-X, r16
     4ca:	5c 97       	sbiw	r26, 0x1c	; 28
	buttonStringPatterns[2][3] = 0b0000110;
     4cc:	5f 96       	adiw	r26, 0x1f	; 31
     4ce:	1c 93       	st	X, r17
     4d0:	0e 93       	st	-X, r16
     4d2:	5e 97       	sbiw	r26, 0x1e	; 30
	buttonStringPatterns[2][4] = 0b0000000;
     4d4:	91 96       	adiw	r26, 0x21	; 33
     4d6:	1c 92       	st	X, r1
     4d8:	1e 92       	st	-X, r1
     4da:	90 97       	sbiw	r26, 0x20	; 32
	buttonStringPatterns[2][5] = 0b0000000;
     4dc:	93 96       	adiw	r26, 0x23	; 35
     4de:	1c 92       	st	X, r1
     4e0:	1e 92       	st	-X, r1
     4e2:	92 97       	sbiw	r26, 0x22	; 34
									  
	buttonStringPatterns[3][0] = 0b0000000; // [3][0] through [3][5] - blue button
     4e4:	95 96       	adiw	r26, 0x25	; 37
     4e6:	1c 92       	st	X, r1
     4e8:	1e 92       	st	-X, r1
     4ea:	94 97       	sbiw	r26, 0x24	; 36
	buttonStringPatterns[3][1] = 0b0000000; // This an A chord
     4ec:	97 96       	adiw	r26, 0x27	; 39
     4ee:	1c 92       	st	X, r1
     4f0:	1e 92       	st	-X, r1
     4f2:	96 97       	sbiw	r26, 0x26	; 38
	buttonStringPatterns[3][2] = 0b0000110;
     4f4:	99 96       	adiw	r26, 0x29	; 41
     4f6:	1c 93       	st	X, r17
     4f8:	0e 93       	st	-X, r16
     4fa:	98 97       	sbiw	r26, 0x28	; 40
	buttonStringPatterns[3][3] = 0b0000110;
     4fc:	9b 96       	adiw	r26, 0x2b	; 43
     4fe:	1c 93       	st	X, r17
     500:	0e 93       	st	-X, r16
     502:	9a 97       	sbiw	r26, 0x2a	; 42
	buttonStringPatterns[3][4] = 0b0000110;
     504:	9d 96       	adiw	r26, 0x2d	; 45
     506:	1c 93       	st	X, r17
     508:	0e 93       	st	-X, r16
     50a:	9c 97       	sbiw	r26, 0x2c	; 44
	buttonStringPatterns[3][5] = 0b0000000;
     50c:	9f 96       	adiw	r26, 0x2f	; 47
     50e:	1c 92       	st	X, r1
     510:	1e 92       	st	-X, r1
     512:	9e 97       	sbiw	r26, 0x2e	; 46

	buttonStringPatterns[4][0] = 0b0000000; // [4][0] through [4][5] - blue button
     514:	d1 96       	adiw	r26, 0x31	; 49
     516:	1c 92       	st	X, r1
     518:	1e 92       	st	-X, r1
     51a:	d0 97       	sbiw	r26, 0x30	; 48
	buttonStringPatterns[4][1] = 0b0000000;	// This is a D chord 
     51c:	d3 96       	adiw	r26, 0x33	; 51
     51e:	1c 92       	st	X, r1
     520:	1e 92       	st	-X, r1
     522:	d2 97       	sbiw	r26, 0x32	; 50
	buttonStringPatterns[4][2] = 0b0000000;
     524:	d5 96       	adiw	r26, 0x35	; 53
     526:	1c 92       	st	X, r1
     528:	1e 92       	st	-X, r1
     52a:	d4 97       	sbiw	r26, 0x34	; 52
	buttonStringPatterns[4][3] = 0b0001110;
     52c:	d7 96       	adiw	r26, 0x37	; 55
     52e:	9c 93       	st	X, r25
     530:	8e 93       	st	-X, r24
     532:	d6 97       	sbiw	r26, 0x36	; 54
	buttonStringPatterns[4][4] = 0b0001110;
     534:	d9 96       	adiw	r26, 0x39	; 57
     536:	9c 93       	st	X, r25
     538:	8e 93       	st	-X, r24
     53a:	d8 97       	sbiw	r26, 0x38	; 56
	buttonStringPatterns[4][5] = 0b0001110;
     53c:	db 96       	adiw	r26, 0x3b	; 59
     53e:	9c 93       	st	X, r25
     540:	8e 93       	st	-X, r24
     542:	da 97       	sbiw	r26, 0x3a	; 58
     544:	88 e7       	ldi	r24, 0x78	; 120
     546:	90 e0       	ldi	r25, 0x00	; 0
     548:	b4 01       	movw	r22, r8
     54a:	48 e7       	ldi	r20, 0x78	; 120
     54c:	50 e0       	ldi	r21, 0x00	; 0
     54e:	28 eb       	ldi	r18, 0xB8	; 184
     550:	30 e0       	ldi	r19, 0x00	; 0
     552:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <__eewr_block>
     556:	77 24       	eor	r7, r7

// This function just reads our plus and minus buttons and sets the data struct accordingly
inline void readOtherButtons(dataForController* data)
{
	// read our plus and minus buttons
	int i = misc_pin; // check for plus and minus
     558:	86 b1       	in	r24, 0x06	; 6
     55a:	90 e0       	ldi	r25, 0x00	; 0
	data->plusOn = !(i & (1<<plus_pin)); //Plus and minus are held high normally, but pressing it drops it low
     55c:	41 e0       	ldi	r20, 0x01	; 1
     55e:	50 e0       	ldi	r21, 0x00	; 0
     560:	9c 01       	movw	r18, r24
     562:	24 27       	eor	r18, r20
     564:	35 27       	eor	r19, r21
     566:	21 70       	andi	r18, 0x01	; 1
     568:	28 8b       	std	Y+16, r18	; 0x10
	data->minusOn = !(i & (1<<minus_pin));
     56a:	96 95       	lsr	r25
     56c:	87 95       	ror	r24
     56e:	84 27       	eor	r24, r20
     570:	95 27       	eor	r25, r21
     572:	81 70       	andi	r24, 0x01	; 1
     574:	89 8b       	std	Y+17, r24	; 0x11
		return 0;
}

inline int testForMinusChord(int stringState[])
{
	if ((stringState[0] == 0b00011110) &&
     576:	2a a5       	ldd	r18, Y+42	; 0x2a
     578:	3b a5       	ldd	r19, Y+43	; 0x2b
     57a:	2e 31       	cpi	r18, 0x1E	; 30
     57c:	31 05       	cpc	r19, r1
     57e:	b1 f4       	brne	.+44     	; 0x5ac <__stack+0xad>
     580:	8c a5       	ldd	r24, Y+44	; 0x2c
     582:	9d a5       	ldd	r25, Y+45	; 0x2d
     584:	4e 97       	sbiw	r24, 0x1e	; 30
     586:	91 f4       	brne	.+36     	; 0x5ac <__stack+0xad>
     588:	8e a5       	ldd	r24, Y+46	; 0x2e
     58a:	9f a5       	ldd	r25, Y+47	; 0x2f
     58c:	4e 97       	sbiw	r24, 0x1e	; 30
     58e:	71 f4       	brne	.+28     	; 0x5ac <__stack+0xad>
     590:	88 a9       	ldd	r24, Y+48	; 0x30
     592:	99 a9       	ldd	r25, Y+49	; 0x31
     594:	4e 97       	sbiw	r24, 0x1e	; 30
     596:	51 f4       	brne	.+20     	; 0x5ac <__stack+0xad>
     598:	8a a9       	ldd	r24, Y+50	; 0x32
     59a:	9b a9       	ldd	r25, Y+51	; 0x33
     59c:	4e 97       	sbiw	r24, 0x1e	; 30
     59e:	31 f4       	brne	.+12     	; 0x5ac <__stack+0xad>
     5a0:	8c a9       	ldd	r24, Y+52	; 0x34
     5a2:	9d a9       	ldd	r25, Y+53	; 0x35
     5a4:	4e 97       	sbiw	r24, 0x1e	; 30
     5a6:	11 f4       	brne	.+4      	; 0x5ac <__stack+0xad>
		// Now read our other buttons, like plus and minus
		readOtherButtons(&data);

		//Test if Minus is being played by the chord instead of the button
		if(testForMinusChord(stringState))
			data.minusOn = 1;
     5a8:	81 e0       	ldi	r24, 0x01	; 1
     5aa:	89 8b       	std	Y+17, r24	; 0x11
		
		if ((controllerMode == NOTES) || (controllerMode == CHORDS))
     5ac:	b2 e0       	ldi	r27, 0x02	; 2
     5ae:	7b 16       	cp	r7, r27
     5b0:	21 f0       	breq	.+8      	; 0x5ba <__stack+0xbb>
     5b2:	e4 e0       	ldi	r30, 0x04	; 4
     5b4:	7e 16       	cp	r7, r30
     5b6:	09 f0       	breq	.+2      	; 0x5ba <__stack+0xbb>
     5b8:	ee c0       	rjmp	.+476    	; 0x796 <__stack+0x297>
		{
			// Check to see if we're trying to enter Config Mode; disabled if we're playing with frets
			if (configMode == 0)
     5ba:	66 20       	and	r6, r6
     5bc:	09 f0       	breq	.+2      	; 0x5c0 <__stack+0xc1>
     5be:	94 c0       	rjmp	.+296    	; 0x6e8 <__stack+0x1e9>

// This function tests to see if you're pressing the top 4 strings on the orange fret,
//  thereby activating config mode. Works with both chords and scales.
inline char testForConfigMode(int stringState[])
{
	if ((stringState[0] == 0b00110000) &&
     5c0:	20 33       	cpi	r18, 0x30	; 48
     5c2:	31 05       	cpc	r19, r1
     5c4:	09 f0       	breq	.+2      	; 0x5c8 <__stack+0xc9>
     5c6:	8d c0       	rjmp	.+282    	; 0x6e2 <__stack+0x1e3>
     5c8:	8c a5       	ldd	r24, Y+44	; 0x2c
     5ca:	9d a5       	ldd	r25, Y+45	; 0x2d
     5cc:	c0 97       	sbiw	r24, 0x30	; 48
     5ce:	09 f0       	breq	.+2      	; 0x5d2 <__stack+0xd3>
     5d0:	88 c0       	rjmp	.+272    	; 0x6e2 <__stack+0x1e3>
     5d2:	8e a5       	ldd	r24, Y+46	; 0x2e
     5d4:	9f a5       	ldd	r25, Y+47	; 0x2f
     5d6:	c0 97       	sbiw	r24, 0x30	; 48
     5d8:	09 f0       	breq	.+2      	; 0x5dc <__stack+0xdd>
     5da:	83 c0       	rjmp	.+262    	; 0x6e2 <__stack+0x1e3>
     5dc:	88 a9       	ldd	r24, Y+48	; 0x30
     5de:	99 a9       	ldd	r25, Y+49	; 0x31
     5e0:	89 2b       	or	r24, r25
     5e2:	09 f0       	breq	.+2      	; 0x5e6 <__stack+0xe7>
     5e4:	7e c0       	rjmp	.+252    	; 0x6e2 <__stack+0x1e3>
     5e6:	8a a9       	ldd	r24, Y+50	; 0x32
     5e8:	9b a9       	ldd	r25, Y+51	; 0x33
     5ea:	89 2b       	or	r24, r25
     5ec:	09 f0       	breq	.+2      	; 0x5f0 <__stack+0xf1>
     5ee:	79 c0       	rjmp	.+242    	; 0x6e2 <__stack+0x1e3>
     5f0:	8c a9       	ldd	r24, Y+52	; 0x34
     5f2:	9d a9       	ldd	r25, Y+53	; 0x35
     5f4:	89 2b       	or	r24, r25
     5f6:	09 f0       	breq	.+2      	; 0x5fa <__stack+0xfb>
     5f8:	74 c0       	rjmp	.+232    	; 0x6e2 <__stack+0x1e3>
			{
				configMode = testForConfigMode(stringState);
				
				// If we're playing with notes, when we enter config mode, we need to clear the 
				//  button string patterns once so we can rebuild them.
				if (configMode == 1 && controllerMode == NOTES)
     5fa:	f2 e0       	ldi	r31, 0x02	; 2
     5fc:	7f 16       	cp	r7, r31
     5fe:	09 f0       	breq	.+2      	; 0x602 <__stack+0x103>
     600:	6e c0       	rjmp	.+220    	; 0x6de <__stack+0x1df>
	return stringState;
}

inline void clearButtonStringPatterns(int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
	buttonStringPatterns[0][0] = 0;	buttonStringPatterns[0][1] = 0;
     602:	1f aa       	std	Y+55, r1	; 0x37
     604:	1e aa       	std	Y+54, r1	; 0x36
     606:	19 ae       	std	Y+57, r1	; 0x39
     608:	18 ae       	std	Y+56, r1	; 0x38
	buttonStringPatterns[0][2] = 0;	buttonStringPatterns[0][3] = 0;
     60a:	1b ae       	std	Y+59, r1	; 0x3b
     60c:	1a ae       	std	Y+58, r1	; 0x3a
     60e:	1d ae       	std	Y+61, r1	; 0x3d
     610:	1c ae       	std	Y+60, r1	; 0x3c
	buttonStringPatterns[0][4] = 0;	buttonStringPatterns[0][5] = 0;
     612:	1f ae       	std	Y+63, r1	; 0x3f
     614:	1e ae       	std	Y+62, r1	; 0x3e
     616:	22 96       	adiw	r28, 0x02	; 2
     618:	1f ae       	std	Y+63, r1	; 0x3f
     61a:	1e ae       	std	Y+62, r1	; 0x3e
     61c:	22 97       	sbiw	r28, 0x02	; 2
	buttonStringPatterns[1][0] = 0;	buttonStringPatterns[1][1] = 0;
     61e:	24 96       	adiw	r28, 0x04	; 4
     620:	1f ae       	std	Y+63, r1	; 0x3f
     622:	1e ae       	std	Y+62, r1	; 0x3e
     624:	24 97       	sbiw	r28, 0x04	; 4
     626:	26 96       	adiw	r28, 0x06	; 6
     628:	1f ae       	std	Y+63, r1	; 0x3f
     62a:	1e ae       	std	Y+62, r1	; 0x3e
     62c:	26 97       	sbiw	r28, 0x06	; 6
	buttonStringPatterns[1][2] = 0;	buttonStringPatterns[1][3] = 0;
     62e:	28 96       	adiw	r28, 0x08	; 8
     630:	1f ae       	std	Y+63, r1	; 0x3f
     632:	1e ae       	std	Y+62, r1	; 0x3e
     634:	28 97       	sbiw	r28, 0x08	; 8
     636:	2a 96       	adiw	r28, 0x0a	; 10
     638:	1f ae       	std	Y+63, r1	; 0x3f
     63a:	1e ae       	std	Y+62, r1	; 0x3e
     63c:	2a 97       	sbiw	r28, 0x0a	; 10
	buttonStringPatterns[1][4] = 0;	buttonStringPatterns[1][5] = 0;
     63e:	2c 96       	adiw	r28, 0x0c	; 12
     640:	1f ae       	std	Y+63, r1	; 0x3f
     642:	1e ae       	std	Y+62, r1	; 0x3e
     644:	2c 97       	sbiw	r28, 0x0c	; 12
     646:	2e 96       	adiw	r28, 0x0e	; 14
     648:	1f ae       	std	Y+63, r1	; 0x3f
     64a:	1e ae       	std	Y+62, r1	; 0x3e
     64c:	2e 97       	sbiw	r28, 0x0e	; 14
	buttonStringPatterns[2][0] = 0;	buttonStringPatterns[2][1] = 0;
     64e:	60 96       	adiw	r28, 0x10	; 16
     650:	1f ae       	std	Y+63, r1	; 0x3f
     652:	1e ae       	std	Y+62, r1	; 0x3e
     654:	60 97       	sbiw	r28, 0x10	; 16
     656:	62 96       	adiw	r28, 0x12	; 18
     658:	1f ae       	std	Y+63, r1	; 0x3f
     65a:	1e ae       	std	Y+62, r1	; 0x3e
     65c:	62 97       	sbiw	r28, 0x12	; 18
	buttonStringPatterns[2][2] = 0;	buttonStringPatterns[2][3] = 0;
     65e:	64 96       	adiw	r28, 0x14	; 20
     660:	1f ae       	std	Y+63, r1	; 0x3f
     662:	1e ae       	std	Y+62, r1	; 0x3e
     664:	64 97       	sbiw	r28, 0x14	; 20
     666:	66 96       	adiw	r28, 0x16	; 22
     668:	1f ae       	std	Y+63, r1	; 0x3f
     66a:	1e ae       	std	Y+62, r1	; 0x3e
     66c:	66 97       	sbiw	r28, 0x16	; 22
	buttonStringPatterns[2][4] = 0;	buttonStringPatterns[2][5] = 0;
     66e:	68 96       	adiw	r28, 0x18	; 24
     670:	1f ae       	std	Y+63, r1	; 0x3f
     672:	1e ae       	std	Y+62, r1	; 0x3e
     674:	68 97       	sbiw	r28, 0x18	; 24
     676:	6a 96       	adiw	r28, 0x1a	; 26
     678:	1f ae       	std	Y+63, r1	; 0x3f
     67a:	1e ae       	std	Y+62, r1	; 0x3e
     67c:	6a 97       	sbiw	r28, 0x1a	; 26
	buttonStringPatterns[3][0] = 0;	buttonStringPatterns[3][1] = 0;
     67e:	6c 96       	adiw	r28, 0x1c	; 28
     680:	1f ae       	std	Y+63, r1	; 0x3f
     682:	1e ae       	std	Y+62, r1	; 0x3e
     684:	6c 97       	sbiw	r28, 0x1c	; 28
     686:	6e 96       	adiw	r28, 0x1e	; 30
     688:	1f ae       	std	Y+63, r1	; 0x3f
     68a:	1e ae       	std	Y+62, r1	; 0x3e
     68c:	6e 97       	sbiw	r28, 0x1e	; 30
	buttonStringPatterns[3][2] = 0;	buttonStringPatterns[3][3] = 0;
     68e:	a0 96       	adiw	r28, 0x20	; 32
     690:	1f ae       	std	Y+63, r1	; 0x3f
     692:	1e ae       	std	Y+62, r1	; 0x3e
     694:	a0 97       	sbiw	r28, 0x20	; 32
     696:	a2 96       	adiw	r28, 0x22	; 34
     698:	1f ae       	std	Y+63, r1	; 0x3f
     69a:	1e ae       	std	Y+62, r1	; 0x3e
     69c:	a2 97       	sbiw	r28, 0x22	; 34
	buttonStringPatterns[3][4] = 0;	buttonStringPatterns[3][5] = 0;
     69e:	a4 96       	adiw	r28, 0x24	; 36
     6a0:	1f ae       	std	Y+63, r1	; 0x3f
     6a2:	1e ae       	std	Y+62, r1	; 0x3e
     6a4:	a4 97       	sbiw	r28, 0x24	; 36
     6a6:	a6 96       	adiw	r28, 0x26	; 38
     6a8:	1f ae       	std	Y+63, r1	; 0x3f
     6aa:	1e ae       	std	Y+62, r1	; 0x3e
     6ac:	a6 97       	sbiw	r28, 0x26	; 38
	buttonStringPatterns[4][0] = 0;	buttonStringPatterns[4][1] = 0;
     6ae:	a8 96       	adiw	r28, 0x28	; 40
     6b0:	1f ae       	std	Y+63, r1	; 0x3f
     6b2:	1e ae       	std	Y+62, r1	; 0x3e
     6b4:	a8 97       	sbiw	r28, 0x28	; 40
     6b6:	aa 96       	adiw	r28, 0x2a	; 42
     6b8:	1f ae       	std	Y+63, r1	; 0x3f
     6ba:	1e ae       	std	Y+62, r1	; 0x3e
     6bc:	aa 97       	sbiw	r28, 0x2a	; 42
	buttonStringPatterns[4][2] = 0;	buttonStringPatterns[4][3] = 0;
     6be:	ac 96       	adiw	r28, 0x2c	; 44
     6c0:	1f ae       	std	Y+63, r1	; 0x3f
     6c2:	1e ae       	std	Y+62, r1	; 0x3e
     6c4:	ac 97       	sbiw	r28, 0x2c	; 44
     6c6:	d1 01       	movw	r26, r2
     6c8:	1d 92       	st	X+, r1
     6ca:	1c 92       	st	X, r1
	buttonStringPatterns[4][4] = 0;	buttonStringPatterns[4][5] = 0;
     6cc:	e0 96       	adiw	r28, 0x30	; 48
     6ce:	1f ae       	std	Y+63, r1	; 0x3f
     6d0:	1e ae       	std	Y+62, r1	; 0x3e
     6d2:	e0 97       	sbiw	r28, 0x30	; 48
     6d4:	fe 01       	movw	r30, r28
     6d6:	e0 59       	subi	r30, 0x90	; 144
     6d8:	ff 4f       	sbci	r31, 0xFF	; 255
     6da:	11 82       	std	Z+1, r1	; 0x01
     6dc:	10 82       	st	Z, r1
     6de:	66 24       	eor	r6, r6
     6e0:	63 94       	inc	r6
				//  button string patterns once so we can rebuild them.
				if (configMode == 1 && controllerMode == NOTES)
				{
					clearButtonStringPatterns(buttonStringPatterns);
				}
				buttonToAssign = 0; // This variable keeps track of which button we're assigning
     6e2:	1e 82       	std	Y+6, r1	; 0x06
     6e4:	1d 82       	std	Y+5, r1	; 0x05
				plusLock = 0; // This is a tool to let us test that in the prior cycle, plus was or wasn't on
     6e6:	1b 82       	std	Y+3, r1	; 0x03
			}

			// Config Mode operation
			if (configMode == 1) 
     6e8:	b1 e0       	ldi	r27, 0x01	; 1
     6ea:	6b 16       	cp	r6, r27
     6ec:	09 f0       	breq	.+2      	; 0x6f0 <__stack+0x1f1>
     6ee:	53 c0       	rjmp	.+166    	; 0x796 <__stack+0x297>
}

//This function tests to see if we're pressing the correct string combination to end config mode
inline char testForEndConfigMode(int stringState[])
{
	if ((stringState[0] == 0b00000000) &&
     6f0:	23 2b       	or	r18, r19
     6f2:	09 f0       	breq	.+2      	; 0x6f6 <__stack+0x1f7>
     6f4:	cc c0       	rjmp	.+408    	; 0x88e <__stack+0x38f>
     6f6:	8c a5       	ldd	r24, Y+44	; 0x2c
     6f8:	9d a5       	ldd	r25, Y+45	; 0x2d
     6fa:	c0 97       	sbiw	r24, 0x30	; 48
     6fc:	09 f0       	breq	.+2      	; 0x700 <__stack+0x201>
     6fe:	c7 c0       	rjmp	.+398    	; 0x88e <__stack+0x38f>
     700:	8e a5       	ldd	r24, Y+46	; 0x2e
     702:	9f a5       	ldd	r25, Y+47	; 0x2f
     704:	c0 97       	sbiw	r24, 0x30	; 48
     706:	09 f0       	breq	.+2      	; 0x70a <__stack+0x20b>
     708:	c2 c0       	rjmp	.+388    	; 0x88e <__stack+0x38f>
     70a:	88 a9       	ldd	r24, Y+48	; 0x30
     70c:	99 a9       	ldd	r25, Y+49	; 0x31
     70e:	c0 97       	sbiw	r24, 0x30	; 48
     710:	09 f0       	breq	.+2      	; 0x714 <__stack+0x215>
     712:	bd c0       	rjmp	.+378    	; 0x88e <__stack+0x38f>
     714:	8a a9       	ldd	r24, Y+50	; 0x32
     716:	9b a9       	ldd	r25, Y+51	; 0x33
     718:	89 2b       	or	r24, r25
     71a:	09 f0       	breq	.+2      	; 0x71e <__stack+0x21f>
     71c:	b8 c0       	rjmp	.+368    	; 0x88e <__stack+0x38f>
     71e:	8c a9       	ldd	r24, Y+52	; 0x34
     720:	9d a9       	ldd	r25, Y+53	; 0x35
     722:	89 2b       	or	r24, r25
     724:	09 f0       	breq	.+2      	; 0x728 <__stack+0x229>
     726:	b3 c0       	rjmp	.+358    	; 0x88e <__stack+0x38f>
				if (testForEndConfigMode(stringState))
					{
						// Now save this new button mapping to the EEPROM 
						// Since we're already passing in buttonsStringPatterns
						// as a pointer, we don't use the '&' operator
						if (controllerMode == NOTES)
     728:	e2 e0       	ldi	r30, 0x02	; 2
     72a:	7e 16       	cp	r7, r30
     72c:	41 f4       	brne	.+16     	; 0x73e <__stack+0x23f>
     72e:	80 e0       	ldi	r24, 0x00	; 0
     730:	90 e0       	ldi	r25, 0x00	; 0
     732:	be 01       	movw	r22, r28
     734:	6a 5c       	subi	r22, 0xCA	; 202
     736:	7f 4f       	sbci	r23, 0xFF	; 255
     738:	4c e3       	ldi	r20, 0x3C	; 60
     73a:	50 e0       	ldi	r21, 0x00	; 0
     73c:	27 c0       	rjmp	.+78     	; 0x78c <__stack+0x28d>
							eeprom_write_block( (void*)buttonStringPatterns, (void*)&notesModeButtonPatterns, EEPROM_NOTES_BLOCK_SIZE);
						else if (controllerMode == CHORDS)
     73e:	f4 e0       	ldi	r31, 0x04	; 4
     740:	7f 16       	cp	r7, r31
     742:	61 f5       	brne	.+88     	; 0x79c <__stack+0x29d>
     744:	88 e7       	ldi	r24, 0x78	; 120
     746:	90 e0       	ldi	r25, 0x00	; 0
     748:	be 01       	movw	r22, r28
     74a:	6a 5c       	subi	r22, 0xCA	; 202
     74c:	7f 4f       	sbci	r23, 0xFF	; 255
     74e:	1c c0       	rjmp	.+56     	; 0x788 <__stack+0x289>
					//  The function itself can be found in processStringState.h/.c
					configSetButtonData(&data, &buttonToAssign, buttonStringPatterns, stringState, controllerMode,
											&plusLock, &previousPlusOn, &debounceTimer);

					// If we've assigned allcolors in Notes mode, cycle back to programming Green 
					if (controllerMode == NOTES && buttonToAssign >= NUM_NOTES_BUTTONS && plusLock == 0 )
     750:	8d 81       	ldd	r24, Y+5	; 0x05
     752:	9e 81       	ldd	r25, Y+6	; 0x06
     754:	05 97       	sbiw	r24, 0x05	; 5
     756:	0c f4       	brge	.+2      	; 0x75a <__stack+0x25b>
     758:	8e c0       	rjmp	.+284    	; 0x876 <__stack+0x377>
     75a:	8b 81       	ldd	r24, Y+3	; 0x03
     75c:	88 23       	and	r24, r24
     75e:	09 f0       	breq	.+2      	; 0x762 <__stack+0x263>
     760:	8a c0       	rjmp	.+276    	; 0x876 <__stack+0x377>
					{
						buttonToAssign = 0;
     762:	1e 82       	std	Y+6, r1	; 0x06
     764:	1d 82       	std	Y+5, r1	; 0x05
     766:	87 c0       	rjmp	.+270    	; 0x876 <__stack+0x377>
					}
					
					// Or if we've programmed all 10 notes in Chord mode, exit programming mode
					if (controllerMode == CHORDS && buttonToAssign >= NUM_CHORDS_BUTTONS && plusLock == 0 )
     768:	84 e0       	ldi	r24, 0x04	; 4
     76a:	78 16       	cp	r7, r24
     76c:	09 f0       	breq	.+2      	; 0x770 <__stack+0x271>
     76e:	83 c0       	rjmp	.+262    	; 0x876 <__stack+0x377>
     770:	8d 81       	ldd	r24, Y+5	; 0x05
     772:	9e 81       	ldd	r25, Y+6	; 0x06
     774:	0a 97       	sbiw	r24, 0x0a	; 10
     776:	0c f4       	brge	.+2      	; 0x77a <__stack+0x27b>
     778:	7e c0       	rjmp	.+252    	; 0x876 <__stack+0x377>
     77a:	8b 81       	ldd	r24, Y+3	; 0x03
     77c:	88 23       	and	r24, r24
     77e:	09 f0       	breq	.+2      	; 0x782 <__stack+0x283>
     780:	7a c0       	rjmp	.+244    	; 0x876 <__stack+0x377>
     782:	88 e7       	ldi	r24, 0x78	; 120
     784:	90 e0       	ldi	r25, 0x00	; 0
     786:	b2 01       	movw	r22, r4
     788:	48 e7       	ldi	r20, 0x78	; 120
     78a:	50 e0       	ldi	r21, 0x00	; 0
     78c:	28 eb       	ldi	r18, 0xB8	; 184
     78e:	30 e0       	ldi	r19, 0x00	; 0
     790:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <__eewr_block>
     794:	03 c0       	rjmp	.+6      	; 0x79c <__stack+0x29d>
					}
		}	}	}	 // End of Config Mode code

		
		// Normal operation
		if (configMode == 0)
     796:	66 20       	and	r6, r6
     798:	09 f0       	breq	.+2      	; 0x79c <__stack+0x29d>
     79a:	6d c0       	rjmp	.+218    	; 0x876 <__stack+0x377>
}

inline int testForSwitchModes(int stringState[])
{
	// Test for the right keypress to start the mode
	if ((stringState[0] == 0b00000000) &&
     79c:	8a a5       	ldd	r24, Y+42	; 0x2a
     79e:	9b a5       	ldd	r25, Y+43	; 0x2b
     7a0:	89 2b       	or	r24, r25
     7a2:	09 f0       	breq	.+2      	; 0x7a6 <__stack+0x2a7>
     7a4:	4d c0       	rjmp	.+154    	; 0x840 <__stack+0x341>
     7a6:	8c a5       	ldd	r24, Y+44	; 0x2c
     7a8:	9d a5       	ldd	r25, Y+45	; 0x2d
     7aa:	89 2b       	or	r24, r25
     7ac:	09 f0       	breq	.+2      	; 0x7b0 <__stack+0x2b1>
     7ae:	48 c0       	rjmp	.+144    	; 0x840 <__stack+0x341>
     7b0:	8e a5       	ldd	r24, Y+46	; 0x2e
     7b2:	9f a5       	ldd	r25, Y+47	; 0x2f
     7b4:	88 31       	cpi	r24, 0x18	; 24
     7b6:	91 05       	cpc	r25, r1
     7b8:	89 f4       	brne	.+34     	; 0x7dc <__stack+0x2dd>
     7ba:	88 a9       	ldd	r24, Y+48	; 0x30
     7bc:	99 a9       	ldd	r25, Y+49	; 0x31
     7be:	48 97       	sbiw	r24, 0x18	; 24
     7c0:	09 f0       	breq	.+2      	; 0x7c4 <__stack+0x2c5>
     7c2:	3e c0       	rjmp	.+124    	; 0x840 <__stack+0x341>
     7c4:	8a a9       	ldd	r24, Y+50	; 0x32
     7c6:	9b a9       	ldd	r25, Y+51	; 0x33
     7c8:	48 97       	sbiw	r24, 0x18	; 24
     7ca:	d1 f5       	brne	.+116    	; 0x840 <__stack+0x341>
     7cc:	8c a9       	ldd	r24, Y+52	; 0x34
     7ce:	9d a9       	ldd	r25, Y+53	; 0x35
     7d0:	89 2b       	or	r24, r25
     7d2:	b1 f5       	brne	.+108    	; 0x840 <__stack+0x341>
static inline void switchPlayModes(int stringState[], int buttonStringPatterns[][6], char* controllerMode)
{
	// Test for the right keypress to start the mode
	if (testForSwitchModes(stringState))
	{
		if (*controllerMode % 2 == 0) // This means that the mode is a full mode
     7d4:	70 fc       	sbrc	r7, 0
     7d6:	34 c0       	rjmp	.+104    	; 0x840 <__stack+0x341>
			{++*controllerMode;}  //This puts it into a transitional mode
     7d8:	73 94       	inc	r7
     7da:	32 c0       	rjmp	.+100    	; 0x840 <__stack+0x341>
		return 0;
}

inline int testForNoStringsPressed(int stringState[])
{
	if ((stringState[0] == 0b00000000) &&
     7dc:	89 2b       	or	r24, r25
     7de:	81 f5       	brne	.+96     	; 0x840 <__stack+0x341>
     7e0:	88 a9       	ldd	r24, Y+48	; 0x30
     7e2:	99 a9       	ldd	r25, Y+49	; 0x31
     7e4:	89 2b       	or	r24, r25
     7e6:	61 f5       	brne	.+88     	; 0x840 <__stack+0x341>
     7e8:	8a a9       	ldd	r24, Y+50	; 0x32
     7ea:	9b a9       	ldd	r25, Y+51	; 0x33
     7ec:	89 2b       	or	r24, r25
     7ee:	41 f5       	brne	.+80     	; 0x840 <__stack+0x341>
     7f0:	8c a9       	ldd	r24, Y+52	; 0x34
     7f2:	9d a9       	ldd	r25, Y+53	; 0x35
     7f4:	89 2b       	or	r24, r25
     7f6:	21 f5       	brne	.+72     	; 0x840 <__stack+0x341>
	}
	// And if we're not pressing that anymore, switch from the transitional mode to the regular mode,
	//  resetting the button patterns as necessary
	else if(testForNoStringsPressed(stringState)) 
	{
		if (*controllerMode == CHORDS_TO_FRETS) // since these modes are just numbers, we need to wrap around
     7f8:	95 e0       	ldi	r25, 0x05	; 5
     7fa:	79 16       	cp	r7, r25
     7fc:	11 f4       	brne	.+4      	; 0x802 <__stack+0x303>
     7fe:	77 24       	eor	r7, r7
     800:	1f c0       	rjmp	.+62     	; 0x840 <__stack+0x341>
			{*controllerMode = FRETS;}

		// Now, reset the buttonStringPattern array to be appropriate for the mode
		// For this, we'll read it from the EEPROM memory.
		else if (*controllerMode  == FRETS_TO_NOTES)
     802:	a1 e0       	ldi	r26, 0x01	; 1
     804:	7a 16       	cp	r7, r26
     806:	69 f4       	brne	.+26     	; 0x822 <__stack+0x323>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
     808:	ce 01       	movw	r24, r28
     80a:	c6 96       	adiw	r24, 0x36	; 54
     80c:	60 e0       	ldi	r22, 0x00	; 0
     80e:	70 e0       	ldi	r23, 0x00	; 0
     810:	4c e3       	ldi	r20, 0x3C	; 60
     812:	50 e0       	ldi	r21, 0x00	; 0
     814:	20 eb       	ldi	r18, 0xB0	; 176
     816:	30 e0       	ldi	r19, 0x00	; 0
     818:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <__eerd_block>
     81c:	52 e0       	ldi	r21, 0x02	; 2
     81e:	75 2e       	mov	r7, r21
     820:	0f c0       	rjmp	.+30     	; 0x840 <__stack+0x341>
		{
			// Notice, we're already passing in buttonStringPatterns as an address, so the EEPROM read looks a bit strange
			eeprom_read_block( (void*)buttonStringPatterns, (void*)&notesModeButtonPatterns, EEPROM_NOTES_BLOCK_SIZE);
			*controllerMode = NOTES;
		}
		else if (*controllerMode  == NOTES_TO_CHORDS)
     822:	b3 e0       	ldi	r27, 0x03	; 3
     824:	7b 16       	cp	r7, r27
     826:	61 f4       	brne	.+24     	; 0x840 <__stack+0x341>
     828:	ce 01       	movw	r24, r28
     82a:	c6 96       	adiw	r24, 0x36	; 54
     82c:	68 e7       	ldi	r22, 0x78	; 120
     82e:	70 e0       	ldi	r23, 0x00	; 0
     830:	48 e7       	ldi	r20, 0x78	; 120
     832:	50 e0       	ldi	r21, 0x00	; 0
     834:	20 eb       	ldi	r18, 0xB0	; 176
     836:	30 e0       	ldi	r19, 0x00	; 0
     838:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <__eerd_block>
     83c:	44 e0       	ldi	r20, 0x04	; 4
     83e:	74 2e       	mov	r7, r20
			switchPlayModes(stringState, buttonStringPatterns, &controllerMode);

			// Next, using our strumState array, we process that data to figure out what sort
			//  of buttons on the controller we want to emulate pressing.
			// find out if we're in a transitional controller mode or not
			if (!(controllerMode % 2)) // Not a transitional mode
     840:	67 2d       	mov	r22, r7
     842:	ce 01       	movw	r24, r28
     844:	09 96       	adiw	r24, 0x09	; 9
     846:	70 fc       	sbrc	r7, 0
     848:	12 c0       	rjmp	.+36     	; 0x86e <__stack+0x36f>
			{	//  This function can be found in processStringState.h/.c
				processStringState(&data, stringState, buttonStringPatterns, controllerMode, greenTimers, triedGreen);
     84a:	be 01       	movw	r22, r28
     84c:	66 5d       	subi	r22, 0xD6	; 214
     84e:	7f 4f       	sbci	r23, 0xFF	; 255
     850:	ae 01       	movw	r20, r28
     852:	4a 5c       	subi	r20, 0xCA	; 202
     854:	5f 4f       	sbci	r21, 0xFF	; 255
     856:	27 2d       	mov	r18, r7
     858:	8e 01       	movw	r16, r28
     85a:	0e 5e       	subi	r16, 0xEE	; 238
     85c:	1f 4f       	sbci	r17, 0xFF	; 255
     85e:	3e e1       	ldi	r19, 0x1E	; 30
     860:	e3 2e       	mov	r14, r19
     862:	f1 2c       	mov	r15, r1
     864:	ec 0e       	add	r14, r28
     866:	fd 1e       	adc	r15, r29
     868:	0e 94 6e 08 	call	0x10dc	; 0x10dc <processStringState>
     86c:	03 c0       	rjmp	.+6      	; 0x874 <__stack+0x375>
			}
			else
			{   // Now, if we're in a transitional controller mode, we'll forget that data and substitue 
				// visual cue data to show that we're changing to a specific mode
				//  The function itself can be found in processStringState.h/.c
				displayTransitionState(&data, controllerMode);
     86e:	70 e0       	ldi	r23, 0x00	; 0
     870:	0e 94 85 08 	call	0x110a	; 0x110a <displayTransitionState>
     874:	66 24       	eor	r6, r6
		}
			    
		// Now our processing is complete, so using those button presses, we set up the 
		// button data packet. This function depends on the console and is 
		// set specially in the interface functions - see ps3interface.h, wiiinterface.h, etc.
		sendData(data);
     876:	09 85       	ldd	r16, Y+9	; 0x09
     878:	1a 85       	ldd	r17, Y+10	; 0x0a
     87a:	2b 85       	ldd	r18, Y+11	; 0x0b
     87c:	3c 85       	ldd	r19, Y+12	; 0x0c
     87e:	4d 85       	ldd	r20, Y+13	; 0x0d
     880:	5e 85       	ldd	r21, Y+14	; 0x0e
     882:	6f 85       	ldd	r22, Y+15	; 0x0f
     884:	78 89       	ldd	r23, Y+16	; 0x10
     886:	89 89       	ldd	r24, Y+17	; 0x11
     888:	0e 94 34 0a 	call	0x1468	; 0x1468 <sendData>
     88c:	4b cd       	rjmp	.-1386   	; 0x324 <main+0xe4>
				else
				{
					// Now set up the data packet to the Wii to say we're pressing whatever button we're currently
					// assigning, and if we're pressing 'plus', go ahead and lock that string combination in
					//  The function itself can be found in processStringState.h/.c
					configSetButtonData(&data, &buttonToAssign, buttonStringPatterns, stringState, controllerMode,
     88e:	b6 e3       	ldi	r27, 0x36	; 54
     890:	4b 2e       	mov	r4, r27
     892:	51 2c       	mov	r5, r1
     894:	4c 0e       	add	r4, r28
     896:	5d 1e       	adc	r5, r29
     898:	ce 01       	movw	r24, r28
     89a:	09 96       	adiw	r24, 0x09	; 9
     89c:	be 01       	movw	r22, r28
     89e:	6b 5f       	subi	r22, 0xFB	; 251
     8a0:	7f 4f       	sbci	r23, 0xFF	; 255
     8a2:	a2 01       	movw	r20, r4
     8a4:	9e 01       	movw	r18, r28
     8a6:	26 5d       	subi	r18, 0xD6	; 214
     8a8:	3f 4f       	sbci	r19, 0xFF	; 255
     8aa:	07 2d       	mov	r16, r7
     8ac:	a3 e0       	ldi	r26, 0x03	; 3
     8ae:	ea 2e       	mov	r14, r26
     8b0:	f1 2c       	mov	r15, r1
     8b2:	ec 0e       	add	r14, r28
     8b4:	fd 1e       	adc	r15, r29
     8b6:	f4 e0       	ldi	r31, 0x04	; 4
     8b8:	cf 2e       	mov	r12, r31
     8ba:	d1 2c       	mov	r13, r1
     8bc:	cc 0e       	add	r12, r28
     8be:	dd 1e       	adc	r13, r29
     8c0:	e7 e0       	ldi	r30, 0x07	; 7
     8c2:	ae 2e       	mov	r10, r30
     8c4:	b1 2c       	mov	r11, r1
     8c6:	ac 0e       	add	r10, r28
     8c8:	bd 1e       	adc	r11, r29
     8ca:	0e 94 9b 08 	call	0x1136	; 0x1136 <configSetButtonData>
											&plusLock, &previousPlusOn, &debounceTimer);

					// If we've assigned allcolors in Notes mode, cycle back to programming Green 
					if (controllerMode == NOTES && buttonToAssign >= NUM_NOTES_BUTTONS && plusLock == 0 )
     8ce:	e2 e0       	ldi	r30, 0x02	; 2
     8d0:	7e 16       	cp	r7, r30
     8d2:	09 f0       	breq	.+2      	; 0x8d6 <__stack+0x3d7>
     8d4:	49 cf       	rjmp	.-366    	; 0x768 <__stack+0x269>
     8d6:	3c cf       	rjmp	.-392    	; 0x750 <__stack+0x251>

000008d8 <setPins>:
#include "guitarInitFunctions.h"

void setPins(void)
{
	// Set the fret pins as input pins, with internal resistor
	fret_ddr &= ~(1<<green_pin);        // input
     8d8:	21 98       	cbi	0x04, 1	; 4
	fret_port |= (1<<green_pin);		//pull-up enabled	
     8da:	29 9a       	sbi	0x05, 1	; 5
	fret_ddr &= ~(1<<red_pin);
     8dc:	22 98       	cbi	0x04, 2	; 4
	fret_port |= (1<<red_pin);
     8de:	2a 9a       	sbi	0x05, 2	; 5
	fret_ddr &= ~(1<<yellow_pin);
     8e0:	23 98       	cbi	0x04, 3	; 4
	fret_port |= (1<<yellow_pin);
     8e2:	2b 9a       	sbi	0x05, 3	; 5
	fret_ddr &= ~(1<<blue_pin);
     8e4:	24 98       	cbi	0x04, 4	; 4
	fret_port |= (1<<blue_pin);
     8e6:	2c 9a       	sbi	0x05, 4	; 5
	fret_ddr &= ~(1<<orange_pin);
     8e8:	25 98       	cbi	0x04, 5	; 4
	fret_port |= (1<<orange_pin);
     8ea:	2d 9a       	sbi	0x05, 5	; 5

	// Set the pins on strumming and plus as inputs, with internal resistor
	misc_ddr &= ~(1<<plus_pin);
     8ec:	38 98       	cbi	0x07, 0	; 7
	misc_port |= (1<<plus_pin);
     8ee:	40 9a       	sbi	0x08, 0	; 8
	misc_ddr &= ~(1<<minus_pin);
     8f0:	39 98       	cbi	0x07, 1	; 7
	misc_port |= (1<<minus_pin);
     8f2:	41 9a       	sbi	0x08, 1	; 8

	pick_ddr &= ~(1<<strum_pin);
     8f4:	3a 98       	cbi	0x07, 2	; 7
	pick_port |= (1<<strum_pin);
     8f6:	42 9a       	sbi	0x08, 2	; 8

	// Set the string pins as output pins, outputting HIGH
	/* MAKE SURE YOU HAVE DIODES OPPOSING THIS CURRENT OUTFLOW! */
	string_ddr |= (1<<first_string);  //output
     8f8:	57 9a       	sbi	0x0a, 7	; 10
	string_port |= (1<<first_string); // set high
     8fa:	5f 9a       	sbi	0x0b, 7	; 11
	string_ddr |= (1<<second_string);  
     8fc:	56 9a       	sbi	0x0a, 6	; 10
	string_port |= (1<<second_string);
     8fe:	5e 9a       	sbi	0x0b, 6	; 11
	string_ddr |= (1<<third_string);  
     900:	55 9a       	sbi	0x0a, 5	; 10
	string_port |= (1<<third_string);
     902:	5d 9a       	sbi	0x0b, 5	; 11
	string_ddr |= (1<<fourth_string);  
     904:	52 9a       	sbi	0x0a, 2	; 10
	string_port |= (1<<fourth_string);
     906:	5a 9a       	sbi	0x0b, 2	; 11
	string_ddr |= (1<<fifth_string);  
     908:	51 9a       	sbi	0x0a, 1	; 10
	string_port |= (1<<fifth_string);
     90a:	59 9a       	sbi	0x0b, 1	; 11
	string_ddr |= (1<<sixth_string);  
     90c:	50 9a       	sbi	0x0a, 0	; 10
	string_port |= (1<<sixth_string);
     90e:	58 9a       	sbi	0x0b, 0	; 11
}
     910:	08 95       	ret

00000912 <setTimer>:

void setTimer(void) //This sets up a timer to handle the green button thing
{
	PRR &= ~(1<<PRTIM1);	// ensure power to Timer/Counter1
     912:	e4 e6       	ldi	r30, 0x64	; 100
     914:	f0 e0       	ldi	r31, 0x00	; 0
     916:	80 81       	ld	r24, Z
     918:	87 7f       	andi	r24, 0xF7	; 247
     91a:	80 83       	st	Z, r24

	TCCR1A &= ~(1<<COM1A1);  // This prevents OC2A pin from doing anything
     91c:	e0 e8       	ldi	r30, 0x80	; 128
     91e:	f0 e0       	ldi	r31, 0x00	; 0
     920:	80 81       	ld	r24, Z
     922:	8f 77       	andi	r24, 0x7F	; 127
     924:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<COM1A0);  //  to the pins on the chip. Otherwise, we might
     926:	80 81       	ld	r24, Z
     928:	8f 7b       	andi	r24, 0xBF	; 191
     92a:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<COM1B1);  //  get signals coming out of some of the pins we might use
     92c:	80 81       	ld	r24, Z
     92e:	8f 7d       	andi	r24, 0xDF	; 223
     930:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<COM1B0);
     932:	80 81       	ld	r24, Z
     934:	8f 7e       	andi	r24, 0xEF	; 239
     936:	80 83       	st	Z, r24

	TCCR1A &= ~(1<<WGM11);  // These bits set up normal mode on the Waveform Generation
     938:	80 81       	ld	r24, Z
     93a:	8d 7f       	andi	r24, 0xFD	; 253
     93c:	80 83       	st	Z, r24
	TCCR1A &= ~(1<<WGM10);  // This means that the counter acts like a normal timer,
     93e:	80 81       	ld	r24, Z
     940:	8e 7f       	andi	r24, 0xFE	; 254
     942:	80 83       	st	Z, r24
	TCCR1B &= ~(1<<WGM12);  // not some sort of fancy digital-analog converter or anything
     944:	e1 e8       	ldi	r30, 0x81	; 129
     946:	f0 e0       	ldi	r31, 0x00	; 0
     948:	80 81       	ld	r24, Z
     94a:	87 7f       	andi	r24, 0xF7	; 247
     94c:	80 83       	st	Z, r24
	TCCR1B &= ~(1<<WGM13);  // It counts up to 65536 and overflows to zero
     94e:	80 81       	ld	r24, Z
     950:	8f 7e       	andi	r24, 0xEF	; 239
     952:	80 83       	st	Z, r24

	TCCR1B |= (1<<CS12);   // These set the clock to CPU (8MHz) / 1024 
     954:	80 81       	ld	r24, Z
     956:	84 60       	ori	r24, 0x04	; 4
     958:	80 83       	st	Z, r24
	TCCR1B &= ~(1<<CS11);  // or roughly 8 kHz (7.8125 kHz)
     95a:	80 81       	ld	r24, Z
     95c:	8d 7f       	andi	r24, 0xFD	; 253
     95e:	80 83       	st	Z, r24
	TCCR1B |= (1<<CS10);   // When counting from zero to 0xFFFF, it takes about 8 seconds
     960:	80 81       	ld	r24, Z
     962:	81 60       	ori	r24, 0x01	; 1
     964:	80 83       	st	Z, r24

	// The counter's value is stored in TCNT1
}
     966:	08 95       	ret

00000968 <processChords>:
*/
#include "processStringState.h"

void processChords(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
     968:	0f 93       	push	r16
     96a:	1f 93       	push	r17
     96c:	cf 93       	push	r28
     96e:	df 93       	push	r29
     970:	8c 01       	movw	r16, r24
     972:	fb 01       	movw	r30, r22
     974:	ea 01       	movw	r28, r20
     976:	20 e0       	ldi	r18, 0x00	; 0
     978:	30 e0       	ldi	r19, 0x00	; 0
				data->downOn = 1;
				data->upOn   = 0;
			}
			else
			{
				data->upOn   = 1;
     97a:	41 e0       	ldi	r20, 0x01	; 1
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
	// First take care of registering strumming
	for (int guitarString = 0; guitarString < 6; guitarString++)
	{
		if (stringState[guitarString] & 1)
     97c:	db 01       	movw	r26, r22
     97e:	8d 91       	ld	r24, X+
     980:	9c 91       	ld	r25, X
     982:	11 97       	sbiw	r26, 0x01	; 1
     984:	80 ff       	sbrs	r24, 0
     986:	13 c0       	rjmp	.+38     	; 0x9ae <processChords+0x46>
		{
			stringState[guitarString] &= ~1; //Set the last bit to zero
     988:	8e 7f       	andi	r24, 0xFE	; 254
     98a:	8d 93       	st	X+, r24
     98c:	9c 93       	st	X, r25
			if (guitarString < 3)
     98e:	23 30       	cpi	r18, 0x03	; 3
     990:	31 05       	cpc	r19, r1
     992:	3c f4       	brge	.+14     	; 0x9a2 <processChords+0x3a>
			{
				data->downOn = 1;
     994:	d8 01       	movw	r26, r16
     996:	16 96       	adiw	r26, 0x06	; 6
     998:	4c 93       	st	X, r20
     99a:	16 97       	sbiw	r26, 0x06	; 6
				data->upOn   = 0;
     99c:	15 96       	adiw	r26, 0x05	; 5
     99e:	1c 92       	st	X, r1
     9a0:	06 c0       	rjmp	.+12     	; 0x9ae <processChords+0x46>
			}
			else
			{
				data->upOn   = 1;
     9a2:	d8 01       	movw	r26, r16
     9a4:	15 96       	adiw	r26, 0x05	; 5
     9a6:	4c 93       	st	X, r20
     9a8:	15 97       	sbiw	r26, 0x05	; 5
				data->downOn = 0;
     9aa:	16 96       	adiw	r26, 0x06	; 6
     9ac:	1c 92       	st	X, r1

void processChords(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
	// First take care of registering strumming
	for (int guitarString = 0; guitarString < 6; guitarString++)
     9ae:	2f 5f       	subi	r18, 0xFF	; 255
     9b0:	3f 4f       	sbci	r19, 0xFF	; 255
     9b2:	6e 5f       	subi	r22, 0xFE	; 254
     9b4:	7f 4f       	sbci	r23, 0xFF	; 255
     9b6:	26 30       	cpi	r18, 0x06	; 6
     9b8:	31 05       	cpc	r19, r1
     9ba:	01 f7       	brne	.-64     	; 0x97c <processChords+0x14>
			}
		}
	}

	// First, save us some trouble and see if we're not pressing anything at all..
	if ((stringState[0] == 0b00000000) &&
     9bc:	40 81       	ld	r20, Z
     9be:	51 81       	ldd	r21, Z+1	; 0x01
     9c0:	41 15       	cp	r20, r1
     9c2:	51 05       	cpc	r21, r1
     9c4:	a9 f4       	brne	.+42     	; 0x9f0 <processChords+0x88>
     9c6:	82 81       	ldd	r24, Z+2	; 0x02
     9c8:	93 81       	ldd	r25, Z+3	; 0x03
     9ca:	89 2b       	or	r24, r25
     9cc:	89 f4       	brne	.+34     	; 0x9f0 <processChords+0x88>
     9ce:	84 81       	ldd	r24, Z+4	; 0x04
     9d0:	95 81       	ldd	r25, Z+5	; 0x05
     9d2:	89 2b       	or	r24, r25
     9d4:	69 f4       	brne	.+26     	; 0x9f0 <processChords+0x88>
     9d6:	86 81       	ldd	r24, Z+6	; 0x06
     9d8:	97 81       	ldd	r25, Z+7	; 0x07
     9da:	89 2b       	or	r24, r25
     9dc:	49 f4       	brne	.+18     	; 0x9f0 <processChords+0x88>
     9de:	80 85       	ldd	r24, Z+8	; 0x08
     9e0:	91 85       	ldd	r25, Z+9	; 0x09
     9e2:	89 2b       	or	r24, r25
     9e4:	29 f4       	brne	.+10     	; 0x9f0 <processChords+0x88>
     9e6:	82 85       	ldd	r24, Z+10	; 0x0a
     9e8:	93 85       	ldd	r25, Z+11	; 0x0b
     9ea:	89 2b       	or	r24, r25
     9ec:	09 f4       	brne	.+2      	; 0x9f0 <processChords+0x88>
     9ee:	31 c2       	rjmp	.+1122   	; 0xe52 <processChords+0x4ea>
		return;

	// Now see if what's being played on the fretboard matches any of the button patterns in
	//  buttonStringPatterns
	// green
	if(stringState[0] == buttonStringPatterns[0][0] &&
     9f0:	88 81       	ld	r24, Y
     9f2:	99 81       	ldd	r25, Y+1	; 0x01
     9f4:	48 17       	cp	r20, r24
     9f6:	59 07       	cpc	r21, r25
     9f8:	39 f5       	brne	.+78     	; 0xa48 <processChords+0xe0>
     9fa:	22 81       	ldd	r18, Z+2	; 0x02
     9fc:	33 81       	ldd	r19, Z+3	; 0x03
     9fe:	8a 81       	ldd	r24, Y+2	; 0x02
     a00:	9b 81       	ldd	r25, Y+3	; 0x03
     a02:	28 17       	cp	r18, r24
     a04:	39 07       	cpc	r19, r25
     a06:	01 f5       	brne	.+64     	; 0xa48 <processChords+0xe0>
     a08:	24 81       	ldd	r18, Z+4	; 0x04
     a0a:	35 81       	ldd	r19, Z+5	; 0x05
     a0c:	8c 81       	ldd	r24, Y+4	; 0x04
     a0e:	9d 81       	ldd	r25, Y+5	; 0x05
     a10:	28 17       	cp	r18, r24
     a12:	39 07       	cpc	r19, r25
     a14:	c9 f4       	brne	.+50     	; 0xa48 <processChords+0xe0>
     a16:	26 81       	ldd	r18, Z+6	; 0x06
     a18:	37 81       	ldd	r19, Z+7	; 0x07
     a1a:	8e 81       	ldd	r24, Y+6	; 0x06
     a1c:	9f 81       	ldd	r25, Y+7	; 0x07
     a1e:	28 17       	cp	r18, r24
     a20:	39 07       	cpc	r19, r25
     a22:	91 f4       	brne	.+36     	; 0xa48 <processChords+0xe0>
     a24:	20 85       	ldd	r18, Z+8	; 0x08
     a26:	31 85       	ldd	r19, Z+9	; 0x09
     a28:	88 85       	ldd	r24, Y+8	; 0x08
     a2a:	99 85       	ldd	r25, Y+9	; 0x09
     a2c:	28 17       	cp	r18, r24
     a2e:	39 07       	cpc	r19, r25
     a30:	59 f4       	brne	.+22     	; 0xa48 <processChords+0xe0>
     a32:	22 85       	ldd	r18, Z+10	; 0x0a
     a34:	33 85       	ldd	r19, Z+11	; 0x0b
     a36:	8a 85       	ldd	r24, Y+10	; 0x0a
     a38:	9b 85       	ldd	r25, Y+11	; 0x0b
     a3a:	28 17       	cp	r18, r24
     a3c:	39 07       	cpc	r19, r25
     a3e:	21 f4       	brne	.+8      	; 0xa48 <processChords+0xe0>
	   stringState[2] == buttonStringPatterns[0][2] &&
	   stringState[3] == buttonStringPatterns[0][3] &&
	   stringState[4] == buttonStringPatterns[0][4] &&
	   stringState[5] == buttonStringPatterns[0][5]  ) 
		{
			data->greenOn = 1;
     a40:	81 e0       	ldi	r24, 0x01	; 1
     a42:	f8 01       	movw	r30, r16
     a44:	80 83       	st	Z, r24
     a46:	05 c2       	rjmp	.+1034   	; 0xe52 <processChords+0x4ea>
  		}
	// red
	else if(stringState[0] == buttonStringPatterns[1][0] &&
     a48:	de 01       	movw	r26, r28
     a4a:	1c 96       	adiw	r26, 0x0c	; 12
     a4c:	8c 85       	ldd	r24, Y+12	; 0x0c
     a4e:	9d 85       	ldd	r25, Y+13	; 0x0d
     a50:	48 17       	cp	r20, r24
     a52:	59 07       	cpc	r21, r25
     a54:	81 f5       	brne	.+96     	; 0xab6 <processChords+0x14e>
     a56:	22 81       	ldd	r18, Z+2	; 0x02
     a58:	33 81       	ldd	r19, Z+3	; 0x03
     a5a:	12 96       	adiw	r26, 0x02	; 2
     a5c:	8d 91       	ld	r24, X+
     a5e:	9c 91       	ld	r25, X
     a60:	13 97       	sbiw	r26, 0x03	; 3
     a62:	28 17       	cp	r18, r24
     a64:	39 07       	cpc	r19, r25
     a66:	39 f5       	brne	.+78     	; 0xab6 <processChords+0x14e>
     a68:	24 81       	ldd	r18, Z+4	; 0x04
     a6a:	35 81       	ldd	r19, Z+5	; 0x05
     a6c:	14 96       	adiw	r26, 0x04	; 4
     a6e:	8d 91       	ld	r24, X+
     a70:	9c 91       	ld	r25, X
     a72:	15 97       	sbiw	r26, 0x05	; 5
     a74:	28 17       	cp	r18, r24
     a76:	39 07       	cpc	r19, r25
     a78:	f1 f4       	brne	.+60     	; 0xab6 <processChords+0x14e>
     a7a:	26 81       	ldd	r18, Z+6	; 0x06
     a7c:	37 81       	ldd	r19, Z+7	; 0x07
     a7e:	16 96       	adiw	r26, 0x06	; 6
     a80:	8d 91       	ld	r24, X+
     a82:	9c 91       	ld	r25, X
     a84:	17 97       	sbiw	r26, 0x07	; 7
     a86:	28 17       	cp	r18, r24
     a88:	39 07       	cpc	r19, r25
     a8a:	a9 f4       	brne	.+42     	; 0xab6 <processChords+0x14e>
     a8c:	20 85       	ldd	r18, Z+8	; 0x08
     a8e:	31 85       	ldd	r19, Z+9	; 0x09
     a90:	18 96       	adiw	r26, 0x08	; 8
     a92:	8d 91       	ld	r24, X+
     a94:	9c 91       	ld	r25, X
     a96:	19 97       	sbiw	r26, 0x09	; 9
     a98:	28 17       	cp	r18, r24
     a9a:	39 07       	cpc	r19, r25
     a9c:	61 f4       	brne	.+24     	; 0xab6 <processChords+0x14e>
     a9e:	22 85       	ldd	r18, Z+10	; 0x0a
     aa0:	33 85       	ldd	r19, Z+11	; 0x0b
     aa2:	1a 96       	adiw	r26, 0x0a	; 10
     aa4:	8d 91       	ld	r24, X+
     aa6:	9c 91       	ld	r25, X
     aa8:	1b 97       	sbiw	r26, 0x0b	; 11
     aaa:	28 17       	cp	r18, r24
     aac:	39 07       	cpc	r19, r25
     aae:	19 f4       	brne	.+6      	; 0xab6 <processChords+0x14e>
	   stringState[2] == buttonStringPatterns[1][2] &&
	   stringState[3] == buttonStringPatterns[1][3] &&
	   stringState[4] == buttonStringPatterns[1][4] &&
	   stringState[5] == buttonStringPatterns[1][5]  ) 
		{
			data->redOn = 1;
     ab0:	81 e0       	ldi	r24, 0x01	; 1
     ab2:	d8 01       	movw	r26, r16
     ab4:	dd c0       	rjmp	.+442    	; 0xc70 <processChords+0x308>
  		}

	// yellow
	else if(stringState[0] == buttonStringPatterns[2][0] &&
     ab6:	de 01       	movw	r26, r28
     ab8:	58 96       	adiw	r26, 0x18	; 24
     aba:	88 8d       	ldd	r24, Y+24	; 0x18
     abc:	99 8d       	ldd	r25, Y+25	; 0x19
     abe:	48 17       	cp	r20, r24
     ac0:	59 07       	cpc	r21, r25
     ac2:	81 f5       	brne	.+96     	; 0xb24 <processChords+0x1bc>
     ac4:	22 81       	ldd	r18, Z+2	; 0x02
     ac6:	33 81       	ldd	r19, Z+3	; 0x03
     ac8:	12 96       	adiw	r26, 0x02	; 2
     aca:	8d 91       	ld	r24, X+
     acc:	9c 91       	ld	r25, X
     ace:	13 97       	sbiw	r26, 0x03	; 3
     ad0:	28 17       	cp	r18, r24
     ad2:	39 07       	cpc	r19, r25
     ad4:	39 f5       	brne	.+78     	; 0xb24 <processChords+0x1bc>
     ad6:	24 81       	ldd	r18, Z+4	; 0x04
     ad8:	35 81       	ldd	r19, Z+5	; 0x05
     ada:	14 96       	adiw	r26, 0x04	; 4
     adc:	8d 91       	ld	r24, X+
     ade:	9c 91       	ld	r25, X
     ae0:	15 97       	sbiw	r26, 0x05	; 5
     ae2:	28 17       	cp	r18, r24
     ae4:	39 07       	cpc	r19, r25
     ae6:	f1 f4       	brne	.+60     	; 0xb24 <processChords+0x1bc>
     ae8:	26 81       	ldd	r18, Z+6	; 0x06
     aea:	37 81       	ldd	r19, Z+7	; 0x07
     aec:	16 96       	adiw	r26, 0x06	; 6
     aee:	8d 91       	ld	r24, X+
     af0:	9c 91       	ld	r25, X
     af2:	17 97       	sbiw	r26, 0x07	; 7
     af4:	28 17       	cp	r18, r24
     af6:	39 07       	cpc	r19, r25
     af8:	a9 f4       	brne	.+42     	; 0xb24 <processChords+0x1bc>
     afa:	20 85       	ldd	r18, Z+8	; 0x08
     afc:	31 85       	ldd	r19, Z+9	; 0x09
     afe:	18 96       	adiw	r26, 0x08	; 8
     b00:	8d 91       	ld	r24, X+
     b02:	9c 91       	ld	r25, X
     b04:	19 97       	sbiw	r26, 0x09	; 9
     b06:	28 17       	cp	r18, r24
     b08:	39 07       	cpc	r19, r25
     b0a:	61 f4       	brne	.+24     	; 0xb24 <processChords+0x1bc>
     b0c:	22 85       	ldd	r18, Z+10	; 0x0a
     b0e:	33 85       	ldd	r19, Z+11	; 0x0b
     b10:	1a 96       	adiw	r26, 0x0a	; 10
     b12:	8d 91       	ld	r24, X+
     b14:	9c 91       	ld	r25, X
     b16:	1b 97       	sbiw	r26, 0x0b	; 11
     b18:	28 17       	cp	r18, r24
     b1a:	39 07       	cpc	r19, r25
     b1c:	19 f4       	brne	.+6      	; 0xb24 <processChords+0x1bc>
	   stringState[2] == buttonStringPatterns[2][2] &&
	   stringState[3] == buttonStringPatterns[2][3] &&
	   stringState[4] == buttonStringPatterns[2][4] &&
	   stringState[5] == buttonStringPatterns[2][5]  ) 
		{
			 data->yellowOn = 1;
     b1e:	81 e0       	ldi	r24, 0x01	; 1
     b20:	f8 01       	movw	r30, r16
     b22:	58 c1       	rjmp	.+688    	; 0xdd4 <processChords+0x46c>
  		}
	// blue
	else if(stringState[0] == buttonStringPatterns[3][0] &&
     b24:	de 01       	movw	r26, r28
     b26:	94 96       	adiw	r26, 0x24	; 36
     b28:	8c a1       	ldd	r24, Y+36	; 0x24
     b2a:	9d a1       	ldd	r25, Y+37	; 0x25
     b2c:	48 17       	cp	r20, r24
     b2e:	59 07       	cpc	r21, r25
     b30:	81 f5       	brne	.+96     	; 0xb92 <processChords+0x22a>
     b32:	22 81       	ldd	r18, Z+2	; 0x02
     b34:	33 81       	ldd	r19, Z+3	; 0x03
     b36:	12 96       	adiw	r26, 0x02	; 2
     b38:	8d 91       	ld	r24, X+
     b3a:	9c 91       	ld	r25, X
     b3c:	13 97       	sbiw	r26, 0x03	; 3
     b3e:	28 17       	cp	r18, r24
     b40:	39 07       	cpc	r19, r25
     b42:	39 f5       	brne	.+78     	; 0xb92 <processChords+0x22a>
     b44:	24 81       	ldd	r18, Z+4	; 0x04
     b46:	35 81       	ldd	r19, Z+5	; 0x05
     b48:	14 96       	adiw	r26, 0x04	; 4
     b4a:	8d 91       	ld	r24, X+
     b4c:	9c 91       	ld	r25, X
     b4e:	15 97       	sbiw	r26, 0x05	; 5
     b50:	28 17       	cp	r18, r24
     b52:	39 07       	cpc	r19, r25
     b54:	f1 f4       	brne	.+60     	; 0xb92 <processChords+0x22a>
     b56:	26 81       	ldd	r18, Z+6	; 0x06
     b58:	37 81       	ldd	r19, Z+7	; 0x07
     b5a:	16 96       	adiw	r26, 0x06	; 6
     b5c:	8d 91       	ld	r24, X+
     b5e:	9c 91       	ld	r25, X
     b60:	17 97       	sbiw	r26, 0x07	; 7
     b62:	28 17       	cp	r18, r24
     b64:	39 07       	cpc	r19, r25
     b66:	a9 f4       	brne	.+42     	; 0xb92 <processChords+0x22a>
     b68:	20 85       	ldd	r18, Z+8	; 0x08
     b6a:	31 85       	ldd	r19, Z+9	; 0x09
     b6c:	18 96       	adiw	r26, 0x08	; 8
     b6e:	8d 91       	ld	r24, X+
     b70:	9c 91       	ld	r25, X
     b72:	19 97       	sbiw	r26, 0x09	; 9
     b74:	28 17       	cp	r18, r24
     b76:	39 07       	cpc	r19, r25
     b78:	61 f4       	brne	.+24     	; 0xb92 <processChords+0x22a>
     b7a:	22 85       	ldd	r18, Z+10	; 0x0a
     b7c:	33 85       	ldd	r19, Z+11	; 0x0b
     b7e:	1a 96       	adiw	r26, 0x0a	; 10
     b80:	8d 91       	ld	r24, X+
     b82:	9c 91       	ld	r25, X
     b84:	1b 97       	sbiw	r26, 0x0b	; 11
     b86:	28 17       	cp	r18, r24
     b88:	39 07       	cpc	r19, r25
     b8a:	19 f4       	brne	.+6      	; 0xb92 <processChords+0x22a>
	   stringState[2] == buttonStringPatterns[3][2] &&
	   stringState[3] == buttonStringPatterns[3][3] &&
	   stringState[4] == buttonStringPatterns[3][4] &&
	   stringState[5] == buttonStringPatterns[3][5]  ) 
		{
			 data->blueOn = 1;
     b8c:	81 e0       	ldi	r24, 0x01	; 1
     b8e:	d8 01       	movw	r26, r16
     b90:	5e c1       	rjmp	.+700    	; 0xe4e <processChords+0x4e6>
  		}
	// orange
	else if(stringState[0] == buttonStringPatterns[4][0] &&
     b92:	de 01       	movw	r26, r28
     b94:	d0 96       	adiw	r26, 0x30	; 48
     b96:	88 a9       	ldd	r24, Y+48	; 0x30
     b98:	99 a9       	ldd	r25, Y+49	; 0x31
     b9a:	48 17       	cp	r20, r24
     b9c:	59 07       	cpc	r21, r25
     b9e:	89 f5       	brne	.+98     	; 0xc02 <processChords+0x29a>
     ba0:	22 81       	ldd	r18, Z+2	; 0x02
     ba2:	33 81       	ldd	r19, Z+3	; 0x03
     ba4:	12 96       	adiw	r26, 0x02	; 2
     ba6:	8d 91       	ld	r24, X+
     ba8:	9c 91       	ld	r25, X
     baa:	13 97       	sbiw	r26, 0x03	; 3
     bac:	28 17       	cp	r18, r24
     bae:	39 07       	cpc	r19, r25
     bb0:	41 f5       	brne	.+80     	; 0xc02 <processChords+0x29a>
     bb2:	24 81       	ldd	r18, Z+4	; 0x04
     bb4:	35 81       	ldd	r19, Z+5	; 0x05
     bb6:	14 96       	adiw	r26, 0x04	; 4
     bb8:	8d 91       	ld	r24, X+
     bba:	9c 91       	ld	r25, X
     bbc:	15 97       	sbiw	r26, 0x05	; 5
     bbe:	28 17       	cp	r18, r24
     bc0:	39 07       	cpc	r19, r25
     bc2:	f9 f4       	brne	.+62     	; 0xc02 <processChords+0x29a>
     bc4:	26 81       	ldd	r18, Z+6	; 0x06
     bc6:	37 81       	ldd	r19, Z+7	; 0x07
     bc8:	16 96       	adiw	r26, 0x06	; 6
     bca:	8d 91       	ld	r24, X+
     bcc:	9c 91       	ld	r25, X
     bce:	17 97       	sbiw	r26, 0x07	; 7
     bd0:	28 17       	cp	r18, r24
     bd2:	39 07       	cpc	r19, r25
     bd4:	b1 f4       	brne	.+44     	; 0xc02 <processChords+0x29a>
     bd6:	20 85       	ldd	r18, Z+8	; 0x08
     bd8:	31 85       	ldd	r19, Z+9	; 0x09
     bda:	18 96       	adiw	r26, 0x08	; 8
     bdc:	8d 91       	ld	r24, X+
     bde:	9c 91       	ld	r25, X
     be0:	19 97       	sbiw	r26, 0x09	; 9
     be2:	28 17       	cp	r18, r24
     be4:	39 07       	cpc	r19, r25
     be6:	69 f4       	brne	.+26     	; 0xc02 <processChords+0x29a>
     be8:	22 85       	ldd	r18, Z+10	; 0x0a
     bea:	33 85       	ldd	r19, Z+11	; 0x0b
     bec:	1a 96       	adiw	r26, 0x0a	; 10
     bee:	8d 91       	ld	r24, X+
     bf0:	9c 91       	ld	r25, X
     bf2:	1b 97       	sbiw	r26, 0x0b	; 11
     bf4:	28 17       	cp	r18, r24
     bf6:	39 07       	cpc	r19, r25
     bf8:	21 f4       	brne	.+8      	; 0xc02 <processChords+0x29a>
	   stringState[2] == buttonStringPatterns[4][2] &&
	   stringState[3] == buttonStringPatterns[4][3] &&
	   stringState[4] == buttonStringPatterns[4][4] &&
	   stringState[5] == buttonStringPatterns[4][5]  ) 
		{
			 data->orangeOn = 1;
     bfa:	81 e0       	ldi	r24, 0x01	; 1
     bfc:	f8 01       	movw	r30, r16
     bfe:	84 83       	std	Z+4, r24	; 0x04
     c00:	28 c1       	rjmp	.+592    	; 0xe52 <processChords+0x4ea>
  		}
	//Green and Red
	else if(stringState[0] == buttonStringPatterns[5][0] &&
     c02:	de 01       	movw	r26, r28
     c04:	dc 96       	adiw	r26, 0x3c	; 60
     c06:	8c ad       	ldd	r24, Y+60	; 0x3c
     c08:	9d ad       	ldd	r25, Y+61	; 0x3d
     c0a:	48 17       	cp	r20, r24
     c0c:	59 07       	cpc	r21, r25
     c0e:	99 f5       	brne	.+102    	; 0xc76 <processChords+0x30e>
     c10:	22 81       	ldd	r18, Z+2	; 0x02
     c12:	33 81       	ldd	r19, Z+3	; 0x03
     c14:	12 96       	adiw	r26, 0x02	; 2
     c16:	8d 91       	ld	r24, X+
     c18:	9c 91       	ld	r25, X
     c1a:	13 97       	sbiw	r26, 0x03	; 3
     c1c:	28 17       	cp	r18, r24
     c1e:	39 07       	cpc	r19, r25
     c20:	51 f5       	brne	.+84     	; 0xc76 <processChords+0x30e>
     c22:	24 81       	ldd	r18, Z+4	; 0x04
     c24:	35 81       	ldd	r19, Z+5	; 0x05
     c26:	14 96       	adiw	r26, 0x04	; 4
     c28:	8d 91       	ld	r24, X+
     c2a:	9c 91       	ld	r25, X
     c2c:	15 97       	sbiw	r26, 0x05	; 5
     c2e:	28 17       	cp	r18, r24
     c30:	39 07       	cpc	r19, r25
     c32:	09 f5       	brne	.+66     	; 0xc76 <processChords+0x30e>
     c34:	26 81       	ldd	r18, Z+6	; 0x06
     c36:	37 81       	ldd	r19, Z+7	; 0x07
     c38:	16 96       	adiw	r26, 0x06	; 6
     c3a:	8d 91       	ld	r24, X+
     c3c:	9c 91       	ld	r25, X
     c3e:	17 97       	sbiw	r26, 0x07	; 7
     c40:	28 17       	cp	r18, r24
     c42:	39 07       	cpc	r19, r25
     c44:	c1 f4       	brne	.+48     	; 0xc76 <processChords+0x30e>
     c46:	20 85       	ldd	r18, Z+8	; 0x08
     c48:	31 85       	ldd	r19, Z+9	; 0x09
     c4a:	18 96       	adiw	r26, 0x08	; 8
     c4c:	8d 91       	ld	r24, X+
     c4e:	9c 91       	ld	r25, X
     c50:	19 97       	sbiw	r26, 0x09	; 9
     c52:	28 17       	cp	r18, r24
     c54:	39 07       	cpc	r19, r25
     c56:	79 f4       	brne	.+30     	; 0xc76 <processChords+0x30e>
     c58:	22 85       	ldd	r18, Z+10	; 0x0a
     c5a:	33 85       	ldd	r19, Z+11	; 0x0b
     c5c:	1a 96       	adiw	r26, 0x0a	; 10
     c5e:	8d 91       	ld	r24, X+
     c60:	9c 91       	ld	r25, X
     c62:	1b 97       	sbiw	r26, 0x0b	; 11
     c64:	28 17       	cp	r18, r24
     c66:	39 07       	cpc	r19, r25
     c68:	31 f4       	brne	.+12     	; 0xc76 <processChords+0x30e>
	   stringState[2] == buttonStringPatterns[5][2] &&
	   stringState[3] == buttonStringPatterns[5][3] &&
	   stringState[4] == buttonStringPatterns[5][4] &&
	   stringState[5] == buttonStringPatterns[5][5]  ) 
		{
			data->greenOn = 1;
     c6a:	81 e0       	ldi	r24, 0x01	; 1
     c6c:	d8 01       	movw	r26, r16
     c6e:	8c 93       	st	X, r24
			data->redOn = 1;
     c70:	11 96       	adiw	r26, 0x01	; 1
     c72:	8c 93       	st	X, r24
     c74:	ee c0       	rjmp	.+476    	; 0xe52 <processChords+0x4ea>
  		}
	//Red and Yellow
	else if(stringState[0] == buttonStringPatterns[6][0] &&
     c76:	de 01       	movw	r26, r28
     c78:	a8 5b       	subi	r26, 0xB8	; 184
     c7a:	bf 4f       	sbci	r27, 0xFF	; 255
     c7c:	8d 91       	ld	r24, X+
     c7e:	9c 91       	ld	r25, X
     c80:	11 97       	sbiw	r26, 0x01	; 1
     c82:	48 17       	cp	r20, r24
     c84:	59 07       	cpc	r21, r25
     c86:	89 f5       	brne	.+98     	; 0xcea <processChords+0x382>
     c88:	22 81       	ldd	r18, Z+2	; 0x02
     c8a:	33 81       	ldd	r19, Z+3	; 0x03
     c8c:	12 96       	adiw	r26, 0x02	; 2
     c8e:	8d 91       	ld	r24, X+
     c90:	9c 91       	ld	r25, X
     c92:	13 97       	sbiw	r26, 0x03	; 3
     c94:	28 17       	cp	r18, r24
     c96:	39 07       	cpc	r19, r25
     c98:	41 f5       	brne	.+80     	; 0xcea <processChords+0x382>
     c9a:	24 81       	ldd	r18, Z+4	; 0x04
     c9c:	35 81       	ldd	r19, Z+5	; 0x05
     c9e:	14 96       	adiw	r26, 0x04	; 4
     ca0:	8d 91       	ld	r24, X+
     ca2:	9c 91       	ld	r25, X
     ca4:	15 97       	sbiw	r26, 0x05	; 5
     ca6:	28 17       	cp	r18, r24
     ca8:	39 07       	cpc	r19, r25
     caa:	f9 f4       	brne	.+62     	; 0xcea <processChords+0x382>
     cac:	26 81       	ldd	r18, Z+6	; 0x06
     cae:	37 81       	ldd	r19, Z+7	; 0x07
     cb0:	16 96       	adiw	r26, 0x06	; 6
     cb2:	8d 91       	ld	r24, X+
     cb4:	9c 91       	ld	r25, X
     cb6:	17 97       	sbiw	r26, 0x07	; 7
     cb8:	28 17       	cp	r18, r24
     cba:	39 07       	cpc	r19, r25
     cbc:	b1 f4       	brne	.+44     	; 0xcea <processChords+0x382>
     cbe:	20 85       	ldd	r18, Z+8	; 0x08
     cc0:	31 85       	ldd	r19, Z+9	; 0x09
     cc2:	18 96       	adiw	r26, 0x08	; 8
     cc4:	8d 91       	ld	r24, X+
     cc6:	9c 91       	ld	r25, X
     cc8:	19 97       	sbiw	r26, 0x09	; 9
     cca:	28 17       	cp	r18, r24
     ccc:	39 07       	cpc	r19, r25
     cce:	69 f4       	brne	.+26     	; 0xcea <processChords+0x382>
     cd0:	22 85       	ldd	r18, Z+10	; 0x0a
     cd2:	33 85       	ldd	r19, Z+11	; 0x0b
     cd4:	1a 96       	adiw	r26, 0x0a	; 10
     cd6:	8d 91       	ld	r24, X+
     cd8:	9c 91       	ld	r25, X
     cda:	1b 97       	sbiw	r26, 0x0b	; 11
     cdc:	28 17       	cp	r18, r24
     cde:	39 07       	cpc	r19, r25
     ce0:	21 f4       	brne	.+8      	; 0xcea <processChords+0x382>
	   stringState[2] == buttonStringPatterns[6][2] &&
	   stringState[3] == buttonStringPatterns[6][3] &&
	   stringState[4] == buttonStringPatterns[6][4] &&
	   stringState[5] == buttonStringPatterns[6][5]  ) 
		{
			data->redOn = 1;
     ce2:	81 e0       	ldi	r24, 0x01	; 1
     ce4:	f8 01       	movw	r30, r16
     ce6:	81 83       	std	Z+1, r24	; 0x01
     ce8:	75 c0       	rjmp	.+234    	; 0xdd4 <processChords+0x46c>
			data->yellowOn = 1;
  		}
	// Yellow and Blue
	else if(stringState[0] == buttonStringPatterns[7][0] &&
     cea:	de 01       	movw	r26, r28
     cec:	ac 5a       	subi	r26, 0xAC	; 172
     cee:	bf 4f       	sbci	r27, 0xFF	; 255
     cf0:	8d 91       	ld	r24, X+
     cf2:	9c 91       	ld	r25, X
     cf4:	11 97       	sbiw	r26, 0x01	; 1
     cf6:	48 17       	cp	r20, r24
     cf8:	59 07       	cpc	r21, r25
     cfa:	99 f5       	brne	.+102    	; 0xd62 <processChords+0x3fa>
     cfc:	22 81       	ldd	r18, Z+2	; 0x02
     cfe:	33 81       	ldd	r19, Z+3	; 0x03
     d00:	12 96       	adiw	r26, 0x02	; 2
     d02:	8d 91       	ld	r24, X+
     d04:	9c 91       	ld	r25, X
     d06:	13 97       	sbiw	r26, 0x03	; 3
     d08:	28 17       	cp	r18, r24
     d0a:	39 07       	cpc	r19, r25
     d0c:	51 f5       	brne	.+84     	; 0xd62 <processChords+0x3fa>
     d0e:	24 81       	ldd	r18, Z+4	; 0x04
     d10:	35 81       	ldd	r19, Z+5	; 0x05
     d12:	14 96       	adiw	r26, 0x04	; 4
     d14:	8d 91       	ld	r24, X+
     d16:	9c 91       	ld	r25, X
     d18:	15 97       	sbiw	r26, 0x05	; 5
     d1a:	28 17       	cp	r18, r24
     d1c:	39 07       	cpc	r19, r25
     d1e:	09 f5       	brne	.+66     	; 0xd62 <processChords+0x3fa>
     d20:	26 81       	ldd	r18, Z+6	; 0x06
     d22:	37 81       	ldd	r19, Z+7	; 0x07
     d24:	16 96       	adiw	r26, 0x06	; 6
     d26:	8d 91       	ld	r24, X+
     d28:	9c 91       	ld	r25, X
     d2a:	17 97       	sbiw	r26, 0x07	; 7
     d2c:	28 17       	cp	r18, r24
     d2e:	39 07       	cpc	r19, r25
     d30:	c1 f4       	brne	.+48     	; 0xd62 <processChords+0x3fa>
     d32:	20 85       	ldd	r18, Z+8	; 0x08
     d34:	31 85       	ldd	r19, Z+9	; 0x09
     d36:	18 96       	adiw	r26, 0x08	; 8
     d38:	8d 91       	ld	r24, X+
     d3a:	9c 91       	ld	r25, X
     d3c:	19 97       	sbiw	r26, 0x09	; 9
     d3e:	28 17       	cp	r18, r24
     d40:	39 07       	cpc	r19, r25
     d42:	79 f4       	brne	.+30     	; 0xd62 <processChords+0x3fa>
     d44:	22 85       	ldd	r18, Z+10	; 0x0a
     d46:	33 85       	ldd	r19, Z+11	; 0x0b
     d48:	1a 96       	adiw	r26, 0x0a	; 10
     d4a:	8d 91       	ld	r24, X+
     d4c:	9c 91       	ld	r25, X
     d4e:	1b 97       	sbiw	r26, 0x0b	; 11
     d50:	28 17       	cp	r18, r24
     d52:	39 07       	cpc	r19, r25
     d54:	31 f4       	brne	.+12     	; 0xd62 <processChords+0x3fa>
	   stringState[2] == buttonStringPatterns[7][2] &&
	   stringState[3] == buttonStringPatterns[7][3] &&
	   stringState[4] == buttonStringPatterns[7][4] &&
	   stringState[5] == buttonStringPatterns[7][5]  ) 
		{
			 data->yellowOn = 1;
     d56:	81 e0       	ldi	r24, 0x01	; 1
     d58:	d8 01       	movw	r26, r16
     d5a:	12 96       	adiw	r26, 0x02	; 2
     d5c:	8c 93       	st	X, r24
     d5e:	12 97       	sbiw	r26, 0x02	; 2
     d60:	76 c0       	rjmp	.+236    	; 0xe4e <processChords+0x4e6>
			 data->blueOn = 1;
  		}
	// Green and Yellow
	else if(stringState[0] == buttonStringPatterns[8][0] &&
     d62:	de 01       	movw	r26, r28
     d64:	a0 5a       	subi	r26, 0xA0	; 160
     d66:	bf 4f       	sbci	r27, 0xFF	; 255
     d68:	8d 91       	ld	r24, X+
     d6a:	9c 91       	ld	r25, X
     d6c:	11 97       	sbiw	r26, 0x01	; 1
     d6e:	48 17       	cp	r20, r24
     d70:	59 07       	cpc	r21, r25
     d72:	91 f5       	brne	.+100    	; 0xdd8 <processChords+0x470>
     d74:	22 81       	ldd	r18, Z+2	; 0x02
     d76:	33 81       	ldd	r19, Z+3	; 0x03
     d78:	12 96       	adiw	r26, 0x02	; 2
     d7a:	8d 91       	ld	r24, X+
     d7c:	9c 91       	ld	r25, X
     d7e:	13 97       	sbiw	r26, 0x03	; 3
     d80:	28 17       	cp	r18, r24
     d82:	39 07       	cpc	r19, r25
     d84:	49 f5       	brne	.+82     	; 0xdd8 <processChords+0x470>
     d86:	24 81       	ldd	r18, Z+4	; 0x04
     d88:	35 81       	ldd	r19, Z+5	; 0x05
     d8a:	14 96       	adiw	r26, 0x04	; 4
     d8c:	8d 91       	ld	r24, X+
     d8e:	9c 91       	ld	r25, X
     d90:	15 97       	sbiw	r26, 0x05	; 5
     d92:	28 17       	cp	r18, r24
     d94:	39 07       	cpc	r19, r25
     d96:	01 f5       	brne	.+64     	; 0xdd8 <processChords+0x470>
     d98:	26 81       	ldd	r18, Z+6	; 0x06
     d9a:	37 81       	ldd	r19, Z+7	; 0x07
     d9c:	16 96       	adiw	r26, 0x06	; 6
     d9e:	8d 91       	ld	r24, X+
     da0:	9c 91       	ld	r25, X
     da2:	17 97       	sbiw	r26, 0x07	; 7
     da4:	28 17       	cp	r18, r24
     da6:	39 07       	cpc	r19, r25
     da8:	b9 f4       	brne	.+46     	; 0xdd8 <processChords+0x470>
     daa:	20 85       	ldd	r18, Z+8	; 0x08
     dac:	31 85       	ldd	r19, Z+9	; 0x09
     dae:	18 96       	adiw	r26, 0x08	; 8
     db0:	8d 91       	ld	r24, X+
     db2:	9c 91       	ld	r25, X
     db4:	19 97       	sbiw	r26, 0x09	; 9
     db6:	28 17       	cp	r18, r24
     db8:	39 07       	cpc	r19, r25
     dba:	71 f4       	brne	.+28     	; 0xdd8 <processChords+0x470>
     dbc:	22 85       	ldd	r18, Z+10	; 0x0a
     dbe:	33 85       	ldd	r19, Z+11	; 0x0b
     dc0:	1a 96       	adiw	r26, 0x0a	; 10
     dc2:	8d 91       	ld	r24, X+
     dc4:	9c 91       	ld	r25, X
     dc6:	1b 97       	sbiw	r26, 0x0b	; 11
     dc8:	28 17       	cp	r18, r24
     dca:	39 07       	cpc	r19, r25
     dcc:	29 f4       	brne	.+10     	; 0xdd8 <processChords+0x470>
	   stringState[2] == buttonStringPatterns[8][2] &&
	   stringState[3] == buttonStringPatterns[8][3] &&
	   stringState[4] == buttonStringPatterns[8][4] &&
	   stringState[5] == buttonStringPatterns[8][5]  ) 
		{
			 data->greenOn = 1;
     dce:	81 e0       	ldi	r24, 0x01	; 1
     dd0:	f8 01       	movw	r30, r16
     dd2:	80 83       	st	Z, r24
			 data->yellowOn = 1;
     dd4:	82 83       	std	Z+2, r24	; 0x02
     dd6:	3d c0       	rjmp	.+122    	; 0xe52 <processChords+0x4ea>
  		}
	// Red and Blue
	else if(stringState[0] == buttonStringPatterns[9][0] &&
     dd8:	de 01       	movw	r26, r28
     dda:	a4 59       	subi	r26, 0x94	; 148
     ddc:	bf 4f       	sbci	r27, 0xFF	; 255
     dde:	8d 91       	ld	r24, X+
     de0:	9c 91       	ld	r25, X
     de2:	11 97       	sbiw	r26, 0x01	; 1
     de4:	48 17       	cp	r20, r24
     de6:	59 07       	cpc	r21, r25
     de8:	a1 f5       	brne	.+104    	; 0xe52 <processChords+0x4ea>
     dea:	22 81       	ldd	r18, Z+2	; 0x02
     dec:	33 81       	ldd	r19, Z+3	; 0x03
     dee:	12 96       	adiw	r26, 0x02	; 2
     df0:	8d 91       	ld	r24, X+
     df2:	9c 91       	ld	r25, X
     df4:	13 97       	sbiw	r26, 0x03	; 3
     df6:	28 17       	cp	r18, r24
     df8:	39 07       	cpc	r19, r25
     dfa:	59 f5       	brne	.+86     	; 0xe52 <processChords+0x4ea>
     dfc:	24 81       	ldd	r18, Z+4	; 0x04
     dfe:	35 81       	ldd	r19, Z+5	; 0x05
     e00:	14 96       	adiw	r26, 0x04	; 4
     e02:	8d 91       	ld	r24, X+
     e04:	9c 91       	ld	r25, X
     e06:	15 97       	sbiw	r26, 0x05	; 5
     e08:	28 17       	cp	r18, r24
     e0a:	39 07       	cpc	r19, r25
     e0c:	11 f5       	brne	.+68     	; 0xe52 <processChords+0x4ea>
     e0e:	26 81       	ldd	r18, Z+6	; 0x06
     e10:	37 81       	ldd	r19, Z+7	; 0x07
     e12:	16 96       	adiw	r26, 0x06	; 6
     e14:	8d 91       	ld	r24, X+
     e16:	9c 91       	ld	r25, X
     e18:	17 97       	sbiw	r26, 0x07	; 7
     e1a:	28 17       	cp	r18, r24
     e1c:	39 07       	cpc	r19, r25
     e1e:	c9 f4       	brne	.+50     	; 0xe52 <processChords+0x4ea>
     e20:	20 85       	ldd	r18, Z+8	; 0x08
     e22:	31 85       	ldd	r19, Z+9	; 0x09
     e24:	18 96       	adiw	r26, 0x08	; 8
     e26:	8d 91       	ld	r24, X+
     e28:	9c 91       	ld	r25, X
     e2a:	19 97       	sbiw	r26, 0x09	; 9
     e2c:	28 17       	cp	r18, r24
     e2e:	39 07       	cpc	r19, r25
     e30:	81 f4       	brne	.+32     	; 0xe52 <processChords+0x4ea>
     e32:	22 85       	ldd	r18, Z+10	; 0x0a
     e34:	33 85       	ldd	r19, Z+11	; 0x0b
     e36:	1a 96       	adiw	r26, 0x0a	; 10
     e38:	8d 91       	ld	r24, X+
     e3a:	9c 91       	ld	r25, X
     e3c:	1b 97       	sbiw	r26, 0x0b	; 11
     e3e:	28 17       	cp	r18, r24
     e40:	39 07       	cpc	r19, r25
     e42:	39 f4       	brne	.+14     	; 0xe52 <processChords+0x4ea>
	   stringState[2] == buttonStringPatterns[9][2] &&
	   stringState[3] == buttonStringPatterns[9][3] &&
	   stringState[4] == buttonStringPatterns[9][4] &&
	   stringState[5] == buttonStringPatterns[9][5]  ) 
		{
			 data->redOn = 1;
     e44:	81 e0       	ldi	r24, 0x01	; 1
     e46:	d8 01       	movw	r26, r16
     e48:	11 96       	adiw	r26, 0x01	; 1
     e4a:	8c 93       	st	X, r24
     e4c:	11 97       	sbiw	r26, 0x01	; 1
			 data->blueOn = 1;
     e4e:	13 96       	adiw	r26, 0x03	; 3
     e50:	8c 93       	st	X, r24
  		}



	return;
}
     e52:	df 91       	pop	r29
     e54:	cf 91       	pop	r28
     e56:	1f 91       	pop	r17
     e58:	0f 91       	pop	r16
     e5a:	08 95       	ret

00000e5c <processNotes>:

void processNotes(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS])
{
     e5c:	ef 92       	push	r14
     e5e:	ff 92       	push	r15
     e60:	0f 93       	push	r16
     e62:	1f 93       	push	r17
     e64:	cf 93       	push	r28
     e66:	df 93       	push	r29
     e68:	fc 01       	movw	r30, r24
	/* If we're playing with notes on a scale, then we have to figure out if the proper note is being
	   played, and also if we strummed the correct string.
	 */
	// First thing, we need to reset the strumming code, since we need to check and see if we 
	//  strummed on the correct string or not
	data->upOn = 0;
     e6a:	15 82       	std	Z+5, r1	; 0x05
	data->downOn = 0;
     e6c:	16 82       	std	Z+6, r1	; 0x06
     e6e:	db 01       	movw	r26, r22
     e70:	7a 01       	movw	r14, r20
     e72:	ba 01       	movw	r22, r20
     e74:	6c 5d       	subi	r22, 0xDC	; 220
     e76:	7f 4f       	sbci	r23, 0xFF	; 255
     e78:	4f ef       	ldi	r20, 0xFF	; 255
     e7a:	00 e0       	ldi	r16, 0x00	; 0
     e7c:	50 e0       	ldi	r21, 0x00	; 0
					buttonPressed = 1;
					}				
				if (stringState[i] == buttonStringPatterns[4][i] && 
										buttonStringPatterns[4][i] != 0)
				{
					data->orangeOn =  1;
     e7e:	11 e0       	ldi	r17, 0x01	; 1
	char strumOn = -1; // This holds which string the pick is strumming
	char buttonPressed = 0;
	char strumPressed  = 0;
	for (int i = 0; i < 6; i++)
	{
		if (stringState[i] != 0) // Only look at strings that are being touched or strummed
     e80:	8d 91       	ld	r24, X+
     e82:	9c 91       	ld	r25, X
     e84:	11 97       	sbiw	r26, 0x01	; 1
     e86:	00 97       	sbiw	r24, 0x00	; 0
     e88:	09 f4       	brne	.+2      	; 0xe8c <processNotes+0x30>
     e8a:	7c c0       	rjmp	.+248    	; 0xf84 <processNotes+0x128>
		{
			// Check for open strings being strummed first
			if (stringState[i] == 1) // This means we're strumming an open string
     e8c:	81 30       	cpi	r24, 0x01	; 1
     e8e:	91 05       	cpc	r25, r1
     e90:	a1 f5       	brne	.+104    	; 0xefa <processNotes+0x9e>
			{
				if (stringState[i] == buttonStringPatterns[0][i])
     e92:	e7 01       	movw	r28, r14
     e94:	88 81       	ld	r24, Y
     e96:	99 81       	ldd	r25, Y+1	; 0x01
     e98:	01 97       	sbiw	r24, 0x01	; 1
     e9a:	11 f4       	brne	.+4      	; 0xea0 <processNotes+0x44>
				{
					strumOn = i;
					data->greenOn =  1;	
     e9c:	10 83       	st	Z, r17
     e9e:	45 2f       	mov	r20, r21
				}
				if (stringState[i] == buttonStringPatterns[1][i])
     ea0:	2d 91       	ld	r18, X+
     ea2:	3c 91       	ld	r19, X
     ea4:	11 97       	sbiw	r26, 0x01	; 1
     ea6:	e7 01       	movw	r28, r14
     ea8:	8c 85       	ldd	r24, Y+12	; 0x0c
     eaa:	9d 85       	ldd	r25, Y+13	; 0x0d
     eac:	28 17       	cp	r18, r24
     eae:	39 07       	cpc	r19, r25
     eb0:	11 f4       	brne	.+4      	; 0xeb6 <processNotes+0x5a>
				{
					strumOn = i;
					data->redOn =  1;	
     eb2:	11 83       	std	Z+1, r17	; 0x01
     eb4:	45 2f       	mov	r20, r21
				}
				if (stringState[i] == buttonStringPatterns[2][i])
     eb6:	2d 91       	ld	r18, X+
     eb8:	3c 91       	ld	r19, X
     eba:	11 97       	sbiw	r26, 0x01	; 1
     ebc:	e7 01       	movw	r28, r14
     ebe:	88 8d       	ldd	r24, Y+24	; 0x18
     ec0:	99 8d       	ldd	r25, Y+25	; 0x19
     ec2:	28 17       	cp	r18, r24
     ec4:	39 07       	cpc	r19, r25
     ec6:	11 f4       	brne	.+4      	; 0xecc <processNotes+0x70>
				{
					strumOn = i;
					data->yellowOn =  1;
     ec8:	12 83       	std	Z+2, r17	; 0x02
     eca:	45 2f       	mov	r20, r21
				}				
				if (stringState[i] == buttonStringPatterns[3][i])
     ecc:	2d 91       	ld	r18, X+
     ece:	3c 91       	ld	r19, X
     ed0:	11 97       	sbiw	r26, 0x01	; 1
     ed2:	eb 01       	movw	r28, r22
     ed4:	88 81       	ld	r24, Y
     ed6:	99 81       	ldd	r25, Y+1	; 0x01
     ed8:	28 17       	cp	r18, r24
     eda:	39 07       	cpc	r19, r25
     edc:	11 f4       	brne	.+4      	; 0xee2 <processNotes+0x86>
				{
					strumOn = i;
					data->blueOn =  1;
     ede:	13 83       	std	Z+3, r17	; 0x03
     ee0:	45 2f       	mov	r20, r21
				}				
				if (stringState[i] == buttonStringPatterns[4][i])
     ee2:	2d 91       	ld	r18, X+
     ee4:	3c 91       	ld	r19, X
     ee6:	11 97       	sbiw	r26, 0x01	; 1
     ee8:	eb 01       	movw	r28, r22
     eea:	8c 85       	ldd	r24, Y+12	; 0x0c
     eec:	9d 85       	ldd	r25, Y+13	; 0x0d
     eee:	28 17       	cp	r18, r24
     ef0:	39 07       	cpc	r19, r25
     ef2:	29 f4       	brne	.+10     	; 0xefe <processNotes+0xa2>
				{
					strumOn = i;
					data->orangeOn =  1;				
     ef4:	14 83       	std	Z+4, r17	; 0x04
     ef6:	45 2f       	mov	r20, r21
     ef8:	02 c0       	rjmp	.+4      	; 0xefe <processNotes+0xa2>
			}
			 // Now we have checked for strummed notes, we need to check for pressed notes
			 //  so that we can display them for reference as well as use them when strummed
			else
				// First see if we're strumming or not
				strumPressed = stringState[i] & 1;
     efa:	08 2f       	mov	r16, r24
     efc:	01 70       	andi	r16, 0x01	; 1
				// Now ensure the strum bit is zero
				stringState[i] &= (~1);
     efe:	2d 91       	ld	r18, X+
     f00:	3c 91       	ld	r19, X
     f02:	11 97       	sbiw	r26, 0x01	; 1
     f04:	2e 7f       	andi	r18, 0xFE	; 254
     f06:	11 96       	adiw	r26, 0x01	; 1
     f08:	3c 93       	st	X, r19
     f0a:	2e 93       	st	-X, r18
				// Take care of displaying closed notes
				if (stringState[i] == buttonStringPatterns[0][i]&& 
     f0c:	e7 01       	movw	r28, r14
     f0e:	88 81       	ld	r24, Y
     f10:	99 81       	ldd	r25, Y+1	; 0x01
     f12:	28 17       	cp	r18, r24
     f14:	39 07       	cpc	r19, r25
     f16:	19 f4       	brne	.+6      	; 0xf1e <processNotes+0xc2>
     f18:	23 2b       	or	r18, r19
     f1a:	09 f0       	breq	.+2      	; 0xf1e <processNotes+0xc2>
										buttonStringPatterns[0][i] != 0)
				{
					data->greenOn =  1;	
     f1c:	10 83       	st	Z, r17
					buttonPressed = 1;
				}
				if (stringState[i] == buttonStringPatterns[1][i] && 
     f1e:	2d 91       	ld	r18, X+
     f20:	3c 91       	ld	r19, X
     f22:	11 97       	sbiw	r26, 0x01	; 1
     f24:	e7 01       	movw	r28, r14
     f26:	8c 85       	ldd	r24, Y+12	; 0x0c
     f28:	9d 85       	ldd	r25, Y+13	; 0x0d
     f2a:	28 17       	cp	r18, r24
     f2c:	39 07       	cpc	r19, r25
     f2e:	19 f4       	brne	.+6      	; 0xf36 <processNotes+0xda>
     f30:	23 2b       	or	r18, r19
     f32:	09 f0       	breq	.+2      	; 0xf36 <processNotes+0xda>
										buttonStringPatterns[1][i] != 0)
				{
					data->redOn =  1;	
     f34:	11 83       	std	Z+1, r17	; 0x01
					buttonPressed = 1;
				}
				if (stringState[i] == buttonStringPatterns[2][i] && 
     f36:	2d 91       	ld	r18, X+
     f38:	3c 91       	ld	r19, X
     f3a:	11 97       	sbiw	r26, 0x01	; 1
     f3c:	e7 01       	movw	r28, r14
     f3e:	88 8d       	ldd	r24, Y+24	; 0x18
     f40:	99 8d       	ldd	r25, Y+25	; 0x19
     f42:	28 17       	cp	r18, r24
     f44:	39 07       	cpc	r19, r25
     f46:	19 f4       	brne	.+6      	; 0xf4e <processNotes+0xf2>
     f48:	23 2b       	or	r18, r19
     f4a:	09 f0       	breq	.+2      	; 0xf4e <processNotes+0xf2>
										buttonStringPatterns[2][i] != 0)
					{
					data->yellowOn =  1;
     f4c:	12 83       	std	Z+2, r17	; 0x02
					buttonPressed = 1;
				}
				if (stringState[i] == buttonStringPatterns[3][i] && 
     f4e:	2d 91       	ld	r18, X+
     f50:	3c 91       	ld	r19, X
     f52:	11 97       	sbiw	r26, 0x01	; 1
     f54:	eb 01       	movw	r28, r22
     f56:	88 81       	ld	r24, Y
     f58:	99 81       	ldd	r25, Y+1	; 0x01
     f5a:	28 17       	cp	r18, r24
     f5c:	39 07       	cpc	r19, r25
     f5e:	19 f4       	brne	.+6      	; 0xf66 <processNotes+0x10a>
     f60:	23 2b       	or	r18, r19
     f62:	09 f0       	breq	.+2      	; 0xf66 <processNotes+0x10a>
										buttonStringPatterns[3][i] != 0)
				{
					data->blueOn =  1;
     f64:	13 83       	std	Z+3, r17	; 0x03
					buttonPressed = 1;
					}				
				if (stringState[i] == buttonStringPatterns[4][i] && 
     f66:	2d 91       	ld	r18, X+
     f68:	3c 91       	ld	r19, X
     f6a:	11 97       	sbiw	r26, 0x01	; 1
     f6c:	eb 01       	movw	r28, r22
     f6e:	8c 85       	ldd	r24, Y+12	; 0x0c
     f70:	9d 85       	ldd	r25, Y+13	; 0x0d
     f72:	28 17       	cp	r18, r24
     f74:	39 07       	cpc	r19, r25
     f76:	19 f4       	brne	.+6      	; 0xf7e <processNotes+0x122>
     f78:	23 2b       	or	r18, r19
     f7a:	09 f0       	breq	.+2      	; 0xf7e <processNotes+0x122>
										buttonStringPatterns[4][i] != 0)
				{
					data->orangeOn =  1;
     f7c:	14 83       	std	Z+4, r17	; 0x04
					buttonPressed = 1;									
				}
					// Now deal with strumming
				if ((buttonPressed = 1) && (strumPressed == 1))
     f7e:	01 30       	cpi	r16, 0x01	; 1
     f80:	09 f4       	brne	.+2      	; 0xf84 <processNotes+0x128>
     f82:	45 2f       	mov	r20, r21
     f84:	12 96       	adiw	r26, 0x02	; 2
     f86:	5f 5f       	subi	r21, 0xFF	; 255
     f88:	82 e0       	ldi	r24, 0x02	; 2
     f8a:	90 e0       	ldi	r25, 0x00	; 0
     f8c:	e8 0e       	add	r14, r24
     f8e:	f9 1e       	adc	r15, r25
     f90:	6e 5f       	subi	r22, 0xFE	; 254
     f92:	7f 4f       	sbci	r23, 0xFF	; 255
	data->upOn = 0;
	data->downOn = 0;
	char strumOn = -1; // This holds which string the pick is strumming
	char buttonPressed = 0;
	char strumPressed  = 0;
	for (int i = 0; i < 6; i++)
     f94:	56 30       	cpi	r21, 0x06	; 6
     f96:	09 f0       	breq	.+2      	; 0xf9a <processNotes+0x13e>
     f98:	73 cf       	rjmp	.-282    	; 0xe80 <processNotes+0x24>
				}
			}
	}

	//Now set the strum buttons properly, so we can have both up and down if we're in this mode
	if ((strumOn >= 0) && (strumOn < 3))
     f9a:	43 30       	cpi	r20, 0x03	; 3
     f9c:	18 f4       	brcc	.+6      	; 0xfa4 <processNotes+0x148>
	{
		data->downOn = 1;
     f9e:	81 e0       	ldi	r24, 0x01	; 1
     fa0:	86 83       	std	Z+6, r24	; 0x06
     fa2:	08 c0       	rjmp	.+16     	; 0xfb4 <processNotes+0x158>
	}
	else if ((strumOn >= 3) && (strumOn < 6 ) && (data->downOn != 1))
     fa4:	43 50       	subi	r20, 0x03	; 3
     fa6:	43 30       	cpi	r20, 0x03	; 3
     fa8:	28 f4       	brcc	.+10     	; 0xfb4 <processNotes+0x158>
     faa:	86 81       	ldd	r24, Z+6	; 0x06
     fac:	81 30       	cpi	r24, 0x01	; 1
     fae:	11 f0       	breq	.+4      	; 0xfb4 <processNotes+0x158>
	{
		data->upOn = 1;
     fb0:	81 e0       	ldi	r24, 0x01	; 1
     fb2:	85 83       	std	Z+5, r24	; 0x05
	}
	return;
}
     fb4:	df 91       	pop	r29
     fb6:	cf 91       	pop	r28
     fb8:	1f 91       	pop	r17
     fba:	0f 91       	pop	r16
     fbc:	ff 90       	pop	r15
     fbe:	ef 90       	pop	r14
     fc0:	08 95       	ret

00000fc2 <processFrets>:

void processFrets(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS], 
									int greenTimers[NUMBER_OF_STRINGS], int triedGreen[NUMBER_OF_STRINGS])
{
     fc2:	af 92       	push	r10
     fc4:	bf 92       	push	r11
     fc6:	cf 92       	push	r12
     fc8:	df 92       	push	r13
     fca:	ff 92       	push	r15
     fcc:	0f 93       	push	r16
     fce:	1f 93       	push	r17
     fd0:	cf 93       	push	r28
     fd2:	df 93       	push	r29
     fd4:	fc 01       	movw	r30, r24
     fd6:	5b 01       	movw	r10, r22
     fd8:	d8 01       	movw	r26, r16
     fda:	89 01       	movw	r16, r18
     fdc:	60 e0       	ldi	r22, 0x00	; 0
     fde:	70 e0       	ldi	r23, 0x00	; 0
				// now we test to see if the counter has counted high enough, and
				// if it has, then we do record a green hit.
				int test = TCNT1 - greenTimers[guitarString];
		    	if (  (data->greenOn == 0) && (( test > GREEN_TIMER_WAIT) || (test <= 0)) )
		    	{
		        	data->greenOn = 1;
     fe0:	ff 24       	eor	r15, r15
     fe2:	f3 94       	inc	r15
		{
		    if (triedGreen[guitarString] == 0) // we didn't touch green last cycle
		    {        
				// so we start the counter and say we did touch it.
		      greenTimers[guitarString] = TCNT1;
		      triedGreen[guitarString] = 1;
     fe4:	81 e0       	ldi	r24, 0x01	; 1
     fe6:	c8 2e       	mov	r12, r24
     fe8:	d1 2c       	mov	r13, r1
		counts up to the GREEN_TIMER_WAIT, red gets activated and green doesn't.
	 */
	for(int guitarString = 0; guitarString < 6; guitarString++)
	{
		// find the proper value by masking the stringState variable for each fret
		char orange = (stringState[guitarString] & (1<<5));
     fea:	e5 01       	movw	r28, r10
     fec:	88 81       	ld	r24, Y
		char blue   = (stringState[guitarString] & (1<<4));
     fee:	98 2f       	mov	r25, r24
     ff0:	90 71       	andi	r25, 0x10	; 16
		char yellow = (stringState[guitarString] & (1<<3));
     ff2:	28 2f       	mov	r18, r24
     ff4:	28 70       	andi	r18, 0x08	; 8
		char red    = (stringState[guitarString] & (1<<2));
     ff6:	38 2f       	mov	r19, r24
     ff8:	34 70       	andi	r19, 0x04	; 4
		char green  = (stringState[guitarString] & (1<<1));
     ffa:	48 2f       	mov	r20, r24
     ffc:	42 70       	andi	r20, 0x02	; 2
		if ((orange != 0) && (blue != 0) && (data->orangeOn == 0))
     ffe:	85 ff       	sbrs	r24, 5
    1000:	07 c0       	rjmp	.+14     	; 0x1010 <processFrets+0x4e>
    1002:	99 23       	and	r25, r25
    1004:	71 f0       	breq	.+28     	; 0x1022 <processFrets+0x60>
    1006:	84 81       	ldd	r24, Z+4	; 0x04
    1008:	88 23       	and	r24, r24
    100a:	21 f4       	brne	.+8      	; 0x1014 <processFrets+0x52>
		{    
		    data->orangeOn = 1;
    100c:	f4 82       	std	Z+4, r15	; 0x04
    100e:	40 c0       	rjmp	.+128    	; 0x1090 <processFrets+0xce>
		    triedGreen[guitarString] = 0;
		}
		else if ((blue != 0) && (yellow != 0) && (data->blueOn == 0))
    1010:	99 23       	and	r25, r25
    1012:	39 f0       	breq	.+14     	; 0x1022 <processFrets+0x60>
    1014:	22 23       	and	r18, r18
    1016:	71 f0       	breq	.+28     	; 0x1034 <processFrets+0x72>
    1018:	83 81       	ldd	r24, Z+3	; 0x03
    101a:	88 23       	and	r24, r24
    101c:	21 f4       	brne	.+8      	; 0x1026 <processFrets+0x64>
		{
		    data->blueOn = 1;
    101e:	f3 82       	std	Z+3, r15	; 0x03
    1020:	37 c0       	rjmp	.+110    	; 0x1090 <processFrets+0xce>
		    triedGreen[guitarString] = 0;
		}
		else if ((yellow != 0) && (red != 0) && (data->yellowOn == 0))
    1022:	22 23       	and	r18, r18
    1024:	39 f0       	breq	.+14     	; 0x1034 <processFrets+0x72>
    1026:	33 23       	and	r19, r19
    1028:	71 f0       	breq	.+28     	; 0x1046 <processFrets+0x84>
    102a:	82 81       	ldd	r24, Z+2	; 0x02
    102c:	88 23       	and	r24, r24
    102e:	21 f4       	brne	.+8      	; 0x1038 <processFrets+0x76>
		{
		    data->yellowOn = 1;
    1030:	f2 82       	std	Z+2, r15	; 0x02
    1032:	2e c0       	rjmp	.+92     	; 0x1090 <processFrets+0xce>
		    triedGreen[guitarString] = 0;
		}
		else if ((red != 0) && (green != 0) && (data->redOn == 0))
    1034:	33 23       	and	r19, r19
    1036:	39 f0       	breq	.+14     	; 0x1046 <processFrets+0x84>
    1038:	44 23       	and	r20, r20
    103a:	51 f1       	breq	.+84     	; 0x1090 <processFrets+0xce>
    103c:	81 81       	ldd	r24, Z+1	; 0x01
    103e:	88 23       	and	r24, r24
    1040:	21 f4       	brne	.+8      	; 0x104a <processFrets+0x88>
		{
		    data->redOn = 1;
    1042:	f1 82       	std	Z+1, r15	; 0x01
    1044:	25 c0       	rjmp	.+74     	; 0x1090 <processFrets+0xce>
		    triedGreen[guitarString] = 0;
		}
		else if (green != 0)
    1046:	44 23       	and	r20, r20
    1048:	19 f1       	breq	.+70     	; 0x1090 <processFrets+0xce>
		{
		    if (triedGreen[guitarString] == 0) // we didn't touch green last cycle
    104a:	8d 91       	ld	r24, X+
    104c:	9c 91       	ld	r25, X
    104e:	11 97       	sbiw	r26, 0x01	; 1
    1050:	89 2b       	or	r24, r25
    1052:	59 f4       	brne	.+22     	; 0x106a <processFrets+0xa8>
		    {        
				// so we start the counter and say we did touch it.
		      greenTimers[guitarString] = TCNT1;
    1054:	80 91 84 00 	lds	r24, 0x0084
    1058:	90 91 85 00 	lds	r25, 0x0085
    105c:	e8 01       	movw	r28, r16
    105e:	99 83       	std	Y+1, r25	; 0x01
    1060:	88 83       	st	Y, r24
		      triedGreen[guitarString] = 1;
    1062:	11 96       	adiw	r26, 0x01	; 1
    1064:	dc 92       	st	X, r13
    1066:	ce 92       	st	-X, r12
    1068:	16 c0       	rjmp	.+44     	; 0x1096 <processFrets+0xd4>
		    }
		    else //triedGreen == true
		    {
				// now we test to see if the counter has counted high enough, and
				// if it has, then we do record a green hit.
				int test = TCNT1 - greenTimers[guitarString];
    106a:	20 91 84 00 	lds	r18, 0x0084
    106e:	30 91 85 00 	lds	r19, 0x0085
    1072:	e8 01       	movw	r28, r16
    1074:	48 81       	ld	r20, Y
    1076:	59 81       	ldd	r21, Y+1	; 0x01
		    	if (  (data->greenOn == 0) && (( test > GREEN_TIMER_WAIT) || (test <= 0)) )
    1078:	80 81       	ld	r24, Z
    107a:	88 23       	and	r24, r24
    107c:	61 f4       	brne	.+24     	; 0x1096 <processFrets+0xd4>
    107e:	21 50       	subi	r18, 0x01	; 1
    1080:	30 40       	sbci	r19, 0x00	; 0
    1082:	24 1b       	sub	r18, r20
    1084:	35 0b       	sbc	r19, r21
    1086:	24 36       	cpi	r18, 0x64	; 100
    1088:	31 05       	cpc	r19, r1
    108a:	28 f0       	brcs	.+10     	; 0x1096 <processFrets+0xd4>
		    	{
		        	data->greenOn = 1;
    108c:	f0 82       	st	Z, r15
    108e:	03 c0       	rjmp	.+6      	; 0x1096 <processFrets+0xd4>
		    	}
		    }
		}
	    else  //no buttons pressed
	    {
	        triedGreen[guitarString] = 0;
    1090:	11 96       	adiw	r26, 0x01	; 1
    1092:	1c 92       	st	X, r1
    1094:	1e 92       	st	-X, r1
		the strum has a direction, so if you strum the
		top 3 strings, you strum down, and if you strum
		the bottom 3 strings, you're strumming up.
	*/
		// Check for strumming
		if (stringState[guitarString] & 1)
    1096:	e5 01       	movw	r28, r10
    1098:	88 81       	ld	r24, Y
    109a:	80 ff       	sbrs	r24, 0
    109c:	08 c0       	rjmp	.+16     	; 0x10ae <processFrets+0xec>
		{
			if (guitarString < 3)
    109e:	63 30       	cpi	r22, 0x03	; 3
    10a0:	71 05       	cpc	r23, r1
    10a2:	1c f4       	brge	.+6      	; 0x10aa <processFrets+0xe8>
			{
				data->downOn = 1;
    10a4:	f6 82       	std	Z+6, r15	; 0x06
				data->upOn   = 0;
    10a6:	15 82       	std	Z+5, r1	; 0x05
    10a8:	02 c0       	rjmp	.+4      	; 0x10ae <processFrets+0xec>
			}
			else
			{
				data->upOn   = 1;
    10aa:	f5 82       	std	Z+5, r15	; 0x05
				data->downOn = 0;
    10ac:	16 82       	std	Z+6, r1	; 0x06
		you don't want that to register as a green button press.  So we do some
		timing on that one, so when you press just green, it starts counting
		instead of turing greenOn on, so if the red fret is turned on before it
		counts up to the GREEN_TIMER_WAIT, red gets activated and green doesn't.
	 */
	for(int guitarString = 0; guitarString < 6; guitarString++)
    10ae:	6f 5f       	subi	r22, 0xFF	; 255
    10b0:	7f 4f       	sbci	r23, 0xFF	; 255
    10b2:	82 e0       	ldi	r24, 0x02	; 2
    10b4:	90 e0       	ldi	r25, 0x00	; 0
    10b6:	a8 0e       	add	r10, r24
    10b8:	b9 1e       	adc	r11, r25
    10ba:	12 96       	adiw	r26, 0x02	; 2
    10bc:	0e 5f       	subi	r16, 0xFE	; 254
    10be:	1f 4f       	sbci	r17, 0xFF	; 255
    10c0:	66 30       	cpi	r22, 0x06	; 6
    10c2:	71 05       	cpc	r23, r1
    10c4:	09 f0       	breq	.+2      	; 0x10c8 <processFrets+0x106>
    10c6:	91 cf       	rjmp	.-222    	; 0xfea <processFrets+0x28>
				data->downOn = 0;
			}
		}
	}	// end of for loop
	return;
}
    10c8:	df 91       	pop	r29
    10ca:	cf 91       	pop	r28
    10cc:	1f 91       	pop	r17
    10ce:	0f 91       	pop	r16
    10d0:	ff 90       	pop	r15
    10d2:	df 90       	pop	r13
    10d4:	cf 90       	pop	r12
    10d6:	bf 90       	pop	r11
    10d8:	af 90       	pop	r10
    10da:	08 95       	ret

000010dc <processStringState>:

void processStringState(dataForController* data, int stringState[NUMBER_OF_STRINGS],
									int buttonStringPatterns[][NUMBER_OF_STRINGS], char controllerMode, 
									int greenTimers[NUMBER_OF_STRINGS], int triedGreen[NUMBER_OF_STRINGS])
{
    10dc:	ef 92       	push	r14
    10de:	ff 92       	push	r15
    10e0:	0f 93       	push	r16
    10e2:	1f 93       	push	r17
	if (controllerMode == CHORDS) // If we're playing with Chords - default is FRETS
    10e4:	24 30       	cpi	r18, 0x04	; 4
    10e6:	19 f4       	brne	.+6      	; 0x10ee <processStringState+0x12>
		processChords(data, stringState, buttonStringPatterns);
    10e8:	0e 94 b4 04 	call	0x968	; 0x968 <processChords>
    10ec:	09 c0       	rjmp	.+18     	; 0x1100 <processStringState+0x24>

	else if (controllerMode == NOTES) // We're playing with notes
    10ee:	22 30       	cpi	r18, 0x02	; 2
    10f0:	19 f4       	brne	.+6      	; 0x10f8 <processStringState+0x1c>
		processNotes(data, stringState, buttonStringPatterns);
    10f2:	0e 94 2e 07 	call	0xe5c	; 0xe5c <processNotes>
    10f6:	04 c0       	rjmp	.+8      	; 0x1100 <processStringState+0x24>
	
	else // We're playing with frets
		processFrets(data, stringState,	buttonStringPatterns, greenTimers, triedGreen);
    10f8:	98 01       	movw	r18, r16
    10fa:	87 01       	movw	r16, r14
    10fc:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <processFrets>

	return;	
}
    1100:	1f 91       	pop	r17
    1102:	0f 91       	pop	r16
    1104:	ff 90       	pop	r15
    1106:	ef 90       	pop	r14
    1108:	08 95       	ret

0000110a <displayTransitionState>:

// This simple function takes in the controller mode and sets the
//  data struct to certain patterns to give the user feedback
//  as to what state is being pressed
void displayTransitionState(dataForController* data, int controllerMode)
{
    110a:	fc 01       	movw	r30, r24
	if (controllerMode == FRETS_TO_NOTES)
    110c:	61 30       	cpi	r22, 0x01	; 1
    110e:	71 05       	cpc	r23, r1
    1110:	21 f4       	brne	.+8      	; 0x111a <displayTransitionState+0x10>
	{
		data->greenOn = 1;
    1112:	81 e0       	ldi	r24, 0x01	; 1
    1114:	80 83       	st	Z, r24
		data->yellowOn = 1;
    1116:	82 83       	std	Z+2, r24	; 0x02
    1118:	08 95       	ret
	}
	else if (controllerMode == NOTES_TO_CHORDS)
    111a:	63 30       	cpi	r22, 0x03	; 3
    111c:	71 05       	cpc	r23, r1
    111e:	21 f4       	brne	.+8      	; 0x1128 <displayTransitionState+0x1e>
	{
		data->greenOn = 1;
    1120:	81 e0       	ldi	r24, 0x01	; 1
    1122:	80 83       	st	Z, r24
		data->blueOn = 1;
    1124:	83 83       	std	Z+3, r24	; 0x03
    1126:	08 95       	ret
	}
	else if (controllerMode == CHORDS_TO_FRETS)
    1128:	65 30       	cpi	r22, 0x05	; 5
    112a:	71 05       	cpc	r23, r1
    112c:	19 f4       	brne	.+6      	; 0x1134 <displayTransitionState+0x2a>
	{
		data->greenOn = 1;
    112e:	81 e0       	ldi	r24, 0x01	; 1
    1130:	80 83       	st	Z, r24
		data->orangeOn = 1;
    1132:	84 83       	std	Z+4, r24	; 0x04
    1134:	08 95       	ret

00001136 <configSetButtonData>:
/* This function sets up the data struct when we're in config mode so that it shows
 *  the user which colors are currently being programmed.
 */
void configSetButtonData(dataForController* data, int* buttonToAssign, int buttonStringPatterns[][6], 
						int stringState[], char controllerMode, char* plusLock, char* previousPlusOn, int* debounceTimer)
{
    1136:	af 92       	push	r10
    1138:	bf 92       	push	r11
    113a:	cf 92       	push	r12
    113c:	df 92       	push	r13
    113e:	ef 92       	push	r14
    1140:	ff 92       	push	r15
    1142:	0f 93       	push	r16
    1144:	cf 93       	push	r28
    1146:	df 93       	push	r29
    1148:	fc 01       	movw	r30, r24
    114a:	db 01       	movw	r26, r22
    114c:	b9 01       	movw	r22, r18
    114e:	95 01       	movw	r18, r10
	// Since 'colorOn' is 1 when a fret is pressed, we invert, shift, invert, and & it to set the
	// corresponding button bit to zero, which corresponds to a button press.
	if (*buttonToAssign == 0)
    1150:	8d 91       	ld	r24, X+
    1152:	9c 91       	ld	r25, X
    1154:	11 97       	sbiw	r26, 0x01	; 1
    1156:	00 97       	sbiw	r24, 0x00	; 0
    1158:	19 f4       	brne	.+6      	; 0x1160 <configSetButtonData+0x2a>
		data->greenOn = 1;
    115a:	81 e0       	ldi	r24, 0x01	; 1
    115c:	80 83       	st	Z, r24
    115e:	34 c0       	rjmp	.+104    	; 0x11c8 <configSetButtonData+0x92>
	else if(*buttonToAssign == 1)
    1160:	81 30       	cpi	r24, 0x01	; 1
    1162:	91 05       	cpc	r25, r1
    1164:	11 f4       	brne	.+4      	; 0x116a <configSetButtonData+0x34>
		data->redOn = 1;
    1166:	81 e0       	ldi	r24, 0x01	; 1
    1168:	15 c0       	rjmp	.+42     	; 0x1194 <configSetButtonData+0x5e>
	else if(*buttonToAssign == 2)
    116a:	82 30       	cpi	r24, 0x02	; 2
    116c:	91 05       	cpc	r25, r1
    116e:	11 f4       	brne	.+4      	; 0x1174 <configSetButtonData+0x3e>
		data->yellowOn = 1;
    1170:	81 e0       	ldi	r24, 0x01	; 1
    1172:	23 c0       	rjmp	.+70     	; 0x11ba <configSetButtonData+0x84>
	else if(*buttonToAssign == 3)
    1174:	83 30       	cpi	r24, 0x03	; 3
    1176:	91 05       	cpc	r25, r1
    1178:	11 f4       	brne	.+4      	; 0x117e <configSetButtonData+0x48>
		data->blueOn = 1;
    117a:	81 e0       	ldi	r24, 0x01	; 1
    117c:	24 c0       	rjmp	.+72     	; 0x11c6 <configSetButtonData+0x90>
	else if(*buttonToAssign == 4)
    117e:	84 30       	cpi	r24, 0x04	; 4
    1180:	91 05       	cpc	r25, r1
    1182:	19 f4       	brne	.+6      	; 0x118a <configSetButtonData+0x54>
		data->orangeOn = 1;
    1184:	81 e0       	ldi	r24, 0x01	; 1
    1186:	84 83       	std	Z+4, r24	; 0x04
    1188:	1f c0       	rjmp	.+62     	; 0x11c8 <configSetButtonData+0x92>
	else if(*buttonToAssign == 5)
    118a:	85 30       	cpi	r24, 0x05	; 5
    118c:	91 05       	cpc	r25, r1
    118e:	21 f4       	brne	.+8      	; 0x1198 <configSetButtonData+0x62>
	{
		data->greenOn = 1;
    1190:	81 e0       	ldi	r24, 0x01	; 1
    1192:	80 83       	st	Z, r24
		data->redOn = 1;
    1194:	81 83       	std	Z+1, r24	; 0x01
    1196:	18 c0       	rjmp	.+48     	; 0x11c8 <configSetButtonData+0x92>
	}
	else if(*buttonToAssign == 6)
    1198:	86 30       	cpi	r24, 0x06	; 6
    119a:	91 05       	cpc	r25, r1
    119c:	19 f4       	brne	.+6      	; 0x11a4 <configSetButtonData+0x6e>
	{
		data->redOn = 1;
    119e:	81 e0       	ldi	r24, 0x01	; 1
    11a0:	81 83       	std	Z+1, r24	; 0x01
    11a2:	0b c0       	rjmp	.+22     	; 0x11ba <configSetButtonData+0x84>
		data->yellowOn = 1;
	}
	else if(*buttonToAssign == 7)
    11a4:	87 30       	cpi	r24, 0x07	; 7
    11a6:	91 05       	cpc	r25, r1
    11a8:	19 f4       	brne	.+6      	; 0x11b0 <configSetButtonData+0x7a>
	{
		data->yellowOn = 1;
    11aa:	81 e0       	ldi	r24, 0x01	; 1
    11ac:	82 83       	std	Z+2, r24	; 0x02
    11ae:	0b c0       	rjmp	.+22     	; 0x11c6 <configSetButtonData+0x90>
		data->blueOn = 1;
	}
	else if(*buttonToAssign == 8)
    11b0:	88 30       	cpi	r24, 0x08	; 8
    11b2:	91 05       	cpc	r25, r1
    11b4:	21 f4       	brne	.+8      	; 0x11be <configSetButtonData+0x88>
	{
		data->greenOn = 1;
    11b6:	81 e0       	ldi	r24, 0x01	; 1
    11b8:	80 83       	st	Z, r24
		data->yellowOn = 1;
    11ba:	82 83       	std	Z+2, r24	; 0x02
    11bc:	05 c0       	rjmp	.+10     	; 0x11c8 <configSetButtonData+0x92>
	}
	else if(*buttonToAssign == 9)
    11be:	09 97       	sbiw	r24, 0x09	; 9
    11c0:	19 f4       	brne	.+6      	; 0x11c8 <configSetButtonData+0x92>
	{
		data->redOn = 1;
    11c2:	81 e0       	ldi	r24, 0x01	; 1
    11c4:	81 83       	std	Z+1, r24	; 0x01
		data->blueOn = 1;
    11c6:	83 83       	std	Z+3, r24	; 0x03
	}



	// Code to debounce our plus button, the current state of plusOn to it's recent history
	if (data->plusOn != 0)  // So we're pressing plus
    11c8:	87 81       	ldd	r24, Z+7	; 0x07
    11ca:	88 23       	and	r24, r24
    11cc:	09 f1       	breq	.+66     	; 0x1210 <configSetButtonData+0xda>
	{ 
		if (*previousPlusOn == 0)  // If we weren't pressing plus last time through the main loop
    11ce:	e6 01       	movw	r28, r12
    11d0:	88 81       	ld	r24, Y
    11d2:	88 23       	and	r24, r24
    11d4:	59 f4       	brne	.+22     	; 0x11ec <configSetButtonData+0xb6>
		{ 
			*debounceTimer = TCNT1;  // Set up a timer
    11d6:	80 91 84 00 	lds	r24, 0x0084
    11da:	90 91 85 00 	lds	r25, 0x0085
    11de:	e9 01       	movw	r28, r18
    11e0:	99 83       	std	Y+1, r25	; 0x01
    11e2:	88 83       	st	Y, r24
			*previousPlusOn = 1;     // remember plus was pressed for the next iteration
    11e4:	81 e0       	ldi	r24, 0x01	; 1
    11e6:	e6 01       	movw	r28, r12
    11e8:	88 83       	st	Y, r24
    11ea:	10 c0       	rjmp	.+32     	; 0x120c <configSetButtonData+0xd6>
			data->plusOn = 0;        // but for now, consider plus not pressed.
		}
		else if ( (TCNT1 - *debounceTimer < DEBOUNCE_DELAY) && (TCNT1 - *debounceTimer >= 0))
    11ec:	80 91 84 00 	lds	r24, 0x0084
    11f0:	90 91 85 00 	lds	r25, 0x0085
    11f4:	e9 01       	movw	r28, r18
    11f6:	28 81       	ld	r18, Y
    11f8:	39 81       	ldd	r19, Y+1	; 0x01
    11fa:	82 1b       	sub	r24, r18
    11fc:	93 0b       	sbc	r25, r19
    11fe:	88 5e       	subi	r24, 0xE8	; 232
    1200:	93 40       	sbci	r25, 0x03	; 3
    1202:	40 f4       	brcc	.+16     	; 0x1214 <configSetButtonData+0xde>
    1204:	80 91 84 00 	lds	r24, 0x0084
    1208:	90 91 85 00 	lds	r25, 0x0085
		{
			data->plusOn = 0;  // This keeps telling us plus wasn't pressed until it's been held long enough
    120c:	17 82       	std	Z+7, r1	; 0x07
    120e:	02 c0       	rjmp	.+4      	; 0x1214 <configSetButtonData+0xde>
		}		
	}
	else
	{
		*previousPlusOn = 0; // and if plus wasn't pressed, remember that for next time
    1210:	e6 01       	movw	r28, r12
    1212:	18 82       	st	Y, r1
	}

	// Now, if you press plus, it will lock in whatever string pattern
	// and advance to working on the next pattern.
	if((data->plusOn) && (*plusLock == 0))
    1214:	87 81       	ldd	r24, Z+7	; 0x07
    1216:	88 23       	and	r24, r24
    1218:	09 f4       	brne	.+2      	; 0x121c <configSetButtonData+0xe6>
    121a:	f7 c0       	rjmp	.+494    	; 0x140a <configSetButtonData+0x2d4>
    121c:	f7 01       	movw	r30, r14
    121e:	80 81       	ld	r24, Z
    1220:	88 23       	and	r24, r24
    1222:	09 f0       	breq	.+2      	; 0x1226 <configSetButtonData+0xf0>
    1224:	f4 c0       	rjmp	.+488    	; 0x140e <configSetButtonData+0x2d8>
	{

		if (controllerMode == CHORDS) 
    1226:	04 30       	cpi	r16, 0x04	; 4
    1228:	09 f0       	breq	.+2      	; 0x122c <configSetButtonData+0xf6>
    122a:	60 c0       	rjmp	.+192    	; 0x12ec <configSetButtonData+0x1b6>
		{   // Set the pattern to nothing pressed
			buttonStringPatterns[*buttonToAssign][0] = 0;
    122c:	8d 91       	ld	r24, X+
    122e:	9c 91       	ld	r25, X
    1230:	11 97       	sbiw	r26, 0x01	; 1
    1232:	fc 01       	movw	r30, r24
    1234:	ee 0f       	add	r30, r30
    1236:	ff 1f       	adc	r31, r31
    1238:	e8 0f       	add	r30, r24
    123a:	f9 1f       	adc	r31, r25
    123c:	ee 0f       	add	r30, r30
    123e:	ff 1f       	adc	r31, r31
    1240:	ee 0f       	add	r30, r30
    1242:	ff 1f       	adc	r31, r31
    1244:	e4 0f       	add	r30, r20
    1246:	f5 1f       	adc	r31, r21
    1248:	11 82       	std	Z+1, r1	; 0x01
    124a:	10 82       	st	Z, r1
			buttonStringPatterns[*buttonToAssign][1] = 0;
    124c:	8d 91       	ld	r24, X+
    124e:	9c 91       	ld	r25, X
    1250:	11 97       	sbiw	r26, 0x01	; 1
    1252:	fc 01       	movw	r30, r24
    1254:	ee 0f       	add	r30, r30
    1256:	ff 1f       	adc	r31, r31
    1258:	e8 0f       	add	r30, r24
    125a:	f9 1f       	adc	r31, r25
    125c:	ee 0f       	add	r30, r30
    125e:	ff 1f       	adc	r31, r31
    1260:	ee 0f       	add	r30, r30
    1262:	ff 1f       	adc	r31, r31
    1264:	e4 0f       	add	r30, r20
    1266:	f5 1f       	adc	r31, r21
    1268:	13 82       	std	Z+3, r1	; 0x03
    126a:	12 82       	std	Z+2, r1	; 0x02
			buttonStringPatterns[*buttonToAssign][2] = 0;
    126c:	8d 91       	ld	r24, X+
    126e:	9c 91       	ld	r25, X
    1270:	11 97       	sbiw	r26, 0x01	; 1
    1272:	fc 01       	movw	r30, r24
    1274:	ee 0f       	add	r30, r30
    1276:	ff 1f       	adc	r31, r31
    1278:	e8 0f       	add	r30, r24
    127a:	f9 1f       	adc	r31, r25
    127c:	ee 0f       	add	r30, r30
    127e:	ff 1f       	adc	r31, r31
    1280:	ee 0f       	add	r30, r30
    1282:	ff 1f       	adc	r31, r31
    1284:	e4 0f       	add	r30, r20
    1286:	f5 1f       	adc	r31, r21
    1288:	15 82       	std	Z+5, r1	; 0x05
    128a:	14 82       	std	Z+4, r1	; 0x04
			buttonStringPatterns[*buttonToAssign][3] = 0;
    128c:	8d 91       	ld	r24, X+
    128e:	9c 91       	ld	r25, X
    1290:	11 97       	sbiw	r26, 0x01	; 1
    1292:	fc 01       	movw	r30, r24
    1294:	ee 0f       	add	r30, r30
    1296:	ff 1f       	adc	r31, r31
    1298:	e8 0f       	add	r30, r24
    129a:	f9 1f       	adc	r31, r25
    129c:	ee 0f       	add	r30, r30
    129e:	ff 1f       	adc	r31, r31
    12a0:	ee 0f       	add	r30, r30
    12a2:	ff 1f       	adc	r31, r31
    12a4:	e4 0f       	add	r30, r20
    12a6:	f5 1f       	adc	r31, r21
    12a8:	17 82       	std	Z+7, r1	; 0x07
    12aa:	16 82       	std	Z+6, r1	; 0x06
			buttonStringPatterns[*buttonToAssign][4] = 0;
    12ac:	8d 91       	ld	r24, X+
    12ae:	9c 91       	ld	r25, X
    12b0:	11 97       	sbiw	r26, 0x01	; 1
    12b2:	fc 01       	movw	r30, r24
    12b4:	ee 0f       	add	r30, r30
    12b6:	ff 1f       	adc	r31, r31
    12b8:	e8 0f       	add	r30, r24
    12ba:	f9 1f       	adc	r31, r25
    12bc:	ee 0f       	add	r30, r30
    12be:	ff 1f       	adc	r31, r31
    12c0:	ee 0f       	add	r30, r30
    12c2:	ff 1f       	adc	r31, r31
    12c4:	e4 0f       	add	r30, r20
    12c6:	f5 1f       	adc	r31, r21
    12c8:	11 86       	std	Z+9, r1	; 0x09
    12ca:	10 86       	std	Z+8, r1	; 0x08
			buttonStringPatterns[*buttonToAssign][5] = 0;
    12cc:	8d 91       	ld	r24, X+
    12ce:	9c 91       	ld	r25, X
    12d0:	11 97       	sbiw	r26, 0x01	; 1
    12d2:	fc 01       	movw	r30, r24
    12d4:	ee 0f       	add	r30, r30
    12d6:	ff 1f       	adc	r31, r31
    12d8:	e8 0f       	add	r30, r24
    12da:	f9 1f       	adc	r31, r25
    12dc:	ee 0f       	add	r30, r30
    12de:	ff 1f       	adc	r31, r31
    12e0:	ee 0f       	add	r30, r30
    12e2:	ff 1f       	adc	r31, r31
    12e4:	e4 0f       	add	r30, r20
    12e6:	f5 1f       	adc	r31, r21
    12e8:	13 86       	std	Z+11, r1	; 0x0b
    12ea:	12 86       	std	Z+10, r1	; 0x0a
		}
			// Assign what's being pressed on the frets to what matches the current button press
		buttonStringPatterns[*buttonToAssign][0] |= stringState[0];
    12ec:	8d 91       	ld	r24, X+
    12ee:	9c 91       	ld	r25, X
    12f0:	11 97       	sbiw	r26, 0x01	; 1
    12f2:	fc 01       	movw	r30, r24
    12f4:	ee 0f       	add	r30, r30
    12f6:	ff 1f       	adc	r31, r31
    12f8:	e8 0f       	add	r30, r24
    12fa:	f9 1f       	adc	r31, r25
    12fc:	ee 0f       	add	r30, r30
    12fe:	ff 1f       	adc	r31, r31
    1300:	ee 0f       	add	r30, r30
    1302:	ff 1f       	adc	r31, r31
    1304:	e4 0f       	add	r30, r20
    1306:	f5 1f       	adc	r31, r21
    1308:	80 81       	ld	r24, Z
    130a:	91 81       	ldd	r25, Z+1	; 0x01
    130c:	eb 01       	movw	r28, r22
    130e:	28 81       	ld	r18, Y
    1310:	39 81       	ldd	r19, Y+1	; 0x01
    1312:	82 2b       	or	r24, r18
    1314:	93 2b       	or	r25, r19
    1316:	91 83       	std	Z+1, r25	; 0x01
    1318:	80 83       	st	Z, r24
		buttonStringPatterns[*buttonToAssign][1] |= stringState[1];
    131a:	8d 91       	ld	r24, X+
    131c:	9c 91       	ld	r25, X
    131e:	11 97       	sbiw	r26, 0x01	; 1
    1320:	fc 01       	movw	r30, r24
    1322:	ee 0f       	add	r30, r30
    1324:	ff 1f       	adc	r31, r31
    1326:	e8 0f       	add	r30, r24
    1328:	f9 1f       	adc	r31, r25
    132a:	ee 0f       	add	r30, r30
    132c:	ff 1f       	adc	r31, r31
    132e:	ee 0f       	add	r30, r30
    1330:	ff 1f       	adc	r31, r31
    1332:	e4 0f       	add	r30, r20
    1334:	f5 1f       	adc	r31, r21
    1336:	82 81       	ldd	r24, Z+2	; 0x02
    1338:	93 81       	ldd	r25, Z+3	; 0x03
    133a:	2a 81       	ldd	r18, Y+2	; 0x02
    133c:	3b 81       	ldd	r19, Y+3	; 0x03
    133e:	82 2b       	or	r24, r18
    1340:	93 2b       	or	r25, r19
    1342:	93 83       	std	Z+3, r25	; 0x03
    1344:	82 83       	std	Z+2, r24	; 0x02
		buttonStringPatterns[*buttonToAssign][2] |= stringState[2];
    1346:	8d 91       	ld	r24, X+
    1348:	9c 91       	ld	r25, X
    134a:	11 97       	sbiw	r26, 0x01	; 1
    134c:	fc 01       	movw	r30, r24
    134e:	ee 0f       	add	r30, r30
    1350:	ff 1f       	adc	r31, r31
    1352:	e8 0f       	add	r30, r24
    1354:	f9 1f       	adc	r31, r25
    1356:	ee 0f       	add	r30, r30
    1358:	ff 1f       	adc	r31, r31
    135a:	ee 0f       	add	r30, r30
    135c:	ff 1f       	adc	r31, r31
    135e:	e4 0f       	add	r30, r20
    1360:	f5 1f       	adc	r31, r21
    1362:	84 81       	ldd	r24, Z+4	; 0x04
    1364:	95 81       	ldd	r25, Z+5	; 0x05
    1366:	2c 81       	ldd	r18, Y+4	; 0x04
    1368:	3d 81       	ldd	r19, Y+5	; 0x05
    136a:	82 2b       	or	r24, r18
    136c:	93 2b       	or	r25, r19
    136e:	95 83       	std	Z+5, r25	; 0x05
    1370:	84 83       	std	Z+4, r24	; 0x04
		buttonStringPatterns[*buttonToAssign][3] |= stringState[3];
    1372:	8d 91       	ld	r24, X+
    1374:	9c 91       	ld	r25, X
    1376:	11 97       	sbiw	r26, 0x01	; 1
    1378:	fc 01       	movw	r30, r24
    137a:	ee 0f       	add	r30, r30
    137c:	ff 1f       	adc	r31, r31
    137e:	e8 0f       	add	r30, r24
    1380:	f9 1f       	adc	r31, r25
    1382:	ee 0f       	add	r30, r30
    1384:	ff 1f       	adc	r31, r31
    1386:	ee 0f       	add	r30, r30
    1388:	ff 1f       	adc	r31, r31
    138a:	e4 0f       	add	r30, r20
    138c:	f5 1f       	adc	r31, r21
    138e:	86 81       	ldd	r24, Z+6	; 0x06
    1390:	97 81       	ldd	r25, Z+7	; 0x07
    1392:	2e 81       	ldd	r18, Y+6	; 0x06
    1394:	3f 81       	ldd	r19, Y+7	; 0x07
    1396:	82 2b       	or	r24, r18
    1398:	93 2b       	or	r25, r19
    139a:	97 83       	std	Z+7, r25	; 0x07
    139c:	86 83       	std	Z+6, r24	; 0x06
		buttonStringPatterns[*buttonToAssign][4] |= stringState[4];
    139e:	8d 91       	ld	r24, X+
    13a0:	9c 91       	ld	r25, X
    13a2:	11 97       	sbiw	r26, 0x01	; 1
    13a4:	fc 01       	movw	r30, r24
    13a6:	ee 0f       	add	r30, r30
    13a8:	ff 1f       	adc	r31, r31
    13aa:	e8 0f       	add	r30, r24
    13ac:	f9 1f       	adc	r31, r25
    13ae:	ee 0f       	add	r30, r30
    13b0:	ff 1f       	adc	r31, r31
    13b2:	ee 0f       	add	r30, r30
    13b4:	ff 1f       	adc	r31, r31
    13b6:	e4 0f       	add	r30, r20
    13b8:	f5 1f       	adc	r31, r21
    13ba:	80 85       	ldd	r24, Z+8	; 0x08
    13bc:	91 85       	ldd	r25, Z+9	; 0x09
    13be:	28 85       	ldd	r18, Y+8	; 0x08
    13c0:	39 85       	ldd	r19, Y+9	; 0x09
    13c2:	82 2b       	or	r24, r18
    13c4:	93 2b       	or	r25, r19
    13c6:	91 87       	std	Z+9, r25	; 0x09
    13c8:	80 87       	std	Z+8, r24	; 0x08
		buttonStringPatterns[*buttonToAssign][5] |= stringState[5];
    13ca:	8d 91       	ld	r24, X+
    13cc:	9c 91       	ld	r25, X
    13ce:	11 97       	sbiw	r26, 0x01	; 1
    13d0:	fc 01       	movw	r30, r24
    13d2:	ee 0f       	add	r30, r30
    13d4:	ff 1f       	adc	r31, r31
    13d6:	e8 0f       	add	r30, r24
    13d8:	f9 1f       	adc	r31, r25
    13da:	ee 0f       	add	r30, r30
    13dc:	ff 1f       	adc	r31, r31
    13de:	ee 0f       	add	r30, r30
    13e0:	ff 1f       	adc	r31, r31
    13e2:	e4 0f       	add	r30, r20
    13e4:	f5 1f       	adc	r31, r21
    13e6:	82 85       	ldd	r24, Z+10	; 0x0a
    13e8:	93 85       	ldd	r25, Z+11	; 0x0b
    13ea:	2a 85       	ldd	r18, Y+10	; 0x0a
    13ec:	3b 85       	ldd	r19, Y+11	; 0x0b
    13ee:	82 2b       	or	r24, r18
    13f0:	93 2b       	or	r25, r19
    13f2:	93 87       	std	Z+11, r25	; 0x0b
    13f4:	82 87       	std	Z+10, r24	; 0x0a

		*plusLock = 1;  // we set up a lock, so we don't assign all the buttons at once
    13f6:	81 e0       	ldi	r24, 0x01	; 1
    13f8:	f7 01       	movw	r30, r14
    13fa:	80 83       	st	Z, r24
		*buttonToAssign += 1;
    13fc:	8d 91       	ld	r24, X+
    13fe:	9c 91       	ld	r25, X
    1400:	11 97       	sbiw	r26, 0x01	; 1
    1402:	01 96       	adiw	r24, 0x01	; 1
    1404:	8d 93       	st	X+, r24
    1406:	9c 93       	st	X, r25
    1408:	02 c0       	rjmp	.+4      	; 0x140e <configSetButtonData+0x2d8>
	}
	else if(data->plusOn == 0)
	{
		*plusLock = 0;
    140a:	e7 01       	movw	r28, r14
    140c:	18 82       	st	Y, r1
	}
	return;
}
    140e:	df 91       	pop	r29
    1410:	cf 91       	pop	r28
    1412:	0f 91       	pop	r16
    1414:	ff 90       	pop	r15
    1416:	ef 90       	pop	r14
    1418:	df 90       	pop	r13
    141a:	cf 90       	pop	r12
    141c:	bf 90       	pop	r11
    141e:	af 90       	pop	r10
    1420:	08 95       	ret

00001422 <usbFunctionSetup>:

/* ------------------------------------------------------------------------- */

usbMsgLen_t usbFunctionSetup(uchar data[8])
{
usbRequest_t    *rq = (void *)data;
    1422:	fc 01       	movw	r30, r24

    /* The following requests are never used. But since they are required by
     * the specification, we implement them in this example.
     */
    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* class request type */
    1424:	80 81       	ld	r24, Z
    1426:	80 76       	andi	r24, 0x60	; 96
    1428:	80 32       	cpi	r24, 0x20	; 32
    142a:	e1 f4       	brne	.+56     	; 0x1464 <usbFunctionSetup+0x42>
        //DBG1(0x50, &rq->bRequest, 1);   /* debug output: print our request */
        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
    142c:	81 81       	ldd	r24, Z+1	; 0x01
    142e:	81 30       	cpi	r24, 0x01	; 1
    1430:	41 f4       	brne	.+16     	; 0x1442 <usbFunctionSetup+0x20>
            /* we only have one report type, so don't look at wValue */
            usbMsgPtr = (void *)&reportBuffer;
    1432:	84 e0       	ldi	r24, 0x04	; 4
    1434:	91 e0       	ldi	r25, 0x01	; 1
    1436:	90 93 26 01 	sts	0x0126, r25
    143a:	80 93 25 01 	sts	0x0125, r24
    143e:	87 e0       	ldi	r24, 0x07	; 7
    1440:	08 95       	ret
            return sizeof(reportBuffer);
        }else if(rq->bRequest == USBRQ_HID_GET_IDLE){
    1442:	82 30       	cpi	r24, 0x02	; 2
    1444:	41 f4       	brne	.+16     	; 0x1456 <usbFunctionSetup+0x34>
            usbMsgPtr = &idleRate;
    1446:	82 e0       	ldi	r24, 0x02	; 2
    1448:	91 e0       	ldi	r25, 0x01	; 1
    144a:	90 93 26 01 	sts	0x0126, r25
    144e:	80 93 25 01 	sts	0x0125, r24
    1452:	81 e0       	ldi	r24, 0x01	; 1
    1454:	08 95       	ret
            return 1;
        }else if(rq->bRequest == USBRQ_HID_SET_IDLE){
    1456:	8a 30       	cpi	r24, 0x0A	; 10
    1458:	29 f4       	brne	.+10     	; 0x1464 <usbFunctionSetup+0x42>
            idleRate = rq->wValue.bytes[1];
    145a:	83 81       	ldd	r24, Z+3	; 0x03
    145c:	80 93 02 01 	sts	0x0102, r24
    1460:	80 e0       	ldi	r24, 0x00	; 0
    1462:	08 95       	ret
    1464:	80 e0       	ldi	r24, 0x00	; 0
        }
    }else{
        /* no vendor specific requests implemented */
    }
    return 0;   /* default for not implemented requests: return no data back to host */
}
    1466:	08 95       	ret

00001468 <sendData>:
	usbPoll();
}


void sendData(dataForController data)
{
    1468:	0f 93       	push	r16
    146a:	1f 93       	push	r17
    146c:	df 93       	push	r29
    146e:	cf 93       	push	r28
    1470:	cd b7       	in	r28, 0x3d	; 61
    1472:	de b7       	in	r29, 0x3e	; 62
    1474:	29 97       	sbiw	r28, 0x09	; 9
    1476:	0f b6       	in	r0, 0x3f	; 63
    1478:	f8 94       	cli
    147a:	de bf       	out	0x3e, r29	; 62
    147c:	0f be       	out	0x3f, r0	; 63
    147e:	cd bf       	out	0x3d, r28	; 61
    1480:	90 2f       	mov	r25, r16
    1482:	09 83       	std	Y+1, r16	; 0x01
    1484:	f1 2f       	mov	r31, r17
    1486:	1a 83       	std	Y+2, r17	; 0x02
    1488:	e2 2f       	mov	r30, r18
    148a:	2b 83       	std	Y+3, r18	; 0x03
    148c:	a3 2f       	mov	r26, r19
    148e:	3c 83       	std	Y+4, r19	; 0x04
    1490:	34 2f       	mov	r19, r20
    1492:	4d 83       	std	Y+5, r20	; 0x05
    1494:	b5 2f       	mov	r27, r21
    1496:	5e 83       	std	Y+6, r21	; 0x06
    1498:	46 2f       	mov	r20, r22
    149a:	6f 83       	std	Y+7, r22	; 0x07
    149c:	27 2f       	mov	r18, r23
    149e:	78 87       	std	Y+8, r23	; 0x08
    14a0:	89 87       	std	Y+9, r24	; 0x09
    14a2:	58 2f       	mov	r21, r24

       //set the buttons to all at default positions
        reportBuffer[0] = 0b00000000;
        reportBuffer[1] = 0b00000000;
    14a4:	10 92 05 01 	sts	0x0105, r1
        reportBuffer[2] = 0b00001000;
    14a8:	88 e0       	ldi	r24, 0x08	; 8
    14aa:	80 93 06 01 	sts	0x0106, r24
        reportBuffer[3] = 0b10000000;
    14ae:	80 e8       	ldi	r24, 0x80	; 128
    14b0:	80 93 07 01 	sts	0x0107, r24
        reportBuffer[4] = 0b10000000;
    14b4:	80 93 08 01 	sts	0x0108, r24
        reportBuffer[5] = 0b10000000;
    14b8:	80 93 09 01 	sts	0x0109, r24
        reportBuffer[6] = 0b00000000;
    14bc:	10 92 0a 01 	sts	0x010A, r1


        // Since 'colorOn' is 1 when a fret is pressed, we shift it to the proper place and | it to set the
        // corresponding button bit to one, which corresponds to a button press.
        reportBuffer[0] |= (data.orangeOn << ORANGE_BIT);
        reportBuffer[0] |= (data.blueOn << BLUE_BIT);
    14c0:	32 95       	swap	r19
    14c2:	30 7f       	andi	r19, 0xF0	; 240
    14c4:	3a 2b       	or	r19, r26
        reportBuffer[0] |= (data.yellowOn << YELLOW_BIT);
        reportBuffer[0] |= (data.redOn << RED_BIT);
        reportBuffer[0] |= (data.greenOn << GREEN_BIT);
    14c6:	ff 0f       	add	r31, r31
    14c8:	ff 0f       	add	r31, r31
    14ca:	ee 0f       	add	r30, r30
    14cc:	ee 0f       	add	r30, r30
    14ce:	ee 0f       	add	r30, r30
    14d0:	ef 2b       	or	r30, r31
    14d2:	99 0f       	add	r25, r25
    14d4:	9e 2b       	or	r25, r30
    14d6:	93 2b       	or	r25, r19
    14d8:	90 93 04 01 	sts	0x0104, r25

        // On the PS3, the strumming shows up as a hat switch, so we have to use conditionals for this..
        if (data.upOn)
    14dc:	bb 23       	and	r27, r27
    14de:	11 f0       	breq	.+4      	; 0x14e4 <sendData+0x7c>
                reportBuffer[2] = 0b00000000;
    14e0:	10 92 06 01 	sts	0x0106, r1
        if (data.downOn)
    14e4:	44 23       	and	r20, r20
    14e6:	19 f0       	breq	.+6      	; 0x14ee <sendData+0x86>
                reportBuffer[2] = 0b00000100;
    14e8:	84 e0       	ldi	r24, 0x04	; 4
    14ea:	80 93 06 01 	sts	0x0106, r24

        reportBuffer[1] |= (data.plusOn << PLUS_BIT);
    14ee:	22 0f       	add	r18, r18
    14f0:	80 91 05 01 	lds	r24, 0x0105
    14f4:	82 2b       	or	r24, r18
    14f6:	80 93 05 01 	sts	0x0105, r24
        reportBuffer[0] |= (data.minusOn << MINUS_BIT);
    14fa:	52 95       	swap	r21
    14fc:	55 0f       	add	r21, r21
    14fe:	50 7e       	andi	r21, 0xE0	; 224
    1500:	80 91 04 01 	lds	r24, 0x0104
    1504:	85 2b       	or	r24, r21
    1506:	80 93 04 01 	sts	0x0104, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    150a:	80 e4       	ldi	r24, 0x40	; 64
    150c:	9f e1       	ldi	r25, 0x1F	; 31
    150e:	01 97       	sbiw	r24, 0x01	; 1
    1510:	f1 f7       	brne	.-4      	; 0x150e <sendData+0xa6>
		//DEBUG STUFF
		//DDRC &= ~(1<<5); //Turn 5 on Port C to inputs
		//PORTC |= (1<<5); //Turn off the internal pullup resistor on pin 5
		_delay_ms(2);

		if (PINC & (1<<5))
    1512:	35 9b       	sbis	0x06, 5	; 6
    1514:	02 c0       	rjmp	.+4      	; 0x151a <sendData+0xb2>
		{
			PORTB &= ~1; // Turn off LED
    1516:	28 98       	cbi	0x05, 0	; 5
    1518:	04 c0       	rjmp	.+8      	; 0x1522 <sendData+0xba>
			//reportBuffer.dx = 0;
		}
		else
		{
           reportBuffer[2] = 0b00000100; //Down
    151a:	84 e0       	ldi	r24, 0x04	; 4
    151c:	80 93 06 01 	sts	0x0106, r24
			PORTB |= 1; // Turn on the LED if we're grounded
    1520:	28 9a       	sbi	0x05, 0	; 5
		}

        //Then we finish off some USB stuff.
        wdt_reset();  //Reset the watchdog timer
    1522:	a8 95       	wdr
        usbPoll();    //USB poll - must be called at least once per 10ms
    1524:	0e 94 d6 0a 	call	0x15ac	; 0x15ac <usbPoll>

        // Now, regardless of mode, we have to send the data to the 
        // USB controlling library from the buffer we've been building
        if(usbInterruptIsReady())
    1528:	80 91 16 01 	lds	r24, 0x0116
    152c:	84 ff       	sbrs	r24, 4
    152e:	05 c0       	rjmp	.+10     	; 0x153a <sendData+0xd2>
        {
            /* called after every poll of the interrupt endpoint */
            usbSetInterrupt((void *)&reportBuffer, sizeof(reportBuffer));
    1530:	84 e0       	ldi	r24, 0x04	; 4
    1532:	91 e0       	ldi	r25, 0x01	; 1
    1534:	67 e0       	ldi	r22, 0x07	; 7
    1536:	0e 94 04 0c 	call	0x1808	; 0x1808 <usbSetInterrupt>
        }
                

}
    153a:	29 96       	adiw	r28, 0x09	; 9
    153c:	0f b6       	in	r0, 0x3f	; 63
    153e:	f8 94       	cli
    1540:	de bf       	out	0x3e, r29	; 62
    1542:	0f be       	out	0x3f, r0	; 63
    1544:	cd bf       	out	0x3d, r28	; 61
    1546:	cf 91       	pop	r28
    1548:	df 91       	pop	r29
    154a:	1f 91       	pop	r17
    154c:	0f 91       	pop	r16
    154e:	08 95       	ret

00001550 <startCommunication>:
	reportBuffer[5] = 0b10000000;
	reportBuffer[6] = 0b00000000;
*/

    // First, set up all the USB communication stuff
    wdt_enable(WDTO_1S);
    1550:	2e e0       	ldi	r18, 0x0E	; 14
    1552:	88 e1       	ldi	r24, 0x18	; 24
    1554:	90 e0       	ldi	r25, 0x00	; 0
    1556:	0f b6       	in	r0, 0x3f	; 63
    1558:	f8 94       	cli
    155a:	a8 95       	wdr
    155c:	80 93 60 00 	sts	0x0060, r24
    1560:	0f be       	out	0x3f, r0	; 63
    1562:	20 93 60 00 	sts	0x0060, r18
     * RESET status: all port bits are inputs without pull-up.
     * That's the way we need D+ and D-. Therefore we don't need any
     * additional hardware initialization.
     */

    usbInit();
    1566:	0e 94 c5 0a 	call	0x158a	; 0x158a <usbInit>
    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
    156a:	54 9a       	sbi	0x0a, 4	; 10
    156c:	20 e0       	ldi	r18, 0x00	; 0
    156e:	40 ea       	ldi	r20, 0xA0	; 160
    1570:	5f e0       	ldi	r21, 0x0F	; 15
    1572:	04 c0       	rjmp	.+8      	; 0x157c <startCommunication+0x2c>
    uchar i = 0;
    while(--i){             /* fake USB disconnect for > 250 ms */
        wdt_reset();
    1574:	a8 95       	wdr
    1576:	ca 01       	movw	r24, r20
    1578:	01 97       	sbiw	r24, 0x01	; 1
    157a:	f1 f7       	brne	.-4      	; 0x1578 <startCommunication+0x28>
     */

    usbInit();
    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
    uchar i = 0;
    while(--i){             /* fake USB disconnect for > 250 ms */
    157c:	21 50       	subi	r18, 0x01	; 1
    157e:	d1 f7       	brne	.-12     	; 0x1574 <startCommunication+0x24>
        wdt_reset();
        _delay_ms(1);
    }
    usbDeviceConnect();
    1580:	54 98       	cbi	0x0a, 4	; 10
    sei();
    1582:	78 94       	sei
	usbPoll();
    1584:	0e 94 d6 0a 	call	0x15ac	; 0x15ac <usbPoll>
}
    1588:	08 95       	ret

0000158a <usbInit>:
/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbInit(void)
{
#if USB_INTR_CFG_SET != 0
    USB_INTR_CFG |= USB_INTR_CFG_SET;
    158a:	e9 e6       	ldi	r30, 0x69	; 105
    158c:	f0 e0       	ldi	r31, 0x00	; 0
    158e:	80 81       	ld	r24, Z
    1590:	8c 60       	ori	r24, 0x0C	; 12
    1592:	80 83       	st	Z, r24
#endif
#if USB_INTR_CFG_CLR != 0
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
    1594:	e9 9a       	sbi	0x1d, 1	; 29
/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    1596:	8b e4       	ldi	r24, 0x4B	; 75
    1598:	80 93 17 01 	sts	0x0117, r24
#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    159c:	80 93 42 01 	sts	0x0142, r24
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
    usbResetDataToggling();
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    usbTxLen1 = USBPID_NAK;
    15a0:	8a e5       	ldi	r24, 0x5A	; 90
    15a2:	80 93 16 01 	sts	0x0116, r24
#if USB_CFG_HAVE_INTRIN_ENDPOINT3
    usbTxLen3 = USBPID_NAK;
    15a6:	80 93 41 01 	sts	0x0141, r24
#endif
#endif
}
    15aa:	08 95       	ret

000015ac <usbPoll>:
}

/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbPoll(void)
{
    15ac:	1f 93       	push	r17
    15ae:	cf 93       	push	r28
    15b0:	df 93       	push	r29
schar   len;
uchar   i;

    len = usbRxLen - 3;
    15b2:	90 91 27 01 	lds	r25, 0x0127
    15b6:	93 50       	subi	r25, 0x03	; 3
    if(len >= 0){
    15b8:	97 fd       	sbrc	r25, 7
    15ba:	a8 c0       	rjmp	.+336    	; 0x170c <usbPoll+0x160>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
    15bc:	20 91 24 01 	lds	r18, 0x0124
    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
        usbFunctionWriteOut(data, len);
        return;
    }
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
    15c0:	80 91 23 01 	lds	r24, 0x0123
    15c4:	8d 32       	cpi	r24, 0x2D	; 45
    15c6:	09 f0       	breq	.+2      	; 0x15ca <usbPoll+0x1e>
    15c8:	9f c0       	rjmp	.+318    	; 0x1708 <usbPoll+0x15c>
        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
    15ca:	98 30       	cpi	r25, 0x08	; 8
    15cc:	09 f0       	breq	.+2      	; 0x15d0 <usbPoll+0x24>
    15ce:	9c c0       	rjmp	.+312    	; 0x1708 <usbPoll+0x15c>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
    15d0:	cc e0       	ldi	r28, 0x0C	; 12
    15d2:	d0 e0       	ldi	r29, 0x00	; 0
    15d4:	c2 1b       	sub	r28, r18
    15d6:	d1 09       	sbc	r29, r1
    15d8:	c5 5d       	subi	r28, 0xD5	; 213
    15da:	de 4f       	sbci	r29, 0xFE	; 254
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
            return;
        usbMsgLen_t replyLen;
        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
    15dc:	83 ec       	ldi	r24, 0xC3	; 195
    15de:	80 93 0b 01 	sts	0x010B, r24
        usbTxLen = USBPID_NAK;              /* abort pending transmit */
    15e2:	8a e5       	ldi	r24, 0x5A	; 90
    15e4:	80 93 00 01 	sts	0x0100, r24
        usbMsgFlags = 0;
    15e8:	10 92 03 01 	sts	0x0103, r1
        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
    15ec:	88 81       	ld	r24, Y
    15ee:	80 76       	andi	r24, 0x60	; 96
    15f0:	29 f0       	breq	.+10     	; 0x15fc <usbPoll+0x50>
            replyLen = usbFunctionSetup(data);
    15f2:	ce 01       	movw	r24, r28
    15f4:	0e 94 11 0a 	call	0x1422	; 0x1422 <usbFunctionSetup>
    15f8:	28 2f       	mov	r18, r24
    15fa:	7d c0       	rjmp	.+250    	; 0x16f6 <usbPoll+0x14a>
 * standard requests instead of class and custom requests.
 */
static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
{
uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffer */
uchar   value = rq->wValue.bytes[0];
    15fc:	9a 81       	ldd	r25, Y+2	; 0x02
#if USB_CFG_IMPLEMENT_HALT
uchar   index = rq->wIndex.bytes[0];
#endif

    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
    15fe:	10 92 14 01 	sts	0x0114, r1
    SWITCH_START(rq->bRequest)
    1602:	89 81       	ldd	r24, Y+1	; 0x01
    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
    1604:	88 23       	and	r24, r24
    1606:	21 f4       	brne	.+8      	; 0x1610 <usbPoll+0x64>
            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
#if USB_CFG_IMPLEMENT_HALT
        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
            dataPtr[0] = usbTxLen1 == USBPID_STALL;
#endif
        dataPtr[1] = 0;
    1608:	10 92 15 01 	sts	0x0115, r1
    160c:	22 e0       	ldi	r18, 0x02	; 2
    160e:	6d c0       	rjmp	.+218    	; 0x16ea <usbPoll+0x13e>
        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
            usbResetDataToggling();
        }
#endif
    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
    1610:	85 30       	cpi	r24, 0x05	; 5
    1612:	19 f4       	brne	.+6      	; 0x161a <usbPoll+0x6e>
        usbNewDeviceAddr = value;
    1614:	90 93 28 01 	sts	0x0128, r25
    1618:	67 c0       	rjmp	.+206    	; 0x16e8 <usbPoll+0x13c>
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
    161a:	86 30       	cpi	r24, 0x06	; 6
    161c:	09 f0       	breq	.+2      	; 0x1620 <usbPoll+0x74>
    161e:	4e c0       	rjmp	.+156    	; 0x16bc <usbPoll+0x110>
static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
{
usbMsgLen_t len = 0;
uchar       flags = USB_FLG_MSGPTR_IS_ROM;

    SWITCH_START(rq->wValue.bytes[1])
    1620:	8b 81       	ldd	r24, Y+3	; 0x03
    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
    1622:	81 30       	cpi	r24, 0x01	; 1
    1624:	41 f4       	brne	.+16     	; 0x1636 <usbPoll+0x8a>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
    1626:	86 ee       	ldi	r24, 0xE6	; 230
    1628:	90 e0       	ldi	r25, 0x00	; 0
    162a:	90 93 26 01 	sts	0x0126, r25
    162e:	80 93 25 01 	sts	0x0125, r24
    1632:	22 e1       	ldi	r18, 0x12	; 18
    1634:	3f c0       	rjmp	.+126    	; 0x16b4 <usbPoll+0x108>
    SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
    1636:	82 30       	cpi	r24, 0x02	; 2
    1638:	41 f4       	brne	.+16     	; 0x164a <usbPoll+0x9e>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
    163a:	88 ef       	ldi	r24, 0xF8	; 248
    163c:	90 e0       	ldi	r25, 0x00	; 0
    163e:	90 93 26 01 	sts	0x0126, r25
    1642:	80 93 25 01 	sts	0x0125, r24
    1646:	29 e2       	ldi	r18, 0x29	; 41
    1648:	35 c0       	rjmp	.+106    	; 0x16b4 <usbPoll+0x108>
    SWITCH_CASE(USBDESCR_STRING)    /* 3 */
    164a:	83 30       	cpi	r24, 0x03	; 3
    164c:	f1 f4       	brne	.+60     	; 0x168a <usbPoll+0xde>
        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
            flags = 0;
        len = usbFunctionDescriptor(rq);
#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
        SWITCH_START(rq->wValue.bytes[0])
        SWITCH_CASE(0)
    164e:	99 23       	and	r25, r25
    1650:	41 f4       	brne	.+16     	; 0x1662 <usbPoll+0xb6>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
    1652:	82 eb       	ldi	r24, 0xB2	; 178
    1654:	90 e0       	ldi	r25, 0x00	; 0
    1656:	90 93 26 01 	sts	0x0126, r25
    165a:	80 93 25 01 	sts	0x0125, r24
    165e:	24 e0       	ldi	r18, 0x04	; 4
    1660:	29 c0       	rjmp	.+82     	; 0x16b4 <usbPoll+0x108>
        SWITCH_CASE(1)
    1662:	91 30       	cpi	r25, 0x01	; 1
    1664:	41 f4       	brne	.+16     	; 0x1676 <usbPoll+0xca>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
    1666:	86 eb       	ldi	r24, 0xB6	; 182
    1668:	90 e0       	ldi	r25, 0x00	; 0
    166a:	90 93 26 01 	sts	0x0126, r25
    166e:	80 93 25 01 	sts	0x0125, r24
    1672:	2c e1       	ldi	r18, 0x1C	; 28
    1674:	1f c0       	rjmp	.+62     	; 0x16b4 <usbPoll+0x108>
        SWITCH_CASE(2)
    1676:	92 30       	cpi	r25, 0x02	; 2
    1678:	e1 f4       	brne	.+56     	; 0x16b2 <usbPoll+0x106>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
    167a:	82 ed       	ldi	r24, 0xD2	; 210
    167c:	90 e0       	ldi	r25, 0x00	; 0
    167e:	90 93 26 01 	sts	0x0126, r25
    1682:	80 93 25 01 	sts	0x0125, r24
    1686:	24 e1       	ldi	r18, 0x14	; 20
    1688:	15 c0       	rjmp	.+42     	; 0x16b4 <usbPoll+0x108>
                len = usbFunctionDescriptor(rq);
            }
        SWITCH_END
#endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
#if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
    SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
    168a:	81 32       	cpi	r24, 0x21	; 33
    168c:	41 f4       	brne	.+16     	; 0x169e <usbPoll+0xf2>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
    168e:	8a e0       	ldi	r24, 0x0A	; 10
    1690:	91 e0       	ldi	r25, 0x01	; 1
    1692:	90 93 26 01 	sts	0x0126, r25
    1696:	80 93 25 01 	sts	0x0125, r24
    169a:	29 e0       	ldi	r18, 0x09	; 9
    169c:	0b c0       	rjmp	.+22     	; 0x16b4 <usbPoll+0x108>
    SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
    169e:	82 32       	cpi	r24, 0x22	; 34
    16a0:	41 f4       	brne	.+16     	; 0x16b2 <usbPoll+0x106>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
    16a2:	88 e6       	ldi	r24, 0x68	; 104
    16a4:	90 e0       	ldi	r25, 0x00	; 0
    16a6:	90 93 26 01 	sts	0x0126, r25
    16aa:	80 93 25 01 	sts	0x0125, r24
    16ae:	2a e4       	ldi	r18, 0x4A	; 74
    16b0:	01 c0       	rjmp	.+2      	; 0x16b4 <usbPoll+0x108>
    16b2:	20 e0       	ldi	r18, 0x00	; 0
    SWITCH_DEFAULT
        if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
            len = usbFunctionDescriptor(rq);
        }
    SWITCH_END
    usbMsgFlags = flags;
    16b4:	80 e4       	ldi	r24, 0x40	; 64
    16b6:	80 93 03 01 	sts	0x0103, r24
    16ba:	1d c0       	rjmp	.+58     	; 0x16f6 <usbPoll+0x14a>
        usbNewDeviceAddr = value;
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
        len = usbDriverDescriptor(rq);
        goto skipMsgPtrAssignment;
    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
    16bc:	88 30       	cpi	r24, 0x08	; 8
    16be:	21 f4       	brne	.+8      	; 0x16c8 <usbPoll+0x11c>
    16c0:	21 e0       	ldi	r18, 0x01	; 1
    16c2:	8a e2       	ldi	r24, 0x2A	; 42
    16c4:	91 e0       	ldi	r25, 0x01	; 1
    16c6:	13 c0       	rjmp	.+38     	; 0x16ee <usbPoll+0x142>
        dataPtr = &usbConfiguration;  /* send current configuration value */
        len = 1;
    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
    16c8:	89 30       	cpi	r24, 0x09	; 9
    16ca:	19 f4       	brne	.+6      	; 0x16d2 <usbPoll+0x126>
        usbConfiguration = value;
    16cc:	90 93 2a 01 	sts	0x012A, r25
    16d0:	0b c0       	rjmp	.+22     	; 0x16e8 <usbPoll+0x13c>
        usbResetStall();
    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
    16d2:	8a 30       	cpi	r24, 0x0A	; 10
    16d4:	11 f4       	brne	.+4      	; 0x16da <usbPoll+0x12e>
    16d6:	21 e0       	ldi	r18, 0x01	; 1
    16d8:	08 c0       	rjmp	.+16     	; 0x16ea <usbPoll+0x13e>
        len = 1;
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
    16da:	8b 30       	cpi	r24, 0x0B	; 11
    16dc:	29 f4       	brne	.+10     	; 0x16e8 <usbPoll+0x13c>
/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    16de:	8b e4       	ldi	r24, 0x4B	; 75
    16e0:	80 93 17 01 	sts	0x0117, r24
#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
    16e4:	80 93 42 01 	sts	0x0142, r24
    16e8:	20 e0       	ldi	r18, 0x00	; 0
    16ea:	84 e1       	ldi	r24, 0x14	; 20
    16ec:	91 e0       	ldi	r25, 0x01	; 1
        usbResetStall();
#endif
    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
        /* Should we add an optional hook here? */
    SWITCH_END
    usbMsgPtr = dataPtr;
    16ee:	90 93 26 01 	sts	0x0126, r25
    16f2:	80 93 25 01 	sts	0x0125, r24
            }
            usbMsgFlags = USB_FLG_USE_USER_RW;
        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */
#endif
        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */
    16f6:	8f 81       	ldd	r24, Y+7	; 0x07
    16f8:	88 23       	and	r24, r24
    16fa:	21 f4       	brne	.+8      	; 0x1704 <usbPoll+0x158>
    16fc:	8e 81       	ldd	r24, Y+6	; 0x06
    16fe:	82 17       	cp	r24, r18
    1700:	08 f4       	brcc	.+2      	; 0x1704 <usbPoll+0x158>
    1702:	28 2f       	mov	r18, r24
                replyLen = rq->wLength.bytes[0];
        }else{
            if(replyLen > rq->wLength.word)     /* limit length to max */
                replyLen = rq->wLength.word;
        }
        usbMsgLen = replyLen;
    1704:	20 93 01 01 	sts	0x0101, r18
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
#if USB_CFG_HAVE_FLOWCONTROL
        if(usbRxLen > 0)    /* only mark as available if not inactivated */
            usbRxLen = 0;
#else
        usbRxLen = 0;       /* mark rx buffer as available */
    1708:	10 92 27 01 	sts	0x0127, r1
#endif
    }
    if(usbTxLen & 0x10){    /* transmit system idle */
    170c:	80 91 00 01 	lds	r24, 0x0100
    1710:	84 ff       	sbrs	r24, 4
    1712:	4a c0       	rjmp	.+148    	; 0x17a8 <usbPoll+0x1fc>
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
    1714:	80 91 01 01 	lds	r24, 0x0101
    1718:	8f 3f       	cpi	r24, 0xFF	; 255
    171a:	09 f4       	brne	.+2      	; 0x171e <usbPoll+0x172>
    171c:	45 c0       	rjmp	.+138    	; 0x17a8 <usbPoll+0x1fc>
    171e:	18 2f       	mov	r17, r24
    1720:	89 30       	cpi	r24, 0x09	; 9
    1722:	08 f0       	brcs	.+2      	; 0x1726 <usbPoll+0x17a>
    1724:	18 e0       	ldi	r17, 0x08	; 8
uchar       len;

    wantLen = usbMsgLen;
    if(wantLen > 8)
        wantLen = 8;
    usbMsgLen -= wantLen;
    1726:	81 1b       	sub	r24, r17
    1728:	80 93 01 01 	sts	0x0101, r24
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    172c:	80 91 0b 01 	lds	r24, 0x010B
    1730:	98 e8       	ldi	r25, 0x88	; 136
    1732:	89 27       	eor	r24, r25
    1734:	80 93 0b 01 	sts	0x010B, r24
/* This function is similar to usbFunctionRead(), but it's also called for
 * data handled automatically by the driver (e.g. descriptor reads).
 */
static uchar usbDeviceRead(uchar *data, uchar len)
{
    if(len > 0){    /* don't bother app with 0 sized reads */
    1738:	11 23       	and	r17, r17
    173a:	41 f1       	breq	.+80     	; 0x178c <usbPoll+0x1e0>
        if(usbMsgFlags & USB_FLG_USE_USER_RW){
            len = usbFunctionRead(data, len);
        }else
#endif
        {
            uchar i = len, *r = usbMsgPtr;
    173c:	20 91 25 01 	lds	r18, 0x0125
    1740:	30 91 26 01 	lds	r19, 0x0126
            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
    1744:	80 91 03 01 	lds	r24, 0x0103
    1748:	86 ff       	sbrs	r24, 6
    174a:	0d c0       	rjmp	.+26     	; 0x1766 <usbPoll+0x1ba>
    174c:	ac e0       	ldi	r26, 0x0C	; 12
    174e:	b1 e0       	ldi	r27, 0x01	; 1
    1750:	80 e0       	ldi	r24, 0x00	; 0
    1752:	90 e0       	ldi	r25, 0x00	; 0
                do{
                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */
    1754:	f9 01       	movw	r30, r18
    1756:	e8 0f       	add	r30, r24
    1758:	f9 1f       	adc	r31, r25
    175a:	e4 91       	lpm	r30, Z+
                    *data++ = c;
    175c:	ed 93       	st	X+, r30
    175e:	01 96       	adiw	r24, 0x01	; 1
                    r++;
                }while(--i);
    1760:	18 17       	cp	r17, r24
    1762:	c1 f7       	brne	.-16     	; 0x1754 <usbPoll+0x1a8>
    1764:	08 c0       	rjmp	.+16     	; 0x1776 <usbPoll+0x1ca>
    1766:	91 2f       	mov	r25, r17
    1768:	d9 01       	movw	r26, r18
    176a:	ec e0       	ldi	r30, 0x0C	; 12
    176c:	f1 e0       	ldi	r31, 0x01	; 1
            }else{  /* RAM data */
                do{
                    *data++ = *r++;
    176e:	8d 91       	ld	r24, X+
    1770:	81 93       	st	Z+, r24
                }while(--i);
    1772:	91 50       	subi	r25, 0x01	; 1
    1774:	e1 f7       	brne	.-8      	; 0x176e <usbPoll+0x1c2>
    1776:	11 50       	subi	r17, 0x01	; 1
    1778:	81 2f       	mov	r24, r17
    177a:	90 e0       	ldi	r25, 0x00	; 0
    177c:	1f 5f       	subi	r17, 0xFF	; 255
    177e:	01 96       	adiw	r24, 0x01	; 1
    1780:	82 0f       	add	r24, r18
    1782:	93 1f       	adc	r25, r19
            }
            usbMsgPtr = r;
    1784:	90 93 26 01 	sts	0x0126, r25
    1788:	80 93 25 01 	sts	0x0125, r24
        wantLen = 8;
    usbMsgLen -= wantLen;
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    len = usbDeviceRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
        usbCrc16Append(&usbTxBuf[1], len);
    178c:	8c e0       	ldi	r24, 0x0C	; 12
    178e:	91 e0       	ldi	r25, 0x01	; 1
    1790:	61 2f       	mov	r22, r17
    1792:	0e 94 3b 0c 	call	0x1876	; 0x1876 <usbCrc16Append>
        len += 4;           /* length including sync byte */
    1796:	61 2f       	mov	r22, r17
    1798:	6c 5f       	subi	r22, 0xFC	; 252
        if(len < 12)        /* a partial package identifies end of message */
    179a:	6c 30       	cpi	r22, 0x0C	; 12
    179c:	19 f0       	breq	.+6      	; 0x17a4 <usbPoll+0x1f8>
            usbMsgLen = USB_NO_MSG;
    179e:	8f ef       	ldi	r24, 0xFF	; 255
    17a0:	80 93 01 01 	sts	0x0101, r24
    }else{
        len = USBPID_STALL;   /* stall the endpoint */
        usbMsgLen = USB_NO_MSG;
    }
    usbTxLen = len;
    17a4:	60 93 00 01 	sts	0x0100, r22
    17a8:	94 e1       	ldi	r25, 0x14	; 20
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 20; i > 0; i--){
        uchar usbLineStatus = USBIN & USBMASK;
    17aa:	89 b1       	in	r24, 0x09	; 9
        if(usbLineStatus != 0)  /* SE0 has ended */
    17ac:	88 71       	andi	r24, 0x18	; 24
    17ae:	31 f4       	brne	.+12     	; 0x17bc <usbPoll+0x210>
    if(usbTxLen & 0x10){    /* transmit system idle */
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 20; i > 0; i--){
    17b0:	91 50       	subi	r25, 0x01	; 1
    17b2:	d9 f7       	brne	.-10     	; 0x17aa <usbPoll+0x1fe>
        uchar usbLineStatus = USBIN & USBMASK;
        if(usbLineStatus != 0)  /* SE0 has ended */
            goto isNotReset;
    }
    /* RESET condition, called multiple times during reset */
    usbNewDeviceAddr = 0;
    17b4:	10 92 28 01 	sts	0x0128, r1
    usbDeviceAddr = 0;
    17b8:	10 92 22 01 	sts	0x0122, r1
    usbResetStall();
    DBG1(0xff, 0, 0);
isNotReset:
    usbHandleResetHook(i);
}
    17bc:	df 91       	pop	r29
    17be:	cf 91       	pop	r28
    17c0:	1f 91       	pop	r17
    17c2:	08 95       	ret

000017c4 <usbSetInterrupt3>:
}
#endif

#if USB_CFG_HAVE_INTRIN_ENDPOINT3
USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
{
    17c4:	1f 93       	push	r17
    17c6:	dc 01       	movw	r26, r24
    17c8:	16 2f       	mov	r17, r22

#if USB_CFG_IMPLEMENT_HALT
    if(usbTxLen1 == USBPID_STALL)
        return;
#endif
    if(txStatus->len & 0x10){   /* packet buffer was empty */
    17ca:	80 91 41 01 	lds	r24, 0x0141
    17ce:	84 ff       	sbrs	r24, 4
    17d0:	07 c0       	rjmp	.+14     	; 0x17e0 <usbSetInterrupt3+0x1c>
        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
    17d2:	80 91 42 01 	lds	r24, 0x0142
    17d6:	98 e8       	ldi	r25, 0x88	; 136
    17d8:	89 27       	eor	r24, r25
    17da:	80 93 42 01 	sts	0x0142, r24
    17de:	03 c0       	rjmp	.+6      	; 0x17e6 <usbSetInterrupt3+0x22>
    }else{
        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
    17e0:	8a e5       	ldi	r24, 0x5A	; 90
    17e2:	80 93 41 01 	sts	0x0141, r24
    17e6:	91 2f       	mov	r25, r17
    17e8:	e3 e4       	ldi	r30, 0x43	; 67
    17ea:	f1 e0       	ldi	r31, 0x01	; 1
    }
    p = txStatus->buffer + 1;
    i = len;
    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
        *p++ = *data++;
    17ec:	8d 91       	ld	r24, X+
    17ee:	81 93       	st	Z+, r24
    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
    17f0:	91 50       	subi	r25, 0x01	; 1
    17f2:	e1 f7       	brne	.-8      	; 0x17ec <usbSetInterrupt3+0x28>
    usbCrc16Append(&txStatus->buffer[1], len);
    17f4:	83 e4       	ldi	r24, 0x43	; 67
    17f6:	91 e0       	ldi	r25, 0x01	; 1
    17f8:	61 2f       	mov	r22, r17
    17fa:	0e 94 3b 0c 	call	0x1876	; 0x1876 <usbCrc16Append>
    txStatus->len = len + 4;    /* len must be given including sync byte */
    17fe:	1c 5f       	subi	r17, 0xFC	; 252
    1800:	10 93 41 01 	sts	0x0141, r17

#if USB_CFG_HAVE_INTRIN_ENDPOINT3
USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
{
    usbGenericSetInterrupt(data, len, &usbTxStatus3);
}
    1804:	1f 91       	pop	r17
    1806:	08 95       	ret

00001808 <usbSetInterrupt>:
    txStatus->len = len + 4;    /* len must be given including sync byte */
    DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
}

USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
{
    1808:	1f 93       	push	r17
    180a:	dc 01       	movw	r26, r24
    180c:	16 2f       	mov	r17, r22

#if USB_CFG_IMPLEMENT_HALT
    if(usbTxLen1 == USBPID_STALL)
        return;
#endif
    if(txStatus->len & 0x10){   /* packet buffer was empty */
    180e:	80 91 16 01 	lds	r24, 0x0116
    1812:	84 ff       	sbrs	r24, 4
    1814:	07 c0       	rjmp	.+14     	; 0x1824 <usbSetInterrupt+0x1c>
        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
    1816:	80 91 17 01 	lds	r24, 0x0117
    181a:	98 e8       	ldi	r25, 0x88	; 136
    181c:	89 27       	eor	r24, r25
    181e:	80 93 17 01 	sts	0x0117, r24
    1822:	03 c0       	rjmp	.+6      	; 0x182a <usbSetInterrupt+0x22>
    }else{
        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
    1824:	8a e5       	ldi	r24, 0x5A	; 90
    1826:	80 93 16 01 	sts	0x0116, r24
    182a:	91 2f       	mov	r25, r17
    182c:	e8 e1       	ldi	r30, 0x18	; 24
    182e:	f1 e0       	ldi	r31, 0x01	; 1
    }
    p = txStatus->buffer + 1;
    i = len;
    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
        *p++ = *data++;
    1830:	8d 91       	ld	r24, X+
    1832:	81 93       	st	Z+, r24
    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
    1834:	91 50       	subi	r25, 0x01	; 1
    1836:	e1 f7       	brne	.-8      	; 0x1830 <usbSetInterrupt+0x28>
    usbCrc16Append(&txStatus->buffer[1], len);
    1838:	88 e1       	ldi	r24, 0x18	; 24
    183a:	91 e0       	ldi	r25, 0x01	; 1
    183c:	61 2f       	mov	r22, r17
    183e:	0e 94 3b 0c 	call	0x1876	; 0x1876 <usbCrc16Append>
    txStatus->len = len + 4;    /* len must be given including sync byte */
    1842:	1c 5f       	subi	r17, 0xFC	; 252
    1844:	10 93 16 01 	sts	0x0116, r17
}

USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
{
    usbGenericSetInterrupt(data, len, &usbTxStatus1);
}
    1848:	1f 91       	pop	r17
    184a:	08 95       	ret

0000184c <usbCrc16>:
    184c:	a8 2f       	mov	r26, r24
    184e:	b9 2f       	mov	r27, r25
    1850:	80 e0       	ldi	r24, 0x00	; 0
    1852:	90 e0       	ldi	r25, 0x00	; 0
    1854:	41 e0       	ldi	r20, 0x01	; 1
    1856:	50 ea       	ldi	r21, 0xA0	; 160
    1858:	60 95       	com	r22
    185a:	30 e0       	ldi	r19, 0x00	; 0
    185c:	09 c0       	rjmp	.+18     	; 0x1870 <usbCrcLoopEntry>

0000185e <usbCrcByteLoop>:
    185e:	2d 91       	ld	r18, X+
    1860:	82 27       	eor	r24, r18

00001862 <usbCrcBitLoop>:
    1862:	97 95       	ror	r25
    1864:	87 95       	ror	r24
    1866:	10 f0       	brcs	.+4      	; 0x186c <usbCrcNoXor>
    1868:	84 27       	eor	r24, r20
    186a:	95 27       	eor	r25, r21

0000186c <usbCrcNoXor>:
    186c:	30 5e       	subi	r19, 0xE0	; 224
    186e:	c8 f3       	brcs	.-14     	; 0x1862 <usbCrcBitLoop>

00001870 <usbCrcLoopEntry>:
    1870:	6f 5f       	subi	r22, 0xFF	; 255
    1872:	a8 f3       	brcs	.-22     	; 0x185e <usbCrcByteLoop>

00001874 <usbCrcReady>:
    1874:	08 95       	ret

00001876 <usbCrc16Append>:
    1876:	ea df       	rcall	.-44     	; 0x184c <usbCrc16>
    1878:	8d 93       	st	X+, r24
    187a:	9d 93       	st	X+, r25
    187c:	08 95       	ret

0000187e <__vector_2>:
    187e:	cf 93       	push	r28
    1880:	cf b7       	in	r28, 0x3f	; 63
    1882:	cf 93       	push	r28
    1884:	df 93       	push	r29

00001886 <waitForJ>:
    1886:	c3 95       	inc	r28
    1888:	4c 9b       	sbis	0x09, 4	; 9
    188a:	e9 f7       	brne	.-6      	; 0x1886 <waitForJ>

0000188c <waitForK>:
    188c:	4c 9b       	sbis	0x09, 4	; 9
    188e:	0b c0       	rjmp	.+22     	; 0x18a6 <foundK>
    1890:	4c 9b       	sbis	0x09, 4	; 9
    1892:	09 c0       	rjmp	.+18     	; 0x18a6 <foundK>
    1894:	4c 9b       	sbis	0x09, 4	; 9
    1896:	07 c0       	rjmp	.+14     	; 0x18a6 <foundK>
    1898:	4c 9b       	sbis	0x09, 4	; 9
    189a:	05 c0       	rjmp	.+10     	; 0x18a6 <foundK>
    189c:	4c 9b       	sbis	0x09, 4	; 9
    189e:	03 c0       	rjmp	.+6      	; 0x18a6 <foundK>
    18a0:	4c 9b       	sbis	0x09, 4	; 9
    18a2:	01 c0       	rjmp	.+2      	; 0x18a6 <foundK>
    18a4:	8b c0       	rjmp	.+278    	; 0x19bc <sofError>

000018a6 <foundK>:
    18a6:	6f 93       	push	r22
    18a8:	c0 91 24 01 	lds	r28, 0x0124
    18ac:	dd 27       	eor	r29, r29
    18ae:	c5 5d       	subi	r28, 0xD5	; 213
    18b0:	de 4f       	sbci	r29, 0xFE	; 254
    18b2:	2f 93       	push	r18
    18b4:	65 e5       	ldi	r22, 0x55	; 85
    18b6:	4c 9b       	sbis	0x09, 4	; 9
    18b8:	03 c0       	rjmp	.+6      	; 0x18c0 <haveTwoBitsK>
    18ba:	2f 91       	pop	r18
    18bc:	6f 91       	pop	r22
    18be:	e6 cf       	rjmp	.-52     	; 0x188c <waitForK>

000018c0 <haveTwoBitsK>:
    18c0:	0f 93       	push	r16
    18c2:	1f 93       	push	r17
    18c4:	4f 93       	push	r20
    18c6:	20 e0       	ldi	r18, 0x00	; 0
    18c8:	40 e1       	ldi	r20, 0x10	; 16
    18ca:	5f 93       	push	r21
    18cc:	09 b1       	in	r16, 0x09	; 9
    18ce:	08 71       	andi	r16, 0x18	; 24
    18d0:	04 fb       	bst	r16, 4
    18d2:	27 f9       	bld	r18, 7
    18d4:	3f 93       	push	r19
    18d6:	50 e0       	ldi	r21, 0x00	; 0
    18d8:	3b e0       	ldi	r19, 0x0B	; 11
    18da:	39 c0       	rjmp	.+114    	; 0x194e <rxbit1>

000018dc <unstuff6>:
    18dc:	18 71       	andi	r17, 0x18	; 24
    18de:	40 64       	ori	r20, 0x40	; 64
    18e0:	2f 77       	andi	r18, 0x7F	; 127
    18e2:	01 2f       	mov	r16, r17
    18e4:	5f 5f       	subi	r21, 0xFF	; 255
    18e6:	1e c0       	rjmp	.+60     	; 0x1924 <didUnstuff6>

000018e8 <unstuff7>:
    18e8:	40 68       	ori	r20, 0x80	; 128
    18ea:	19 b1       	in	r17, 0x09	; 9
    18ec:	18 71       	andi	r17, 0x18	; 24
    18ee:	2f 77       	andi	r18, 0x7F	; 127
    18f0:	52 50       	subi	r21, 0x02	; 2
    18f2:	1f c0       	rjmp	.+62     	; 0x1932 <didUnstuff7>

000018f4 <unstuffEven>:
    18f4:	40 64       	ori	r20, 0x40	; 64
    18f6:	09 b1       	in	r16, 0x09	; 9
    18f8:	2f 77       	andi	r18, 0x7F	; 127
    18fa:	08 71       	andi	r16, 0x18	; 24
    18fc:	d1 f1       	breq	.+116    	; 0x1972 <se0>
    18fe:	5f 5f       	subi	r21, 0xFF	; 255
    1900:	00 c0       	rjmp	.+0      	; 0x1902 <unstuffEven+0xe>
    1902:	23 c0       	rjmp	.+70     	; 0x194a <didUnstuffE>

00001904 <unstuffOdd>:
    1904:	40 62       	ori	r20, 0x20	; 32
    1906:	19 b1       	in	r17, 0x09	; 9
    1908:	2f 77       	andi	r18, 0x7F	; 127
    190a:	18 71       	andi	r17, 0x18	; 24
    190c:	91 f1       	breq	.+100    	; 0x1972 <se0>
    190e:	5f 5f       	subi	r21, 0xFF	; 255
    1910:	00 c0       	rjmp	.+0      	; 0x1912 <unstuffOdd+0xe>
    1912:	25 c0       	rjmp	.+74     	; 0x195e <didUnstuffO>

00001914 <rxByteLoop>:
    1914:	08 71       	andi	r16, 0x18	; 24
    1916:	10 27       	eor	r17, r16
    1918:	51 50       	subi	r21, 0x01	; 1
    191a:	12 f4       	brpl	.+4      	; 0x1920 <skipLeap>
    191c:	5d 5f       	subi	r21, 0xFD	; 253
	...

00001920 <skipLeap>:
    1920:	11 50       	subi	r17, 0x01	; 1
    1922:	27 95       	ror	r18

00001924 <didUnstuff6>:
    1924:	2c 3f       	cpi	r18, 0xFC	; 252
    1926:	19 b1       	in	r17, 0x09	; 9
    1928:	c8 f6       	brcc	.-78     	; 0x18dc <unstuff6>
    192a:	18 71       	andi	r17, 0x18	; 24
    192c:	01 27       	eor	r16, r17
    192e:	01 50       	subi	r16, 0x01	; 1
    1930:	27 95       	ror	r18

00001932 <didUnstuff7>:
    1932:	2c 3f       	cpi	r18, 0xFC	; 252
    1934:	c8 f6       	brcc	.-78     	; 0x18e8 <unstuff7>
    1936:	42 27       	eor	r20, r18
    1938:	49 93       	st	Y+, r20

0000193a <rxBitLoop>:
    193a:	09 b1       	in	r16, 0x09	; 9
    193c:	08 71       	andi	r16, 0x18	; 24
    193e:	10 27       	eor	r17, r16
    1940:	4f 73       	andi	r20, 0x3F	; 63
    1942:	11 50       	subi	r17, 0x01	; 1
    1944:	27 95       	ror	r18
    1946:	2c 3f       	cpi	r18, 0xFC	; 252
    1948:	a8 f6       	brcc	.-86     	; 0x18f4 <unstuffEven>

0000194a <didUnstuffE>:
    194a:	46 95       	lsr	r20
    194c:	46 95       	lsr	r20

0000194e <rxbit1>:
    194e:	19 b1       	in	r17, 0x09	; 9
    1950:	18 71       	andi	r17, 0x18	; 24
    1952:	79 f0       	breq	.+30     	; 0x1972 <se0>
    1954:	01 27       	eor	r16, r17
    1956:	01 50       	subi	r16, 0x01	; 1
    1958:	27 95       	ror	r18
    195a:	2c 3f       	cpi	r18, 0xFC	; 252
    195c:	98 f6       	brcc	.-90     	; 0x1904 <unstuffOdd>

0000195e <didUnstuffO>:
    195e:	6b 5a       	subi	r22, 0xAB	; 171
    1960:	60 f3       	brcs	.-40     	; 0x193a <rxBitLoop>
    1962:	31 50       	subi	r19, 0x01	; 1
    1964:	09 b1       	in	r16, 0x09	; 9
    1966:	b0 f6       	brcc	.-84     	; 0x1914 <rxByteLoop>
    1968:	00 c0       	rjmp	.+0      	; 0x196a <overflow>

0000196a <overflow>:
    196a:	12 e0       	ldi	r17, 0x02	; 2
    196c:	1c bb       	out	0x1c, r17	; 28

0000196e <ignorePacket>:
    196e:	00 27       	eor	r16, r16
    1970:	19 c0       	rjmp	.+50     	; 0x19a4 <handleSetupOrOut>

00001972 <se0>:
    1972:	3b 50       	subi	r19, 0x0B	; 11
    1974:	31 95       	neg	r19
    1976:	c3 1b       	sub	r28, r19
    1978:	d0 40       	sbci	r29, 0x00	; 0
    197a:	12 e0       	ldi	r17, 0x02	; 2
    197c:	1c bb       	out	0x1c, r17	; 28
    197e:	08 81       	ld	r16, Y
    1980:	03 3c       	cpi	r16, 0xC3	; 195
    1982:	09 f1       	breq	.+66     	; 0x19c6 <handleData>
    1984:	0b 34       	cpi	r16, 0x4B	; 75
    1986:	f9 f0       	breq	.+62     	; 0x19c6 <handleData>
    1988:	20 91 22 01 	lds	r18, 0x0122
    198c:	19 81       	ldd	r17, Y+1	; 0x01
    198e:	11 0f       	add	r17, r17
    1990:	12 13       	cpse	r17, r18
    1992:	ed cf       	rjmp	.-38     	; 0x196e <ignorePacket>
    1994:	4a 81       	ldd	r20, Y+2	; 0x02
    1996:	44 1f       	adc	r20, r20
    1998:	09 36       	cpi	r16, 0x69	; 105
    199a:	51 f1       	breq	.+84     	; 0x19f0 <handleIn>
    199c:	0d 32       	cpi	r16, 0x2D	; 45
    199e:	11 f0       	breq	.+4      	; 0x19a4 <handleSetupOrOut>
    19a0:	01 3e       	cpi	r16, 0xE1	; 225
    19a2:	29 f7       	brne	.-54     	; 0x196e <ignorePacket>

000019a4 <handleSetupOrOut>:
    19a4:	00 93 29 01 	sts	0x0129, r16

000019a8 <doReturn>:
    19a8:	3f 91       	pop	r19
    19aa:	5f 91       	pop	r21
    19ac:	4f 91       	pop	r20
    19ae:	1f 91       	pop	r17
    19b0:	0f 91       	pop	r16
    19b2:	2f 91       	pop	r18
    19b4:	6f 91       	pop	r22
    19b6:	cc b3       	in	r28, 0x1c	; 28
    19b8:	c1 fd       	sbrc	r28, 1
    19ba:	65 cf       	rjmp	.-310    	; 0x1886 <waitForJ>

000019bc <sofError>:
    19bc:	df 91       	pop	r29
    19be:	cf 91       	pop	r28
    19c0:	cf bf       	out	0x3f, r28	; 63
    19c2:	cf 91       	pop	r28
    19c4:	18 95       	reti

000019c6 <handleData>:
    19c6:	20 91 29 01 	lds	r18, 0x0129
    19ca:	22 23       	and	r18, r18
    19cc:	69 f3       	breq	.-38     	; 0x19a8 <doReturn>
    19ce:	10 91 27 01 	lds	r17, 0x0127
    19d2:	11 23       	and	r17, r17
    19d4:	e9 f5       	brne	.+122    	; 0x1a50 <sendNakAndReti>
    19d6:	34 30       	cpi	r19, 0x04	; 4
    19d8:	ea f1       	brmi	.+122    	; 0x1a54 <sendAckAndReti>
    19da:	30 93 27 01 	sts	0x0127, r19
    19de:	20 93 23 01 	sts	0x0123, r18
    19e2:	10 91 24 01 	lds	r17, 0x0124
    19e6:	3b e0       	ldi	r19, 0x0B	; 11
    19e8:	31 1b       	sub	r19, r17
    19ea:	30 93 24 01 	sts	0x0124, r19
    19ee:	32 c0       	rjmp	.+100    	; 0x1a54 <sendAckAndReti>

000019f0 <handleIn>:
    19f0:	00 91 27 01 	lds	r16, 0x0127
    19f4:	01 30       	cpi	r16, 0x01	; 1
    19f6:	64 f5       	brge	.+88     	; 0x1a50 <sendNakAndReti>
    19f8:	0a e5       	ldi	r16, 0x5A	; 90
    19fa:	4f 70       	andi	r20, 0x0F	; 15
    19fc:	49 f4       	brne	.+18     	; 0x1a10 <handleIn1>
    19fe:	30 91 00 01 	lds	r19, 0x0100
    1a02:	34 fd       	sbrc	r19, 4
    1a04:	28 c0       	rjmp	.+80     	; 0x1a56 <sendCntAndReti>
    1a06:	00 93 00 01 	sts	0x0100, r16
    1a0a:	cb e0       	ldi	r28, 0x0B	; 11
    1a0c:	d1 e0       	ldi	r29, 0x01	; 1
    1a0e:	27 c0       	rjmp	.+78     	; 0x1a5e <usbSendAndReti>

00001a10 <handleIn1>:
    1a10:	41 35       	cpi	r20, 0x51	; 81
    1a12:	49 f0       	breq	.+18     	; 0x1a26 <handleIn3>
    1a14:	30 91 16 01 	lds	r19, 0x0116
    1a18:	34 fd       	sbrc	r19, 4
    1a1a:	1d c0       	rjmp	.+58     	; 0x1a56 <sendCntAndReti>
    1a1c:	00 93 16 01 	sts	0x0116, r16
    1a20:	c7 e1       	ldi	r28, 0x17	; 23
    1a22:	d1 e0       	ldi	r29, 0x01	; 1
    1a24:	1c c0       	rjmp	.+56     	; 0x1a5e <usbSendAndReti>

00001a26 <handleIn3>:
    1a26:	30 91 41 01 	lds	r19, 0x0141
    1a2a:	34 fd       	sbrc	r19, 4
    1a2c:	14 c0       	rjmp	.+40     	; 0x1a56 <sendCntAndReti>
    1a2e:	00 93 41 01 	sts	0x0141, r16
    1a32:	c2 e4       	ldi	r28, 0x42	; 66
    1a34:	d1 e0       	ldi	r29, 0x01	; 1
    1a36:	13 c0       	rjmp	.+38     	; 0x1a5e <usbSendAndReti>

00001a38 <bitstuffN>:
    1a38:	05 27       	eor	r16, r21
    1a3a:	10 e0       	ldi	r17, 0x00	; 0
    1a3c:	00 c0       	rjmp	.+0      	; 0x1a3e <bitstuffN+0x6>
    1a3e:	00 00       	nop
    1a40:	0b b9       	out	0x0b, r16	; 11
    1a42:	1a c0       	rjmp	.+52     	; 0x1a78 <didStuffN>

00001a44 <bitstuff6>:
    1a44:	05 27       	eor	r16, r21
    1a46:	10 e0       	ldi	r17, 0x00	; 0
    1a48:	22 1f       	adc	r18, r18
    1a4a:	1d c0       	rjmp	.+58     	; 0x1a86 <didStuff6>

00001a4c <bitstuff7>:
    1a4c:	10 e0       	ldi	r17, 0x00	; 0
    1a4e:	21 c0       	rjmp	.+66     	; 0x1a92 <didStuff7>

00001a50 <sendNakAndReti>:
    1a50:	4a e5       	ldi	r20, 0x5A	; 90
    1a52:	02 c0       	rjmp	.+4      	; 0x1a58 <sendX3AndReti>

00001a54 <sendAckAndReti>:
    1a54:	32 ed       	ldi	r19, 0xD2	; 210

00001a56 <sendCntAndReti>:
    1a56:	43 2f       	mov	r20, r19

00001a58 <sendX3AndReti>:
    1a58:	c4 e1       	ldi	r28, 0x14	; 20
    1a5a:	d0 e0       	ldi	r29, 0x00	; 0
    1a5c:	32 e0       	ldi	r19, 0x02	; 2

00001a5e <usbSendAndReti>:
    1a5e:	1a b1       	in	r17, 0x0a	; 10
    1a60:	18 61       	ori	r17, 0x18	; 24
    1a62:	5c 9a       	sbi	0x0b, 4	; 11
    1a64:	0b b1       	in	r16, 0x0b	; 11
    1a66:	1a b9       	out	0x0a, r17	; 10
    1a68:	58 e1       	ldi	r21, 0x18	; 24
    1a6a:	20 e8       	ldi	r18, 0x80	; 128

00001a6c <txByteLoop>:
    1a6c:	65 e3       	ldi	r22, 0x35	; 53

00001a6e <txBitLoop>:
    1a6e:	20 ff       	sbrs	r18, 0
    1a70:	05 27       	eor	r16, r21
    1a72:	0b b9       	out	0x0b, r16	; 11
    1a74:	27 95       	ror	r18
    1a76:	17 95       	ror	r17

00001a78 <didStuffN>:
    1a78:	1c 3f       	cpi	r17, 0xFC	; 252
    1a7a:	f0 f6       	brcc	.-68     	; 0x1a38 <bitstuffN>
    1a7c:	66 95       	lsr	r22
    1a7e:	b8 f7       	brcc	.-18     	; 0x1a6e <txBitLoop>
    1a80:	b1 f7       	brne	.-20     	; 0x1a6e <txBitLoop>
    1a82:	20 ff       	sbrs	r18, 0
    1a84:	05 27       	eor	r16, r21

00001a86 <didStuff6>:
    1a86:	0b b9       	out	0x0b, r16	; 11
    1a88:	27 95       	ror	r18
    1a8a:	17 95       	ror	r17
    1a8c:	1c 3f       	cpi	r17, 0xFC	; 252
    1a8e:	d0 f6       	brcc	.-76     	; 0x1a44 <bitstuff6>
    1a90:	27 95       	ror	r18

00001a92 <didStuff7>:
    1a92:	17 95       	ror	r17
    1a94:	17 ff       	sbrs	r17, 7
    1a96:	05 27       	eor	r16, r21
    1a98:	00 00       	nop
    1a9a:	1c 3f       	cpi	r17, 0xFC	; 252
    1a9c:	0b b9       	out	0x0b, r16	; 11
    1a9e:	b0 f6       	brcc	.-84     	; 0x1a4c <bitstuff7>
    1aa0:	29 91       	ld	r18, Y+
    1aa2:	3a 95       	dec	r19
    1aa4:	19 f7       	brne	.-58     	; 0x1a6c <txByteLoop>
    1aa6:	07 7e       	andi	r16, 0xE7	; 231
    1aa8:	10 91 28 01 	lds	r17, 0x0128
    1aac:	11 0f       	add	r17, r17
    1aae:	c6 51       	subi	r28, 0x16	; 22
    1ab0:	d0 40       	sbci	r29, 0x00	; 0
    1ab2:	0b b9       	out	0x0b, r16	; 11
    1ab4:	11 f0       	breq	.+4      	; 0x1aba <skipAddrAssign>
    1ab6:	10 93 22 01 	sts	0x0122, r17

00001aba <skipAddrAssign>:
    1aba:	12 e0       	ldi	r17, 0x02	; 2
    1abc:	1c bb       	out	0x1c, r17	; 28
    1abe:	00 61       	ori	r16, 0x10	; 16
    1ac0:	1a b1       	in	r17, 0x0a	; 10
    1ac2:	17 7e       	andi	r17, 0xE7	; 231
    1ac4:	40 2f       	mov	r20, r16
    1ac6:	47 7e       	andi	r20, 0xE7	; 231
    1ac8:	54 e0       	ldi	r21, 0x04	; 4

00001aca <se0Delay>:
    1aca:	5a 95       	dec	r21
    1acc:	f1 f7       	brne	.-4      	; 0x1aca <se0Delay>
    1ace:	0b b9       	out	0x0b, r16	; 11
    1ad0:	1a b9       	out	0x0a, r17	; 10
    1ad2:	4b b9       	out	0x0b, r20	; 11
    1ad4:	69 cf       	rjmp	.-302    	; 0x19a8 <doReturn>

00001ad6 <__eerd_block>:
    1ad6:	a0 e0       	ldi	r26, 0x00	; 0
    1ad8:	b0 e0       	ldi	r27, 0x00	; 0
    1ada:	e1 e7       	ldi	r30, 0x71	; 113
    1adc:	fd e0       	ldi	r31, 0x0D	; 13
    1ade:	0c 94 ad 0d 	jmp	0x1b5a	; 0x1b5a <__prologue_saves__+0x14>
    1ae2:	7c 01       	movw	r14, r24
    1ae4:	eb 01       	movw	r28, r22
    1ae6:	8a 01       	movw	r16, r20
    1ae8:	69 01       	movw	r12, r18
    1aea:	09 c0       	rjmp	.+18     	; 0x1afe <__eerd_block+0x28>
    1aec:	ce 01       	movw	r24, r28
    1aee:	21 96       	adiw	r28, 0x01	; 1
    1af0:	f6 01       	movw	r30, r12
    1af2:	09 95       	icall
    1af4:	f7 01       	movw	r30, r14
    1af6:	81 93       	st	Z+, r24
    1af8:	7f 01       	movw	r14, r30
    1afa:	01 50       	subi	r16, 0x01	; 1
    1afc:	10 40       	sbci	r17, 0x00	; 0
    1afe:	01 15       	cp	r16, r1
    1b00:	11 05       	cpc	r17, r1
    1b02:	a1 f7       	brne	.-24     	; 0x1aec <__eerd_block+0x16>
    1b04:	cd b7       	in	r28, 0x3d	; 61
    1b06:	de b7       	in	r29, 0x3e	; 62
    1b08:	e8 e0       	ldi	r30, 0x08	; 8
    1b0a:	0c 94 c9 0d 	jmp	0x1b92	; 0x1b92 <__epilogue_restores__+0x14>

00001b0e <__eewr_block>:
    1b0e:	a0 e0       	ldi	r26, 0x00	; 0
    1b10:	b0 e0       	ldi	r27, 0x00	; 0
    1b12:	ed e8       	ldi	r30, 0x8D	; 141
    1b14:	fd e0       	ldi	r31, 0x0D	; 13
    1b16:	0c 94 ad 0d 	jmp	0x1b5a	; 0x1b5a <__prologue_saves__+0x14>
    1b1a:	ec 01       	movw	r28, r24
    1b1c:	7b 01       	movw	r14, r22
    1b1e:	8a 01       	movw	r16, r20
    1b20:	69 01       	movw	r12, r18
    1b22:	09 c0       	rjmp	.+18     	; 0x1b36 <__eewr_block+0x28>
    1b24:	ce 01       	movw	r24, r28
    1b26:	21 96       	adiw	r28, 0x01	; 1
    1b28:	f7 01       	movw	r30, r14
    1b2a:	61 91       	ld	r22, Z+
    1b2c:	7f 01       	movw	r14, r30
    1b2e:	f6 01       	movw	r30, r12
    1b30:	09 95       	icall
    1b32:	01 50       	subi	r16, 0x01	; 1
    1b34:	10 40       	sbci	r17, 0x00	; 0
    1b36:	01 15       	cp	r16, r1
    1b38:	11 05       	cpc	r17, r1
    1b3a:	a1 f7       	brne	.-24     	; 0x1b24 <__eewr_block+0x16>
    1b3c:	cd b7       	in	r28, 0x3d	; 61
    1b3e:	de b7       	in	r29, 0x3e	; 62
    1b40:	e8 e0       	ldi	r30, 0x08	; 8
    1b42:	0c 94 c9 0d 	jmp	0x1b92	; 0x1b92 <__epilogue_restores__+0x14>

00001b46 <__prologue_saves__>:
    1b46:	2f 92       	push	r2
    1b48:	3f 92       	push	r3
    1b4a:	4f 92       	push	r4
    1b4c:	5f 92       	push	r5
    1b4e:	6f 92       	push	r6
    1b50:	7f 92       	push	r7
    1b52:	8f 92       	push	r8
    1b54:	9f 92       	push	r9
    1b56:	af 92       	push	r10
    1b58:	bf 92       	push	r11
    1b5a:	cf 92       	push	r12
    1b5c:	df 92       	push	r13
    1b5e:	ef 92       	push	r14
    1b60:	ff 92       	push	r15
    1b62:	0f 93       	push	r16
    1b64:	1f 93       	push	r17
    1b66:	cf 93       	push	r28
    1b68:	df 93       	push	r29
    1b6a:	cd b7       	in	r28, 0x3d	; 61
    1b6c:	de b7       	in	r29, 0x3e	; 62
    1b6e:	ca 1b       	sub	r28, r26
    1b70:	db 0b       	sbc	r29, r27
    1b72:	0f b6       	in	r0, 0x3f	; 63
    1b74:	f8 94       	cli
    1b76:	de bf       	out	0x3e, r29	; 62
    1b78:	0f be       	out	0x3f, r0	; 63
    1b7a:	cd bf       	out	0x3d, r28	; 61
    1b7c:	09 94       	ijmp

00001b7e <__epilogue_restores__>:
    1b7e:	2a 88       	ldd	r2, Y+18	; 0x12
    1b80:	39 88       	ldd	r3, Y+17	; 0x11
    1b82:	48 88       	ldd	r4, Y+16	; 0x10
    1b84:	5f 84       	ldd	r5, Y+15	; 0x0f
    1b86:	6e 84       	ldd	r6, Y+14	; 0x0e
    1b88:	7d 84       	ldd	r7, Y+13	; 0x0d
    1b8a:	8c 84       	ldd	r8, Y+12	; 0x0c
    1b8c:	9b 84       	ldd	r9, Y+11	; 0x0b
    1b8e:	aa 84       	ldd	r10, Y+10	; 0x0a
    1b90:	b9 84       	ldd	r11, Y+9	; 0x09
    1b92:	c8 84       	ldd	r12, Y+8	; 0x08
    1b94:	df 80       	ldd	r13, Y+7	; 0x07
    1b96:	ee 80       	ldd	r14, Y+6	; 0x06
    1b98:	fd 80       	ldd	r15, Y+5	; 0x05
    1b9a:	0c 81       	ldd	r16, Y+4	; 0x04
    1b9c:	1b 81       	ldd	r17, Y+3	; 0x03
    1b9e:	aa 81       	ldd	r26, Y+2	; 0x02
    1ba0:	b9 81       	ldd	r27, Y+1	; 0x01
    1ba2:	ce 0f       	add	r28, r30
    1ba4:	d1 1d       	adc	r29, r1
    1ba6:	0f b6       	in	r0, 0x3f	; 63
    1ba8:	f8 94       	cli
    1baa:	de bf       	out	0x3e, r29	; 62
    1bac:	0f be       	out	0x3f, r0	; 63
    1bae:	cd bf       	out	0x3d, r28	; 61
    1bb0:	ed 01       	movw	r28, r26
    1bb2:	08 95       	ret

00001bb4 <_exit>:
    1bb4:	f8 94       	cli

00001bb6 <__stop_program>:
    1bb6:	ff cf       	rjmp	.-2      	; 0x1bb6 <__stop_program>
